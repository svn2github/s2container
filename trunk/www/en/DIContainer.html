<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- don't edit start -->
<head><title>Seasar - DI Container with AOP - </title><meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
<meta http-equiv="Content-Style-Type" content="text/css">
<link href="seasar_p.css" type="text/css" rel="stylesheet" media="print">
<link href="seasar_b.css" type="text/css" rel="stylesheet" media="screen">
<script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script>
</head><body onload="preload('en')">
<img height="117" width="256" src="images/spacer.gif" alt=""><table width="100%" border="0" cellspacing="0" cellpadding="0" align="left"><tr>
<td align="left" valign="top" width="780"><table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr><td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt=""></td></tr>
<tr><td><img height="117" width="235" src="images/top02_b.gif" alt="Seasar"></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP"></td>
<td colspan="3">&nbsp;</td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td><a href="http://www.seasar.org/en/index.html"><img src="images/menu01_b_en.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)"></a></td>
<td><a href="http://www.seasar.org/en/projects.html"><img src="images/menu02_b_en.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)"></a></td>
<td><a href="http://www.seasar.org/en/products.html"><img src="images/menu06_b_en.gif" height="30" width="110" border="0" alt="" id="menu06" onmouseover="swap(6)" onmouseout="restore(6)"></a></td>
<td><a href="http://www.seasar.org/en/documents.html"><img src="images/menu04_b_en.gif" height="30" width="109" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)"></a></td>
<td><a href="http://www.seasar.org/en/resources.html"><img src="images/menu05_b_en.gif" height="30" width="113" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)"></a></td>
<!--
<td><img src="images/menu07_b_en.gif" height="30" width="109" border="0" alt=""  id="menu07" onmouseover="swap(7)" onmouseout="restore(7)"></td>
//-->
<td><img height="30" width="34" src="images/menu06.gif" alt=""></td></tr><tr>

<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt=""></td></tr></table>
<table  width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr align="left" valign="top"><td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td><td width="740" class="main">
<!-- don't edit end -->
<!-- document start -->
            <ul>
              <li><a href="#Quickstart">Quickstart</a>
			 　<ul>
				<li><a href="#FirstStep">First step</a>
				<li><a href="#NextStep">Next step</a>
　　　　　　　　</ul>
              </li>

              <li><a href="#S2ContainerReference">S2Container reference</a>
                <ul>
                  <li><a href="#CreateFile">作成すべきファイル</a></li>
                  <li><a href="#S2ContainerDefinition">S2Containerの定義</a></li>
                  <li><a href="#S2ContainerCreation">S2Containerの生成</a>
<ul>
<li><a href="#SingletonS2ContainerFactory">SingletonS2ContainerFactoryを使用する</a>
<li><a href="#S2ContainerFactory">S2ContainerFactoryを使用する</a>
</ul>
</li>
                  <li><a href="#getComponent">コンポーネントの取得</a></li>
                  <li><a href="#DIType">Dependency Injectionのタイプ</a>
                    <ul>
                      <li type="circle"><a href="#ConstructorInjection">コンストラクタ・インジェクション</a></li>
                      <li type="circle"><a href="#SetterInjection">セッター・インジェクション</a></li>
                      <li type="circle"><a href="#MethodInjection">メソッド・インジェクション</a></li>
                    </ul>
                  </li>
                  <li><a href="#Include">S2Container定義の分割とインクルード</a></li>
                  <li><a href="#Namespace">名前空間</a></li>
                  <li><a href="#InstanceMode">インスタンス管理</a></li>
                  <li><a href="#Lifecycle">ライフサイクル</a></li>
                  <li><a href="#AutoBindingMode">自動バインディング</a></li>
                  <li><a href="#UseS2Container">コンポーネントでS2Containerを利用する</a></li>
                  <li><a href="#S2ContainerServlet">S2ContainerServlet</a></li>
                  <li><a href="#app.dicon">app.diconの役割</a></li>
                  <li><a href="#Aop">AOPの適用</a></li>
				  <li><a href="#Meta">メタデータ</a></li>
				  <li><a href="#Request">Requestの自動バインディング</a></li>
				  <li><a href="#ComponentAutoRegister">コンポーネントの自動登録</a></li>
				  <li><a href="#AspectAutoRegister">アスペクトの自動登録</a></li>
				  <li><a href="#Hotswap">Hotswap</a></li>
                </ul>
              </li>
              <li><a href="#DefReference">S2Containerタグリファレンス</a>
                <ul>
                  <li><a href="#DOCTYPE">DOCTYPE</a></li>
                  <li><a href="#componentsTag">componentsタグ</a></li>
                  <li><a href="#includeTag">includeタグ</a></li>
                  <li><a href="#componentTag">componentタグ</a></li>
                  <li><a href="#argTag">argタグ</a></li>
                  <li><a href="#propertyTag">propertyタグ</a></li>
				  <li><a href="#metaTag">metaタグ</a></li>
                  <li><a href="#initMethodTag">initMethodタグ</a></li>
                  <li><a href="#destroyMethodTag">destroyMethodタグ</a></li>
                  <li><a href="#aspectTag">aspectタグ</a></li>
                  <li><a href="#descriptionTag">descriptionタグ</a></li>
                  <li><a href="#ognlExpr">OGNL式</a></li>
                </ul>
              </li>
			  <li><a href="#AnnotationReference">S2Containerアノテーションリファレンス</a>
                <ul>
                  <li><a href="#ComponentAnnotation">Componentアノテーション</a></li>
				  <li><a href="#BindingAnnotation">Bindingアノテーション</a></li>
				  <li><a href="#AspectAnnotation">Aspectアノテーション</a></li>
				</ul>
			  </li>
              <li>DIContainerエクササイズ</li>
            </ul>


<h2><a name="Quickstart">Quickstart</a></h2>
<p>S2Container is a light weight container for Dependency Injection (DI) operations. DI is an idea to separate the interface and implementation, to communicate with each other through the interface.</p>

<h3><a name="FirstStep">First Step</a></h3>
<p>Let us give this a try. The following objects will be used.</p>
<ul>
<li>Greeting Class
<ul>
<li>Returns a greeting string.</li>
</ul>
</li>

<li>Greeting Client Class
<ul>
<li>Outputs string obtained from the greeting class to console.</li>
</ul>
</li>

<li>Greeting Main Class
<ul>
<li>Startup Class. Also constructs greeting and greeting client class.
</li>
</ul>
</li>

</ul>
<h5>Greeting.java</h5>
<p>Greeting Interface.</p>
<pre>
package examples.di;

public interface Greeting {

    String greet();
}
</pre>

<h5>GreetingImpl.java</h5>
<p>Implementation of the greeting.</p>
<pre>
package examples.di.impl;

import examples.di.Greeting;

public class GreetingImpl implements Greeting {

    public String greet() {
        return "Hello World!";
    }
}
</pre>

<h5>GreetingClient.java</h5>
<p>Client interface to use the greeting.</p>
<pre>
package examples.di;

public interface GreetingClient {

    void execute();
}
</pre>

<h5>GreetingClientImpl.java</h5>
<p>Client implementation to use greeting. Instead of using Greeting Implementation (GreetingImpl) directly, the interface (Greeting) will be used. </p>
<pre>
package examples.di.impl;

import examples.di.Greeting;
import examples.di.GreetingClient;

public class GreetingClientImpl implements GreetingClient {

    private Greeting greeting;

    public void setGreeting(Greeting greeting) {
        this.greeting = greeting;
    }

    public void execute() {
        System.out.println(greeting.greet());
    }
}
</pre>

<p>Both function provider and user is prepared. Let us try running this. </p>
<h5>GreetingMain.java</h5>
<pre>
package examples.di.main;

import examples.di.Greeting;
import examples.di.impl.GreetingClientImpl;
import examples.di.impl.GreetingImpl;

public class GreetingMain {

    public static void main(String[] args) {
        Greeting greeting = new GreetingImpl();
        GreetingClientImpl greetingClient = new GreetingClientImpl();
        greetingClient.setGreeting(greeting);
        greetingClient.execute();
    }
}
</pre>
<p>The result will be as follows.</p>
<pre>
Hello World!
</pre>
<p>As shown here, the function user (GreetingClientImpl) uses the function through the interface (Greeting),
a third party (GreetingMain, in this case) provides the implementation object at runtime.
That is the basic style of DI </p>
<p>However, if one writes configurations into the source as GreetingMain,
the source code must be altered to reflect any changes.
DIContainer is used to avoid this.
DIContainer constructs objects by reading external configuration files.</p>
<p>We will write the configuration information into the configuration file.
That extension is &quot;.dicon&quot; in S2Container.</p>

<h5>GreetingMain2.dicon</h5>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE components PUBLIC<br>    &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;<br>    &quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;<br>&lt;components&gt;<br>    &lt;component name=&quot;greeting&quot;<br>        class=&quot;examples.di.impl.GreetingImpl&quot;/&gt;<br>    &lt;component name=&quot;greetingClient&quot;<br>        class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>        &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;
</pre>

<p>Look at <a href="#DefReference">S2Container Tag Reference</a> for details.
We will first describe the main points.</p>

<pre>&lt;component name=&quot;greeting&quot;<br>    class=&quot;examples.di.impl.GreetingImpl&quot;/&gt;
</pre>
<p>We define component as above. This is equivalent to the following Java code.</p>

<pre>
Greeting greeting = new GreetingImpl();
</pre>

<p>We define  a component name using the name property in the component tag, and a class name using the class property.
Next, we configure greetingClient.</p>

<pre>&lt;component name=&quot;greetingClient&quot;<br>    class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>    &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>&lt;/component&gt;
</pre>

<p>We define a property name using the name property in the property tag,
and specify the component name in the body. This is equivalent to the following Java code.
Take care not to surround the component name in double quotation marks,
as this will cause the contents to be interpreted as a string.</p>

<pre>GreetingClientImpl greetingClient = new GreetingClientImpl();
greetingClient.setGreeting(greeting);
</pre>

<p>The startup class using S2Container will be as follows.</p>
<h5>GreetingMain2.java</h5>
<pre>
package examples.di.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.di.GreetingClient;

public class GreetingMain2 {

    private static final String PATH =
        "examples/di/dicon/GreetingMain2.dicon";

    public static void main(String[] args) {
        S2Container container =
            S2ContainerFactory.create(PATH);
        GreetingClient greetingClient = (GreetingClient)
            container.getComponent("greetingClient");
        greetingClient.execute();
    }
}</pre>

<p>S2Container is created using S2ContainerFactor#create(String Path).
Read <a href="#S2ContainerCreation">Creating S2Container</a> for details.</p>

<p>The component(greetingClient) is acquired using S2Container#getComponent(String componentName).
Please reference <a href="#getComponent">Acquiring Components</a> for details.</p>

<p>As before, the result will be as follows.</p>
<pre>
Hello World!
</pre>

<p>AOP is often used with DI.
AOP is a technique to modularize the functions like logging that are spread over many classes.
We will now output a log (trace) from GreetingImpl, and GreetingClientImpl without altering the existing source code.
The configuration file with AOP will be as follows.</p>

<h5>GreetingMain3.dicon</h5>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE components PUBLIC<br>    &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;<br>    &quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;<br>&lt;components&gt;<br>    &lt;include path=&quot;aop.dicon&quot;/&gt;<br>    &lt;component name=&quot;greeting&quot;<br>        class=&quot;examples.di.impl.GreetingImpl&quot;&gt;<br>        &lt;aspect&gt;aop.traceInterceptor&lt;/aspect&gt;<br>    &lt;/component&gt;<br>    &lt;component name=&quot;greetingClient&quot;<br>        class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>        &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>        &lt;aspect&gt;aop.traceInterceptor&lt;/aspect&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;
</pre>

<p>Seasar2 contains commonly used AOP modules predefined within aop.dicon.
We use the include tag as follows.
Please reference <a href="#Include">S2Container Definition division and include</a> for details.</p>

<pre>&lt;include path=&quot;aop.dicon&quot;/&gt;
</pre>

<p>We define <a href="#aspectTag">the aspect tag</a> to apply AOP to a component, and specify the AOP module name in the body.
We will be using aop.traceInterceptor as the AOP module name.</p>

<pre>&lt;aspect&gt;aop.traceInterceptor&lt;/aspect&gt;
</pre>

<p>This concludes the configuration of AOP. We will now try running GreetingMain3.
The only difference from GreetingMain2 is the path of the configuration file.</p>

<h5>GreetingMain3.java</h5>
<pre>
package examples.di.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.di.GreetingClient;

public class GreetingMain3 {

    private static final String PATH =
        "examples/di/dicon/GreetingMain3.dicon";

    public static void main(String[] args) {
        S2Container container =
            S2ContainerFactory.create(PATH);
        GreetingClient greetingClient = (GreetingClient)
            container.getComponent("greetingClient");
        greetingClient.execute();
    }
}
</pre>

<p>The results will be as follows. We see the log output with no alteration to the original source code.</p>

<pre>
DEBUG 2005-10-11 21:01:49,655 [main] BEGIN examples.di.impl.GreetingClientImpl#execute()
DEBUG 2005-10-11 21:01:49,665 [main] BEGIN examples.di.impl.GreetingImpl#greet()
DEBUG 2005-10-11 21:01:49,665 [main] END examples.di.impl.GreetingImpl#greet() : Hello World!
Hello World!
DEBUG 2005-10-11 21:01:49,675 [main] END examples.di.impl.GreetingClientImpl#execute() : null
</pre>

<p>We have now mastered the basic use of S2Container.</p>

<h3><a name="NextStep">Next Step</a></h3>
<p>Writing the configuration file is still annoying, isn’t it?
S2Container also possesses the following concepts to minimize the amount of writing in configuration files.</p>

<ul>
<li><a name="CoC">Convention over Configuration</a></li>
</ul>

<p>This implements a number of practical conventions,
so that a program will run with no configuration as long as it follows these rules.
For example, the configuration file from earlier explicitly defines the property tag as follows.</p>

<pre>&lt;component name=&quot;greetingClient&quot;<br>    class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>    &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>&lt;/component&gt;
</pre>

<p>As long as the property type is interface and there is a component impementing interface in the container,
S2Container has a function to automatically DI.
This means S2Container will automatically process components as long as
they follow the DI convention of defining property type by interface.</p>

<p>"Convention" may sound annoying, but they are not only recommended but also making development easier.</p>

<p>We can simplify the configuration from above as follows.</p>
<pre>&lt;component name=&quot;greetingClient&quot;<br>    class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>&lt;/component&gt;
</pre>

<p>Actually, “Convention over Configuration” is used in the AOP example from earlier.
Normally, where (or which method) the AOP module is applied is defined in pointcut.
All methods defined by interface have the AOP module applied without the use of pointcut in <a href="aop.html">S2AOP</a>
as long as they follow the convention of using interface.
This is how there was no need to define a module in pointcut in the earlier example.</p>

<p>Using “Convention over Configuration” will simplify the configuration of DI and AOP.
However, component registration itself becomes a burden as the number of components increase.
The automation of this component registration is <a href="#ComponentAutoRegister">Component auto-registration</a> functionality.
The registration of GreetingImpl, GreetingClientImpl from earlier is automated as follows.</p>

<pre>&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister&quot;&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;/&gt;<br>&lt;/component&gt;</pre>

<p>This FileSystemComponentAutoRegister component searches classes defined in addClassPattern from the file system
and auto-registers them in S2Container.
Please refer to <a href="#MethodInjection">Method Injection</a> for details on the initMethod tag.</p>

<p>The first argument of addClassPattern method is the package name of the component to be auto-registered.
Child packages are also recursively searched.
The second argument is the class name, which may be a regular expression. 
Multiple definitions are separated by commas.</p>

<p>Auto-registration of components decreases the overall amount of work,
as the programmer is not required to configure anything for new components.</p>

<p>As we automate the registration of components,
next focus is the automation of aspect registration.
The configuration of <a href="#AspectAutoRegister">Aspect auto-registration</a> for GreetingImpl and GreetingClientImp is as follows.</p>

<pre>&lt;include path=&quot;aop.dicon&quot;/&gt;
...
&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.AspectAutoRegister&quot;&gt;<br>    &lt;property name=&quot;interceptor&quot;&gt;aop.traceInterceptor&lt;/property&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;/&gt;<br>&lt;/component&gt;
</pre>

<p>We specify the AOP module name in the interceptor property.
We will skip the explanation of the addClassPattern method, as it is identical to the component auto-registration.
The combination of component and aspect auto-registration looks like the following.</p>

<h5>GreetingMain4.dicon</h5>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot; <br>	&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;<br>    &lt;include path=&quot;aop.dicon&quot;/&gt;

    &lt;component<br>      class=&quot;org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister&quot;&gt;<br>        &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>            &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>            &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>        &lt;/initMethod&gt;<br>        &lt;initMethod name=&quot;registAll&quot;/&gt;<br>    &lt;/component&gt;

    &lt;component<br>      class=&quot;org.seasar.framework.container.autoregister.AspectAutoRegister&quot;&gt;<br>        &lt;property name=&quot;interceptor&quot;&gt;aop.traceInterceptor&lt;/property&gt;<br>        &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>            &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>            &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>        &lt;/initMethod&gt;<br>        &lt;initMethod name=&quot;registAll&quot;/&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;
</pre>

<p>We will now run GreetingMain4.
We must invoke S2Container#init() and S2Container#destroy() in the case of using auto-registration.</p>

<h5>GreetingMain4.java</h5>
<pre>
package examples.di.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.di.GreetingClient;

public class GreetingMain4 {

    private static final String PATH =
        "examples/di/dicon/GreetingMain4.dicon";

    public static void main(String[] args) {
        S2Container container =
            S2ContainerFactory.create(PATH);
        container.init();
        try {
            GreetingClient greetingClient = (GreetingClient)
                container.getComponent("greetingClient");
            greetingClient.execute();
        } finally {
            container.destroy();
        }
    }
}
</pre>

<p>The result will be identical to GreetingMain3 as follows.</p>
<pre>
DEBUG 2005-10-12 16:00:08,093 [main] BEGIN examples.di.impl.GreetingClientImpl#execute()
DEBUG 2005-10-12 16:00:08,103 [main] BEGIN examples.di.impl.GreetingImpl#greet()
DEBUG 2005-10-12 16:00:08,103 [main] END examples.di.impl.GreetingImpl#greet() : Hello World!
Hello World!
DEBUG 2005-10-12 16:00:08,103 [main] END examples.di.impl.GreetingClientImpl#execute() : null
</pre>

<p>Auto-registration and Auto-binding will work well in most cases.
Components can be excluded from auto-registration using the addIgnoreClassPattern method.</p>

<p><a href="#BindingAnnotation">Binding Annotation</a> can be used to fine tune configuration settings
without using configuration files for properties excluded from auto-binding.</p>

<p><a href="#Hotswap">Hotswap</a> can be used to retry immediately without restarting application
so that development is more efficient.</p>

<p>We have now mastered advanced use of S2Container. Please reference the manual as needed.</p>


<h2><a name="S2ContainerReference">S2Container Reference</a></h2>

<h3><a name="CreateFile">Files to be Created</a></h3>
<p>A definition file must be created in order to use S2Container.
A definition file is a XML file with a .dicon extension,
and serves as a blueprint for component creation.</p>

<h3><a name="S2ContainerDefinition">S2Container Definition</a></h3>
<p>The definition of S2Container is as follows.</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
            ...
    &lt;/component&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
            ...
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<p>DOCTYPE may not be abbreviated.
The above sample should be copied verbatim when creating a dicon file.
The root is the <a href="#componentsTag">components tag</a>.
We will define the component tag for every <a href="#componentTag">component tag</a>.
Please refer to the <a href="#DefReference">S2Container Definition Tag Reference</a> for additional details.</p>

<pre>
&lt;components&gt;
    &lt;component name=&quot;hoge&quot; class=&quot;examples.dicon.HogeImpl&quot;/&gt;
&lt;/components&gt;
</pre>

<h3><a name="S2ContainerCreation">S2Container Creation</a></h3>
<p>There are two methods of creating S2Container.</p>
<ul>
<li>Use SingletonS2ContainerFactory</li>
<li>Use S2ContainerFactory</li>
</ul>
<h4><a name="SingletonS2ContainerFactory">Using SingletonS2ContainerFactory</a></h4>
<p>We will use the following method when utilizing SingletonS2ContainerFactory.</p>
<p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#init()</p>
<p>app.dicon located in the directory as defined in CLASSPATH is used.</p>
<p>The created S2Container can be obtained by the following method from any location.</p>
<p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#getContainer()</p>
<pre>SingletonS2ContainerFactory.init();
...
S2Container container = SingletonS2ContainerFactory.getContainer();</pre>
<p>Use the following method before calling init() if specifying a path to the definition file.</p>
<p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#setConfigPath(String Path)</p>
<p>The arguments path is an absolute path of the definition file referencing the directory defined in CLASSPATH as root.
For example, WEB-INF/classes/aaa.dicon is aaa.dicon.  WEB-INF/classes/aaa/bbb/ccc.dicon becomes aaa/bbb/ccc.dicon.
The separator is “/” in both Windows and UNIX systems.</p>
<pre>private static final String PATH = &quot;aaa/bbb/ccc.dicon&quot;;
...
SingletonS2ContainerFactory.setConfigPath(PATH);
SingletonS2ContainerFactory.init();
...
S2Container container = SingletonS2ContainerFactory.getContainer();</pre>
<h4><a name="S2ContainerFactory">Using S2ContainerFactory</a></h4>
<p>We will use the following method when utilizing S2ContainerFactory.</p>
<p>- org.seasar.framework.container.factory.S2ContainerFactory#create(String path)</p>
<p>We will call the following method after creating S2Container.</p>
<p>- org.seasar.framework.container.S2Container#init()</p>
<pre>private static final String PATH = &quot;aaa/bbb/ccc.dicon&quot;;
...
S2Container container = S2ContainerFactory.create(PATH);
container.init();</pre>
<p>An instance of the container obtained using this method must be managed by an application.</p>

<h3><a name="getComponent">Acquiring Components</a></h3>
<p>To extract a component from S2Container, we use the following method.</p>
<p>- org.seasar.framework.container.S2Container#getComponent(Object componentKey)</p>

<p></p>
<p>A component name or component class can be specified as an argument. 
Please refer to <a href="#componentTag">component tag</a> for details.
When specifying a component class, the class must return true for the component class instanceof class. 
If there are multiple components that implement the specified class,
S2Container will fail to identify the target component and throw TooManyRegistrationRuntimeException.
Please specify a class that will uniquely identify an implemented component, or acquire using the component name.
If there are multiple components with identical names registered, S2Container will throw TooManyRegistrationRuntimeException as well.</p>

<h4>Example: When acquiring a component by class</h4>
<pre>
S2Container container = S2ContainerFactory.create(PATH);
Hoge hoge = (Hoge) container.getComponent(Hoge.class);
</pre>

<h4>Example: When acquiring a component by name</h4>
<pre>
S2Container container = S2ContainerFactory.create(PATH);
Hoge hoge = (Hoge) container.getComponent("hoge");
</pre>

<h3><a name="DIType">Dependency Injection Type</a></h3>
<p>
Dependency Injection has three different types, Constructor Injection, Setter Injection, and Method Injection.
Constructor Injection configures by the constructor,
Setter Injection configures by the setter method,
and Method Injection is configured by the initialization method.
Method injection is specific to S2Container.
S2Container supports all types and its hybrids.</p>

<h3><a name="ConstructorInjection">Constructor Injection</a></h3>
<p>Constructor Injection applies DI to the constructor arguments.
The following contents are written into the S2Container definition file.</p>
<ul>
<li><b>Specifying component</b><br/>
The component is constructed using the component tag. The class name is specified using the class property.
The name property can be used to give the component a name.</li>
<li><b>Specifying constructor argument</b><br/>
The arguments of the constructor are specified in the arg sub-tag of the component tag.
Strings are to be surrounded by double quotation marks (&quot;).</li>
</ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;arg&gt;...&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h3><a name="SetterInjection"><b>セッター･インジェクション</b></a></h3>
            <p>セッター･インジェクションとは、任意のプロパティにセッターメソッドを使用してDIを行います。<br/>
S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントの指定は、コンストラクタ・インジェクションと同様です。<br/>name属性でコンポーネントに名前を付けることもできます。</li>
            <li><b>プロパティの指定</b><br/>コンポーネントのプロパティは、componentタグの子タグであるpropertyタグを使って指定します。<br/>name属性でプロパティ名を指定します。</li>
         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;property name=&quot;...&quot;&gt;...&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h3><a name="MethodInjection"><b>メソッド・インジェクション</b></a></h3>
<p>メソッド・インジェクションとは、任意のメソッドを呼び出して、DIを行います。<br/>
S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントの指定は、コンストラクタ・インジェクションと同様です。<br/>name属性でコンポーネントに名前を付けることもできます。</li>
            <li><b>初期化メソッドの指定</b><br/>initMethodタグを使って、コンポーネントの任意のメソッドを呼び出します。name属性で、メソッド名を指定します。引数は、argタグを子タグに使います。name属性を省略して、ボディで、<a href="#ognlExpr">OGNL式</a>を使うこともできます。その際、コンポーネント自身は#selfで表します。</li>
         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;initMethod&gt;...&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h3><a name="Include">S2Container定義の分割とインクルード</a></h3>
<p>すべてのコンポーネントを1つのファイルに記述すると、直ぐに肥大化してしまい管理が難しくなります。そのため、コンポーネントの定義を複数に分割する機能と分割された定義をインクルードして1つにまとめる機能がS2Containerにあります。S2Container定義ファイルのインクルードは次のようにして行います。</p>

<pre>&lt;components&gt;
    &lt;include path=&quot;bar.dicon&quot;/&gt;
&lt;/components&gt;
</pre>

            <p><a href="#includeTag">includeタグ</a>のpath属性で取り込みたいS2Container定義ファイルのパスを指定します。詳しくは、<a href="#includeTag">includeタグ</a>を参照してください。<br/>コンポーネントの検索順は、先ず自分自身に登録されているコンポーネントを探して、見つからない場合は、includeされている順に子供のS2Containerに登録されているコンポーネントを検索し、最初に見つかったコンポーネントが返されます。<br/>次のような場合は、Foo(自身のコンポーネント)→aaa(子供のS2Container)→bbb(子供のS2Container)の順に検索します。</p>

<pre>
&lt;components&gt;
    &lt;include path=&quot;aaa.dicon&quot;/&gt;
    &lt;include path=&quot;bbb.dicon&quot;/&gt;
    &lt;component class=&quot;example.container.Foo&quot; /&gt;
&lt;/components&gt;
</pre>

            <p>自動で<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>や<a href="#SetterInjection">セッター・インジェクション</a>を行う場合、S2Containerはインクルード先のコンポーネントを自動インジェクションすることができます。自動でDependency Injectionを行う場合の条件は<a href="#AutoBindingMode">自動バインディング</a>を参照してください。<br/>次のようにセッター･インジェクションでプロパティに指定するコンポーネントがインクルード先のaaa.diconとbbb.diconに登録されている場合、各HelloClientでは、どちらのコンポーネントが使用されるかをみてましょう。</p>

            <h5>root.dicon</h5>
<pre>
&lt;components&gt;
    &lt;include path=&quot;examples/dicon/include/aaa.dicon&quot;/&gt;
    &lt;include path=&quot;examples/dicon/include/bbb.dicon&quot;/&gt;
    &lt;component name=&quot;root&quot; class=&quot;examples.dicon.include.RootHelloClient&quot;/&gt;
&lt;/components&gt;
</pre>

            <h5>aaa.dicon</h5>
<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.include.HelloImpl&quot;&gt;
        &lt;property name=&quot;Message&quot;&gt;&quot;Hello Aaa!&quot;&lt;/property&gt;
    &lt;/component&gt;

    &lt;component name=&quot;aaa&quot; class=&quot;examples.dicon.include.AaaHelloClient&quot;/&gt;
&lt;/components&gt;
</pre>

            <h5>bbb.dicon</h5>
<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.include.HelloImpl&quot;&gt;
        &lt;property name=&quot;Message&quot;&gt;&quot;Hello Bbb!&quot;&lt;/property&gt;
    &lt;/component&gt;

    &lt;component name=&quot;bbb&quot; class=&quot;examples.dicon.include.BbbHelloClient&quot;/&gt;
&lt;/components&gt;
</pre>

            <p>各コンポーネントの内容は、次のようになります。</p>

<pre>
package examples.dicon.include;

public interface HelloClient {
    public void showMessage();
}
</pre>

<pre>
package examples.dicon.include;

public class RootHelloClient implements HelloClient {

    private Hello hello_;

    public void setHello(Hello hello) {
        hello_ = hello;
    }

    public Hello getHello() {
        return hello_;
    }

    public void showMessage() {
        System.out.println(getHello().getMessage());
    }
}
</pre>

            <p>AaaHelloClientとBbbHelloClientはRootHelloClient同様の実装です。</p>

<pre>
package examples.dicon.include;

public interface Hello {
    public void setMessage(String helloMessage);
    public String getMessage();
}
</pre>

<pre>
package examples.dicon.include;

public class HelloImpl implements Hello {
    private String helloMessage_;

    public void setMessage(String helloMessage) {
        helloMessage_ = helloMessage;
    }

    public String getMessage() {
        return helloMessage_;
    }
}
</pre>

           <p>HelloImplはMessageプロパティを定義しているだけです。各HelloClientのshowMessage()を呼び出した場合の実行結果は次のようになります。</p>

           <h5>RootHelloClientの実行結果</h5>
<pre>
Hello Aaa!
</pre>
           <p>まず、S2Containerはroot.diconにHelloImplが登録されているかを検索します。root.diconにはないので、次にインクルード先のaaa.diconを検索します。aaa.diconにはHelloImplが登録されているので、そのコンポーネントを使用します。</p>

           <h5>AaaHelloClientの実行結果</h5>
<pre>
Hello Aaa!
</pre>

           <p>AaaHelloClientは、aaa.diconに登録されているコンポーネントを使用します。自動でインジェクションを行う場合、子供のS2Containerは親のS2Containerのコンポーネントを使用することはできません。例えば、root.diconにHelloImplを登録していてもAaaHelloClientには自動インジェクションされないということです。</p>

           <h5>BbbHelloClientの実行結果</h5>
<pre>
Hello Bbb!
</pre>

           <p>AaaHelloClientと同様にBbbHelloClientもbbb.diconに登録されているコンポーネントを使用します。</p>

            <h3><a name="Namespace">名前空間</a></h3>
            <p>コンポーネントの定義を分割した場合に、複数のコンポーネント定義間で名前が衝突しないように、<a href="#componentsTag">componentsタグ</a>のnamespace属性で名前空間を指定することができます。</p>
            <h5>foo.dicon</h5>
<pre>
&lt;components namespace=&quot;foo&quot;&gt;
    &lt;component name=&quot;aaa&quot; .../&gt;
    &lt;component name=&quot;bbb&quot; ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>bar.dicon</h5>

<pre>
&lt;components namespace=&quot;bar&quot;&gt;
    &lt;include path=&quot;foo.dicon&quot;/&gt;
    &lt;component name=&quot;aaa&quot; .../&gt;
    &lt;component name=&quot;bbb&quot; ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
    &lt;component name=&quot;ccc&quot; ...&gt;
        &lt;arg&gt;foo.aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>app.dicon</h5>

<pre>
&lt;components&gt;
    &lt;include path=&quot;bar.dicon&quot;/&gt;
&lt;/components&gt;
</pre>

            <p>同一のコンポーネント定義内では、名前空間なしで参照できます。他のS2Container定義のコンポーネントを参照する場合は、名前空間.をコンポーネント名の頭につけます。foo.aaaとbar.aaaは同じ名前がついていますが、名前空間が異なっているので、違うコンポーネントとして認識されます。慣習として、定義ファイルの名前は、名前空間.diconにすることを推奨します。</p>


<h3><a name="InstanceMode">インスタンス管理</a></h3>
            <p>S2Containerで、コンポーネントのインスタンスをどのように管理するのかを指定するのが、<a href="#componentTag">componentタグ</a>のinstance属性です。デフォルトはsingletonで、これは、S2Container.getComponent()によって返されるコンポーネントは常に同じだという意味です。S2Container.getComponent()を呼び出すたびに、新たに作成されたコンポーネントを返して欲しい場合は、instance属性にprototypeを指定します。リクエスト(HttpServletRequest)ごとにコンポーネントを管理したい場合は、instance属性にrequestを指定します。セッション(HttpSession)ごとにコンポーネントを管理したい場合は、instance属性にsessionを指定します。</p>
            <p>プレゼンテーションのフレームワークと組み合わせるときに、プレゼンテーションフレームワークが作成したインスタンスに対して、S2Containerで管理されているコンポーネントをセットしたい場合があります。そのようなS2Container外のコンポーネントに対して<a href="http://www.kakutani.com/trans/fowler/injection.html">Dependency Injection</a>したいときには、次のメソッドを使用します。<br/><br/>- org.seasar.framework.container.S2Container#injectDependency(Object outerComponent)<br/>- org.seasar.framework.container.S2Container#injectDependency(Object outerComponent, Class componentClass)<br/>- org.seasar.framework.container.S2Container#injectDependency(Object outerComponent, String componentName)</p>
            第一引数には、外部のコンポーネントを指定します。第二引数には、外部コンポーネントのクラス、またはコンポーネント名を指定します。<br/>そのとき、S2Container定義では、instance属性にouterを指定します。

<table width="744" border="1">
  <tr bgcolor="#d1f3f4" align="center">
    <th width="104" scope="col">instance属性</th>
    <th width="624" scope="col">説明</th>
  </tr>
  <tr>
    <td>singleton(default)</td>
    <td>S2Container.getComponent()を何度呼び出しても同じインスタンスが返されます。</td>
  </tr>
  <tr>
    <td>prototype</td>
    <td>S2Container.getComponent()を呼び出すたびに新たなインスタンスが返されます。</td>
  </tr>
  <tr>
<td>request</td>
<td>リクエスト毎に1つのインスタンスが作成されます。name属性に指定した名前で、コンポーネントがリクエストに格納されます。requestを使う場合は、<a href="#request">S2ContainerFilter</a>を設定する必要があります。</td>
</tr>
<tr>
<td>session</td>
<td>セッション毎に1つのインスタンスが作成されます。name属性に指定した名前で、コンポーネントがセッションに格納されます。sessionを使う場合は、<a href="#request">S2ContainerFilter</a>を設定する必要があります。</td>
</tr>
<tr>
  <td>outer</td>
  <td>コンポーネントのインスタンスは、S2Container外で作成し、Dependency Injectionだけを行います。<a href="#Aop">アスペクト</a>、<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>は適用できません。</td>
</tr>
</table>

            <h3><a name="Lifecycle">ライフサイクル</a></h3>
            <p>initMethodやdestroyMethodでコンポーネントのライフサイクルもコンテナで管理することができます。S2Containerの開始時(S2Container.init())に<a href="#initMethodTag">initMethodタグ</a>で指定したメソッドが呼び出され、S2Containerの終了時(S2Container.destroy())に<a href="#destroyMethodTag">destroyMethodタグ</a>で指定したメソッドが呼び出されるようになります。initMethodはコンポーネントがコンテナに登録した順番に実行され、destroyMethodはその逆順に呼び出されることになります。instance属性がsingleton以外の場合、destroyMethodを指定しても無視されます。java.util.HashMap#put()メソッドに初期化(aaaに111を設定)・終了処理(aaaにnullを設定)を設定する場合は、次のようになります。</p>
<pre>
&lt;components namespace=&quot;bar&quot;&gt;
    &lt;component name=&quot;map&quot; class=&quot;java.util.HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;destroyMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;null&lt;/arg&gt;
        &lt;/destroyMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            <h3><a name="AutoBindingMode">自動バインディング</a></h3>
            <p>コンポーネント間の依存関係は、型がインターフェースの場合、コンテナによって自動的に解決されます。これがS2Containerのデフォルトですが、<a href="#componentTag">componentタグ</a>のautoBinding属性を指定することで細かく制御することもできます。</p>

<table width="744" border="1">
<tr bgcolor="#d1f3f4" align="center">
<th width="104" scope="col">autoBinding</th>
<th width="624" scope="col">説明</th>
</tr>
<tr>
<td>auto(default)</td>
<td>
コンストラクタの自動バインディング､プロパティの自動バインディングが適用されます。
</td>
</tr>
<tr>
<td>constructor</td>
<td>コンストラクタの自動バインディングが適用されます。</td>
</tr>
<tr>
<td>property</td>
<td>プロパティの自動バインディングが適用されます。</td>
</tr>
<tr>
<td>none</td>
<td>コンストラクタ、プロパティの手動バインディングのみ。</td>
</tr>
</table>

<br />
<p>コンストラクタの自動バインディングのルールは次のようになります。</p>
<ul>
<li>コンストラクタの引数が明示的に指定されている場合は、それに従い、自動バインディングは適用されません。</li>
<li>上記に該当しない場合、引数のないデフォルトコンストラクタが定義されているなら、そのコンストラクタを使い、自動バインディングは適用されません。</li>
<li>上記に該当しない場合、コンストラクタの引数の数が1以上で、
引数の型がすべてインターフェースのコンストラクタで最も引数の数が多いコンストラクタを使います。そして、
引数の型を実装したコンポーネントをコンテナから取得して適用します。</li>
<li>上記に該当しない場合､自動バインディングは適用されません。</li>
</ul>

<p>プロパティの自動バインディングのルールは次のようになります。</p>
<ul>
<li>プロパティが明示的に指定されている場合は、それに従い、自動バインディングは適用されません。</li>
<li>上記に該当しない場合､プロパティ名と同一のコンポーネントがコンテナに登録されてプロパティに代入可能なら、
そのコンポーネントが適用されます。</li>
<li>上記に該当しない場合､プロパティの型がインターフェースでプロパティの型を実装したコンポーネントがコンテナに登録されていれば、
そのコンポーネントが適用されます。</li>
<li>上記に該当しない場合､自動バインディングは適用されません。</li>
</ul>
<p>propertyタグのbindingType属性で、プロパティごとに細かく制御することもできます。</p>
<table width="744" border="1">
<tr bgcolor="#d1f3f4" align="center">
<th width="104" scope="col">bindingType</th>
<th width="624" scope="col">説明</th>
</tr>
<tr>
<td>must</td>
<td>自動バインディングが適用されない場合､例外が発生します。
</td>
</tr>
<tr>
<td>should(default)</td>
<td>自動バインディングが適用されない場合､警告を通知します。</td>
</tr>
<tr>
<td>may</td>
<td>自動バインディングが適用されない場合､何もおきません。</td>
</tr>
<tr>
<td>none</td>
<td>autoBinding属性が、auto、propertyの場合でも､自動バインディングは適用されません。</td>
</tr>
</table>
<br/>

            <h3><a name="UseS2Container">コンポーネントでS2Containerを利用する</a></h3>
            <p>コンポーネントはS2Containerに依存しないことが望ましいのですが、コンポーネントによっては、S2Containerのメソッドを呼び出したい場合もあるでしょう。S2Container自身もcontainerという名前で、登録されているので、arg,propertyタグのボディでcontainerを指定することで、コンテナのインスタンスを取得できます。また、S2Container型のsetterメソッドを定義しておいて自動バインディングで設定することもできます。arg,propertyタグでcontainerを指定する場合は、次のようになります。</p>

<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.BarImpl&quot;&gt;
        &lt;arg&gt;container&lt;/arg&gt;
    &lt;/component&gt;

    &lt;component class=&quot;examples.dicon.FooImpl&quot;&gt;
        &lt;property name=&quot;foo&quot;&gt;container&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            <h3><a name="S2ContainerServlet">S2ContainerServlet</a></h3>
            <p>これまでは、Javaアプリケーションで、明示的にS2Containerを作成していましたが、Webアプリケーションの場合、誰がS2Containerを作成するのでしょうか。その目的のために次のクラスが用意されています。</p>
            <p>- org.seasar.framework.container.servlet#S2ContainerServlet</p>
            S2ContainerServletを使うためには、web.xmlに次の項目を記述します。<br/>src/org/seasar/framework/container/servlet/web.xmlに記述例もあります。

<pre>
&lt;servlet&gt;
    &lt;servlet-name&gt;s2servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.seasar.framework.container.servlet.S2ContainerServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;configPath&lt;/param-name&gt;
        &lt;param-value&gt;app.dicon&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;debug&lt;/param-name&gt;
        &lt;param-value&gt;false&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;s2servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/s2servlet&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre>

            <p>configPathでメインとなるS2Container定義のパスを指定します。定義ファイルはWEB-INF/classesにおきます。S2ContainerServletは、他のサーブレットよりもはやく起動されるようにload-on-startupタグを調整してください。S2ContainerServletが起動した後は、次のメソッドでS2Containerのインスタンスを取得することができます。</p>
            <p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#getContainer()</p>
            <p>また、S2Containerのライフサイクルは、S2ContainerServletと連動します。debugパラメータをtrueにすると、次のようにして、稼動中にS2Containerを再起動できます。xxxはWebアプリケーションのコンテキスト名です。</p>
			<pre>http://localhost:8080/xxx/s2servlet?command=restart
            </pre>
            <p>S2ContainerServletを使っている場合、ServletContextをservletContextという名前のコンポーネントとしてアクセスできるようになります。</p>

            <h3><a name="app.dicon">app.diconの役割</a></h3>
            <p>すべてのS2Container定義のルートになる定義ファイルは、慣例でapp.diconという名前にします。app.diconにはコンポーネントの定義はしないようにしてください。通常はWEB-INF/classesにおくと良いでしょう。</p>

<pre>
&lt;components&gt;
    &lt;include path=&quot;examples/foo.dicon&quot;/&gt;
    &lt;include path=&quot;examples/bar.dicon&quot;/&gt;
          ...
&lt;/components&gt;
</pre>

<h3><a name="Aop">AOPの適用</a></h3>
<p>コンポーネントに<a href="aop.html">AOP</a>を適用することもできます。例えば、ArrayListに<a href="aop.html#TraceInterceptor">TraceInterceptor</a>を適用したい場合次のようにします。</p>

<pre>
&lt;components&gt;
    &lt;component name=&quot;traceInterceptor&quot;
               class=&quot;org.seasar.framework.aop.interceptors.TraceInterceptor&quot;/&gt;
    &lt;component class=&quot;java.util.ArrayList&quot;&gt;
        &lt;aspect&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;
    &lt;component class=&quot;java.util.Date&quot;&gt;
        &lt;arg&gt;0&lt;/arg&gt;
        &lt;aspect pointcut=&quot;getTime, hashCode&quot;&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<p>aspectタグのボディで<a href="aop.html#Advice">Interceptor</a>の名前を指定します。pointcut属性にカンマ区切りで対象となるメソッド名を指定することができます。pointcut属性を指定しない場合は、コンポーネントが実装しているインターフェースのすべてのメソッドが対象になります。メソッド名には正規表現(JDK1.4のregex)も使えます。この定義を使うサンプルは次のようになります。</p>

<pre>
private static final String PATH =
    &quot;examples/dicon/Aop.dicon&quot;;
S2Container container = S2ContainerFactory.create(PATH);
List list = (List) container.getComponent(List.class);
list.size();
Date date = (Date) container.getComponent(Date.class);
date.getTime();
date.hashCode();
date.toString();
</pre>

            <p>実行結果は次のようになります。</p>

<pre>
BEGIN java.util.ArrayList#size()
END java.util.ArrayList#size() : 0
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
BEGIN java.util.Date#hashCode()
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
END java.util.Date#hashCode() : 0
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
</pre>


<h3><a name="Meta">メタデータ</a></h3>

<p>components、component、arg、propertyタグにメタデータ<a href="aop.html"></a>を指定することもできます。metaタグはメタデータを指定したいタグの子タグに指定します。例えば、componentsタグにメタデータを指定したい場合次のようにします。</p>

<pre>&lt;components&gt;
    &lt;meta name=&quot;aaa&quot;&gt;111&lt;/meta&gt;
&lt;/components&gt;
</pre>
<p>components、component、arg、propertyタグに指定したメタデータの情報は、S2Container、ComponentDef、ArgDef、PropertyDefで定義されている次のメソッドで取得することが出来ます。</p>
<ul>
<li>public int getMetaDefSize()</li>
<li>public MetaDef getMetaDef(int index)</li>
<li>public MetaDef getMetaDef(String name)</li>
<li>public MetaDef[] getMetaDefs(String name)</li>
</ul>


<h3><a name="request">リクエストの自動バインディング</a></h3>
<p>コンポーネントに対して、HttpServletRequestを自動的にバインディングすることが出来ます。そのためには、コンポーネントに、setRequest(HttpServletRequest request)のメソッドを定義します。そうすると、S2Containerが自動的にリクエストを設定します。また、次のようにFilterをweb.xmlに定義する必要があります。</p>
<pre>&lt;web-app&gt;
<br>    &lt;filter&gt;<br>        &lt;filter-name&gt;s2filter&lt;/filter-name&gt;<br>        &lt;filter-class&gt;org.seasar.framework.container.filter.S2ContainerFilter&lt;/filter-class&gt;<br>    &lt;/filter&gt;<br>    <br>    &lt;filter-mapping&gt;<br>        &lt;filter-name&gt;s2filter&lt;/filter-name&gt;<br>        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;<br>    &lt;/filter-mapping&gt;<br>&lt;/web-app&gt;
</pre>
<p>同様にHttpServletResponse、HttpSessionもsetterメソッドを定義するだけで、自動バインディングすることが出来ます。また、S2ContainerFilterを使うと、HttpServletRequest、HttpServletResponse、HttpSessionをそれぞれrequest、response、sessionという名前のコンポーネントとしてアクセスできるようになります。</p>

<h3><a name="ComponentAutoRegister">コンポーネントの自動登録</a></h3>
<p><a href="#AutoBindingMode">自動バインディング</a>により、DIの設定はほぼ自動化できます。
<a href="#AnnotationReference">アノテーション</a>を使って細かく制御することも可能です。
さらに、コンポーネントの登録も自動化してしまおうというのが、コンポーネントの自動登録機能です。
コンポーネントの自動登録には､ファイルシステム上のclassファイルを検索するFileSystemComponentAutoRegisterコンポーネントやjarファイルの中を検索するJarComponentAutoRegisterを利用します。</p>
<h5><a name="FileSystemComponentAutoRegister">org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister</a></h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>自動登録されるコンポーネントに適用するInstanceDefを指定します。XMLで指定する場合､<br>
<code>@org.seasar.framework.container.deployer.InstanceDefFactory@REQUEST</code><br>
のように指定します。</td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>クラス名からコンポーネント名を自動的に決定するコンポーネント。org.seasar.framework.container.autoregister.AutoNamingインターフェースを実装している必要があります。デフォルトは､org.seasar.framework.container.autoregister.DefaultAutoNamingクラスのインスタンスになります。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPatten</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<h5><a name="JarComponentAutoRegister">org.seasar.framework.container.autoregister.JarComponentAutoRegister</a></h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>jarFileNames</code></td>
<td>対象のjarファイル名を指定します。正規表現も使えます。ただし､拡張子は含まれません。複数指定する場合は､「,」で区切ります。例えば､myapp.*, yourapp.*のようになります。</td>
</tr>
<tr>
<td><code>classInJar</code></td>
<td>このプロパティで指定されたクラスが存在するjarファイルの親ディレクトリをベースのディレクトリ(例えば、WEB-INF/lib)とみなします。デフォルトは、org.aopalliance.intercept.MethodInterceptor.classになります。</td>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>自動登録されるコンポーネントに適用するInstanceDefを指定します。XMLで指定する場合､@org.seasar.framework.container.deployer.InstanceDefFactory@REQUESTのように指定します。</td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>クラス名からコンポーネント名を自動的に決定するコンポーネント。org.seasar.framework.container.autoregister.AutoNamingインターフェースを実装している必要があります。デフォルトは､org.seasar.framework.container.autoregister.DefaultAutoNamingクラスのインスタンスになります。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPatten</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<h5><a name="JarComponentAutoRegister">org.seasar.framework.container.autoregister.JarComponentAutoRegister</a></h5>
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>jarFileNames</code></td>
<td>対象のjarファイル名を指定します。正規表現も使えます。ただし､拡張子は含まれません。複数指定する場合は､「,」で区切ります。例えば､myapp.*, yourapp.*のようになります。</td>
</tr>
<tr>
<td><code>referenceClass</code></td>
<td>このプロパティで指定されたクラスが存在するjarファイルの親ディレクトリをベースのディレクトリ(例えば、WEB-INF/lib)とみなします。デフォルトは、org.aopalliance.intercept.MethodInterceptor.classになります。</td>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>自動登録されるコンポーネントに適用するInstanceDefを指定します。XMLで指定する場合､<br>
<code>@org.seasar.framework.container.deployer.InstanceDefFactory@REQUEST</code><br>
のように指定します。</td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>クラス名からコンポーネント名を自動的に決定するコンポーネント。org.seasar.framework.container.autoregister.AutoNamingインターフェースを実装している必要があります。デフォルトは､org.seasar.framework.container.autoregister.DefaultAutoNamingクラスのインスタンスになります。</td>
</tr>

</table>
<br />
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>

</table>
<h5><a name="aComponentAutoRegister">org.seasar.framework.container.autoregister.ComponentAutoRegister</a></h5>
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>自動登録されるコンポーネントに適用するInstanceDefを指定します。XMLで指定する場合､@org.seasar.framework.container.deployer.InstanceDefFactory@REQUESTのように指定します。</td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>クラス名からコンポーネント名を自動的に決定するコンポーネント。org.seasar.framework.container.autoregister.AutoNamingインターフェースを実装している必要があります。デフォルトは､org.seasar.framework.container.autoregister.DefaultAutoNamingクラスのインスタンスになります。</td>
</tr>

</table>
<br />
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addReferenceClass</code></td>
<td>このプロパティで指定されたクラスが存在するディレクトリまたはJarファイルを基点としてクラスを検索します。</td>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPatten</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>

</table>
<br />
<p>コンポーネントの名前はAutoNamingにより制御します．クラス名をコンポーネント名とするDefaultAutoNamingと、パッケージで修飾された名前をコンポーネント名とするQualifiedAutoNamingがあります．</p>
<h5><a name="DefaultAutoNaming">org.seasar.framework.container.autoregister.DefaultAutoNaming</a></h5>
<p>クラスの完全修飾名からパッケージ部分を除き、最後がImplまたはBeanで終わっていたら削除し､
先頭を小文字にした名前をコンポーネントの名前に設定します。
例えば､aaa.HogeImplクラスの場合､コンポーネント名は､hogeになります。</p>
<table border="1">


<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>decapitalize</code></td>
<td>コンポーネント名の先頭を小文字にする場合はtrueを指定します。デフォルトはtrueです。</td>
</tr>


</table>
<br>
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>setCustomizedName</code></td>
<td>デフォルトのルールに従わないクラスを登録します。最初の引数は､クラスの完全修飾名です。
2番目の引数は､コンポーネント名です。</td>
</tr>
<tr>
<td><code>addIgnoreClassSuffix</code></td>
<td>クラス名の末尾から削除する部分を指定します。デフォルトでImplおよびBeanが登録されています。</td>
</tr>
<tr>
<td><code>addReplaceRule</code></td>
<td>正規表現による置換ルールを追加します。最初の引数は正規表現です。2番目の引数は置換文字列です。</td>
</tr>
<tr>
<td><code>clearReplaceRule</code></td>
<td>setCustomizedName、addIgnoreClassSuffix、addReplaceRuleで登録した変換規則をクリアします。デフォルトで登録されているImplおよびBeanもクリアされます。</td>
</tr>

</table>
<h5><a name="QualifiedAutoNaming">org.seasar.framework.container.autoregister.QualifiedAutoNaming</a></h5>
<p>パッケージ名またはその一部で修飾されたクラス名をコンポーネントの名前に設定します。
クラスの完全修飾名から最後がImplまたはBeanで終わっていたら削除し､
先頭を小文字、ピリオドの直後を大文字にした名前をコンポーネントの名前に設定します。<br>
パッケージの先頭部分から不要な部分を削除することができます。<br>
例えば､aaa.bbb.ccc.ddd.HogeImplクラスの場合で､先頭のaaa.bbbを削除するように指定した場合のコンポーネント名は､cccDddHogeになります。</p>
<table border="1">



<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>decapitalize</code></td>
<td>コンポーネント名の先頭を小文字にする場合はtrueを指定します。デフォルトはtrueです。</td>
</tr>



</table>
<br>
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>setCustomizedName</code></td>
<td>デフォルトのルールに従わないクラスを登録します。最初の引数は､クラスの完全修飾名です。
2番目の引数は､コンポーネント名です。</td>
</tr>
<tr>
<td><code>addIgnorePackagePrefix</code></td>
<td>パッケージ名の先頭から削除する部分を指定します。</td>
</tr>
<tr>
<td><code>addIgnoreClassSuffix</code></td>
<td>クラス名の末尾から削除する部分を指定します。デフォルトでImplおよびBeanが登録されています。</td>
</tr>
<tr>
<td><code>addReplaceRule</code></td>
<td>正規表現による置換ルールを追加します。最初の引数は正規表現です。2番目の引数は置換文字列です。</td>
</tr>
<tr>
<td><code>clearReplaceRule</code></td>
<td>setCustomizedName、addIgnorePackagePrefix、addIgnoreClassSuffix、addReplaceRuleで登録した変換規則をクリアします。デフォルトで登録されているImplおよびBeanもクリアされます。</td>
</tr>

</table>
<br />
<h5>例</h5>
<pre>&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister&quot;&gt;<br>    &lt;property name=&quot;autoNaming&quot;&gt;<br>	    &lt;component class=&quot;org.seasar.framework.container.autoregister.DefaultAutoNaming&quot;&gt;
            &lt;initMethod name=&quot;setCustomizedName&quot;&gt;<br>                &lt;arg&gt;&quot;examples.di.impl.HogeImpl&quot;&lt;/arg&gt;<br>                &lt;arg&gt;&quot;hoge2&quot;&lt;/arg&gt;<br>            &lt;/initMethod&gt;
        &lt;/component&gt;<br>    &lt;/property&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;/&gt;<br>&lt;/component&gt;</pre>

<pre>&lt;component class=&quot;org.seasar.framework.container.autoregister.JarComponentAutoRegister&quot;&gt;<br>    &lt;property name=&quot;classInJar&quot;&gt;<br>        @junit.framework.TestSuite@class<br>    &lt;/property&gt;<br>    &lt;property name=&quot;jarFileNames&quot;&gt;&quot;junit.*&quot;&lt;/property&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;junit.framework&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;TestSuite&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;&gt;&lt;/initMethod&gt;<br>&lt;/component&gt;

</pre>
<pre>&lt;component class=&quot;org.seasar.framework.container.autoregister.ComponentAutoRegister&quot;&gt;<br>    &lt;property name=&quot;referenceClass&quot;&gt;<br>        @aaa.bbb.ccc.ddd.HogeImpl@class<br>    &lt;/property&gt;<br><br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;aaa.bbb&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;&gt;&lt;/initMethod&gt;<br>&lt;/component&gt;

</pre>

<h3><a name="AspectAutoRegister">アスペクトの自動登録</a></h3>
<p><a href="#ComponentAutoRegister">コンポーネントの自動登録</a>により、コンポーネントの登録は自動化できます。
さらに、アスペクトの登録も自動化してしまおうというのが、アスペクトの自動登録機能です。アスペクトの自動登録には､AspectAutoRegisterコンポーネントを利用します。</p>
<h5>org.seasar.framework.container.autoregister.AspectAutoRegister</h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>interceptor</code></td>
<td>インターセプタを指定します。複数のインターセプタを指定したい場合は､<a href="aop.html#InterceptorChain">InterceptorChain</a>を使ってください。</td>
</tr>
<tr>
<td><code>pointcut</code></td>
<td> インターセプタを適用するメソッドをカンマ区切りで指定します。pointcutを指定しない場合は、コンポーネントが実装しているインターフェースのすべてのメソッドが対象になります。メソッド名には正規表現(JDK1.4のregex)も使えます。 </td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPatten</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<br />
<h5>例</h5>
<pre>&lt;include path=&quot;aop.dicon&quot;/&gt;
...
&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.AspectAutoRegister&quot;&gt;<br>    &lt;property name=&quot;interceptor&quot;&gt;aop.traceInterceptor&lt;/property&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;/&gt;<br>&lt;/component&gt;
</pre>

<h3><a name="Hotswap">Hotswap</a></h3>
<p>従来、ソースコードを書き換えてコンパイルした場合､コンパイル後の機能を試すためには､
アプリケーション(正確にはClassLoader)を再起動する必要がありました。
アプリケーションサーバ上で､アプリケーションを再起動するのは､非常に時間がかかるものです。
「かったるい」と思っていた方も多くいることでしょう。</p>
<p>Seasar2では、アプリケーションを稼動させたまま､クラスファイルを置き換えて、
即座に試すことのできる<b>Hotswap</b>機能を実現しています。
これであの「イライラ」からも解放されます。余分な待ち時間が無いので生産性を向上させることもできます。それでは、試してみましょう。</p>
<h4>Greeting.java</h4>
<pre>
package examples.hotswap;

public interface Greeting {

    String greet();
}
</pre>
<h4>GreetingImpl.java</h4>
<pre>
package examples.hotswap.impl;

import examples.hotswap.Greeting;

public class GreetingImpl implements Greeting {

    public String greet() {
        return "Hello";
    }
}
</pre>
<h4>hotswap.dicon</h4>
<pre>&lt;components&gt;<br>    &lt;component class=&quot;examples.hotswap.impl.GreetingImpl&quot;/&gt;<br>&lt;/components&gt;
</pre>
<p>ここまでは､特に変わったところはありません。ポイントはこれからです。
s2container.diconを使って、hotswapモードに切り替えます。</p>
<h4>s2container.dicon</h4>
<pre>&lt;components&gt;<br>    &lt;component<br>      class=&quot;org.seasar.framework.container.factory.S2ContainerFactory$DefaultProvider&quot;&gt;<br>        &lt;property name=&quot;hotswapMode&quot;&gt;true&lt;/property&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;<br></pre>
<p>s2container.diconはクラスパスの通っているルートのディレクトリに置いておけば､自動で認識されます。
S2ContainerFactory#configure()を使って明示的に指定することもできます。</p>
<h4>GreetingMain.dicon</h4>
<pre>
package examples.hotswap.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.hotswap.Greeting;

public class GreetingMain {

    private static final String CONFIGURE_PATH =
        "examples/hotswap/dicon/s2container.dicon";

    private static final String PATH =
        "examples/hotswap/dicon/hotswap.dicon";

    public static void main(String[] args) throws Exception {
        S2ContainerFactory.configure(CONFIGURE_PATH);
        S2Container container = S2ContainerFactory.create(PATH);
        System.out.println("hotswapMode:" + container.isHotswapMode());
        container.init();
        try {
            Greeting greeting = (Greeting) container
                    .getComponent(Greeting.class);
            System.out.println(greeting.greet());
            System.out.println("Let's modify GreetingImpl, then press ENTER.");
            System.in.read();
            System.out.println("after modify");
            System.out.println(greeting.greet());
        } finally {
            container.destroy();
        }
    }
}
</pre>
<p>hotswapを使うためには､S2Container#init()を呼び出す必要があります。
実行すると"Hello"と表示された後に､プログラムが停止するので､
GreetingImpl#greet()が"Hello2"を返すように修正してコンパイルします。
その後､コンソールにフォーカスを当ててENTERキーを押してください。
同じインスタンスなのにかかわらず、classファイルが入れ替わっていることがわかります。
これは、<a href="#InstanceMode">インスタンスモード</a>がsingletonの場合の例ですが､
<a href="#InstanceMode">インスタンスモード</a>がprototypeの場合は､S2Container#getComponent()のタイミングでクラスが入れ替わります。</p>
<h4>実行結果</h4>
<pre>
hotswapMode:true
Hello
Let's modify GreetingImpl, then press ENTER.

after modify
Hello2
</pre>
<p>hotswapを使うためには､コンポーネントがインターフェースを提供し､
コンポーネントの利用者側は､インターフェース経由でコンポーネントを利用する必要があります。
<a href="#InstanceMode">インスタンスモード</a>がrequest、sessionの場合は､
そのコンポーネントが他のコンポーネントから参照されていない場合には､
インターフェースなしでもhotswapを利用することができます。
</p>


<h2><a name="DefReference">S2Containerタグリファレンス</a></h2>

<h3><a name="DOCTYPE">DOCTYPE</a></h3>
<p>DOCTYPEは、XML宣言の次に指定します。下記のように指定してください。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;hello&quot; class=&quot;examples.dicon.HelloConstructorInjection&quot;&gt;
        &lt;arg&gt;&quot;Hello World!&quot;&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h3><a name="componentsTag">componentsタグ(必須)</a></h3>
            <p>ルートのタグになります。</p>
            <h4><a name="namespaceAttr">namespace属性(任意)</a></h4>
            <p><a href="#Namespace">名前空間</a>を指定することができます。Javaの識別子として使えるものにします</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components namespace=&quot;hoge&quot;&gt;
    ...
&lt;/components&gt;
</pre>

            <h3><a name="includeTag">includeタグ(任意)</a></h3>
            <p>分割されたS2Containerの定義を<a href="#Include">取り込む</a>場合に使います。</p>
            <h4><a name="pathAttr">path属性(必須)</a></h4>
            <p>定義ファイルのパスを指定することができます。CLASSPATHで指定されているディレクトリをルートとする定義ファイルの絶対パスです。例えば、WEB-INF/classes/aaa.dicon
の場合は aaa.dicon に、WEB-INF/classes/aaa/bbb/ccc.dicon の場合は aaa/bbb/ccc.dicon
になりますセパレータは、WindowsでもUnixでも/です。componentタグの前に記述する必要があります。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;include path=&quot;aaa/bbb/ccc.dicon&quot; /&gt;
&lt;/components&gt;
</pre>

            <h3><a name="componentTag">componentタグ(任意)</a></h3>
            <p>コンポーネントを定義します。</p>
            <h4><a name="classAttr">class属性(任意)</a></h4>
            <p>クラスの完全限定名を指定します。ボディで、<a href="#ognlExpr">OGNL式</a>を使ってコンポーネントを指定した場合は、class属性を省略することができます。OGNL式を使った場合にclass属性を指定すると、型チェックを行います。</p>
            <h4><a name="componentTag.nameAttr">name属性(任意)</a></h4>
            <p>名前を指定することもできます。Javaの識別子として使えるものにします。詳しくは、<a href="#getComponent">コンポーネントの取得</a>を参照してください。</p>
            <h4><a name="instanceAttr">instance属性(任意)</a></h4>
            <p>S2Containerがどのようにコンポーネントのインスタンスを管理するのかを指定することができます。singleton(デフォルト)、prototype、outer、request、sessionを指定することができます。詳しくは、<a href="#InstanceMode">インスタンス管理</a>を参照してください。</p>
            <h4><a name="autoBindingAttr">autoBinding属性(任意)</a></h4>
            <p>S2Containerがコンポーネントの依存関係をどのように解決するのかを指定できます。auto(デフォルト)、constructor、property、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。</p>

            <h3><a name="argTag">argタグ(任意)</a></h3>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使った場合は、コンストラクタの引数になります。記述した順番でコンストラクタに渡されます。
            <a href="#initMethodTag">initMethodタグ</a>、<a href="#destroyMethodTag">destroyMethodタグ</a>の子タグとして使った場合は、メソッドの引数になります。記述した順番でメソッドに渡されます。
            引数として渡される実際の値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

            <h3><a name="propertyTag">propertyタグ(任意)</a></h3>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使います。プロパティとして設定される実際の値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

			<h4><a name="propertyTag.nameAttr">name属性(必須)</a></h4>
            <p>プロパティ名を指定します。</p>

			<h4><a name="propertyTag.bindingTypeAttr">bindingType属性(任意)</a></h4>
            <p>プロパティごとに自動バインディングを細かく制御できます。must、should(デフォルト)、may、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。</p>

			<h3><a name="metaTag">metaタグ(任意)</a></h3>
            <p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとして使います。メタデータの値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

<h4><a name="propertyTag.nameAttr">name属性(任意)</a></h4>

            <p>メタ名を指定します。</p>

            <h3><a name="initMethodTag">initMethodタグ(任意)</a></h3>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使います。引数は、子タグで、<a href="#argTag">argタグ</a>を使います。name属性を書かずに、<a href="#ognlExpr">OGNL式</a>を使って、コンポーネントのメソッドを呼び出すこともできます。initMethodタグが定義されているコンポーネント自身を表す#self、System.outを表す#out、System.errを表す#errがinitMethodタグ内だけで有効なオブジェクトとして使えます。</p>
            <h4><a name="initMethodTag.nameAttr">name属性(任意)</a></h4>
            <p>メソッド名を指定します。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;java.util.HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;initMethod&gt;#self.put(&quot;aaa&quot;, 111)&lt;/initMethod&gt;
        &lt;initMethod&gt;#out.println(&quot;Hello&quot;)&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h3><a name="destroyMethodTag">destroyMethodタグ(任意)</a></h3>
            <p>initMethodタグと同様です。</p>

            <h3><a name="aspectTag">aspectタグ(任意)</a></h3>
            <p>アスペクトをコンポーネントに組み込みます。詳しくは、S2AOPの<a href="aop.html#aspectTag">aspectタグ</a>の説明を参照してください。</p>

            <h3><a name="descriptionTag">descriptionタグ(任意)</a></h3>

            <p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとしてdescriptionタグを使うことができます。自由に説明を記述できます。</p>

            <h3><a name="ognlExpr">OGNL式</a></h3>
            <p>S2Containerでは、式言語として<a href="http://www.ognl.org/">OGNL</a>を利用しています。XMLの中で、文字列で記述した内容(式)をJavaのオブジェクトに変換するためのものだと思って間違いないと思います。</p>

            <ul>
            <li>文字列は、&quot;hoge&quot;のように&quot;で囲みます。</li>
            <li>charは、'a'のように'で囲みます。</li>
            <li>数値は、123のようにそのまま記述します。</li>
            <li>論理値は、true,falseのようにそのまま記述します。</li>
            <li>new java.util.Date(0)のようにクラスの完全限定名でコンストラクタを呼び出すことができます。</li>
            <li> @java.lang.Math@max(1, 2)のようにstaticなメソッドを呼び出した結果を参照することができます。</li>
            <li>@java.lang.String@classのようにクラスを参照できます。</li>
            <li>hoge.toString()のようにコンポーネントのメソッドを呼び出した結果を参照することができます。この例は、どこかでhogeという名前のコンポーネントが定義されているという前提です。</li>
            </ul>
            詳しくは、<a href="http://www.ognl.org/2.6.7/Documentation/html/LanguageGuide/index.html">OGNLのマニュアル</a>を参照してください。<br/>
            <br/>

<h2><a name="AnnotationReference">S2Containerアノテーションリファレンス</a></h2>
<p>S2Containerでは、アノテーションの実装方法として､
Tigerアノテーション､backport175アノテーション､定数アノテーションの3種類を用意しています。一般的にアノテーションといえば､Java 5から導入された
Tigerアノテーションですが､それだけだと、JDK1.4のユーザが利用できなくなってしまいます。</p>
<p>できるだけ、多くの方にアノテーションを便利に使ってもらいたいため､JDK1.4で、
Tiger風アノテーション(JSR-175)を使うことのできる
<a href="http://backport175.codehaus.org/">backport175</a>アノテーション、public static finalな定数を利用する定数アノテーションを用意しています。 </p>

<h3><a name="ComponentAnnotation">Componentアノテーション</a></h3>
<p><a href="#componentTag">componentタグ</a>のかわりに使えるが、Componentアノテーションです。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Component(name="xxx", instance=InstanceType.PROTOTYPE,
        autoBinding=AutoBindingType.PROPERTY)
public class Xxx {
    ...
}
</pre>
<p>backport175アノテーションは以下のようになります。</p>
<pre>
/**
 * @org.seasar.framework.container.annotation.backport175.Component(
 *      name = "xxx",
 *      instance = "prototype",
 *      autoBinding = "property")
 */
public class Xxx {
    ...
}
</pre>
<p>定数アノテーションは以下のようになります。</p>
<pre>
public static final String COMPONENT =
  "name = xxx, instance = prototype, autoBinding = property";
</pre>

<h3><a name="BindingAnnotation">Bindingアノテーション</a></h3>
<p><a href="#propertyTag">propertyタグ</a>のかわりに使えるが、Bindingアノテーションです。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Binding("aaa2")
public void setAaa(String aaa) {
    ...
}

@Binding(bindingType=BindingType.NONE)
public void setBbb(String bbb) {
    ...
}

@Binding
public void setCcc(String ccc) {
    ...
}
</pre>
<p>backport175アノテーションは以下のようになります。</p>
<pre>
/**

 * @org.seasar.framework.container.annotation.backport175.Binding("aaa2")
 */
public void setAaa(String aaa) {
    ...
}

/**
 * @org.seasar.framework.container.annotation.backport175.Binding(bindingType="none")
 */
public void setBbb(String bbb) {
    ...
}

/**
 * @org.seasar.framework.container.annotation.backport175.Binding
 */
public void setCcc(String ccc) {
    ...
}
</pre>
<p>定数アノテーションはプロパティ名_BINDINGで指定します。</p>
<pre>
public static final String aaa_BINDING = "aaa2";

public static final String bbb_BINDING = "bindingType=none";

public static final String ccc_BINDING = null;

public void setAaa(String aaa) {
    ...
}

public void setBbb(String bbb) {
    ...
}

public void setCcc(String ccc) {
    ...
}
</pre>

<h3><a name="AspectAnnotation">Aspectアノテーション</a></h3>
<p><a href="aop.html#aspectTag">aspectタグ</a>のかわりに使えるが、Aspectアノテーションです。aspectタグと異なり､複数定義することはできないので､
複数のインターセプタを適用したい場合は､<a href="aop.html#InterceptorChain">InterceptorChain</a>を使ってください。ポイントカットを指定したいときは､pointcut属性を指定します。クラスに対するアノテーションの場合､pointcutを指定しないときは､そのクラスが実装しているすべてのインターフェースのメソッドが対象になります。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Aspect("aop.traceInterceptor")
public class Xxx {
    ...
}

public class Xxx {
    ...
    @Aspect("aop.traceInterceptor")
    public void hoge() {
        ...
    }
}
</pre>
<p>backport175アノテーションは以下のようになります。</p>
<pre>
/**
 * @org.seasar.framework.container.annotation.backport175.Aspect(
 *  "aop.traceInterceptor")
 */
public class Xxx {
    ...
}

public class Xxx {
    ...
    /**
     * @org.seasar.framework.container.annotation.backport175.Aspect(
     *  "aop.traceInterceptor")
     */
    public void hoge() {
        ...
    }
}
</pre>
<p>定数アノテーションは以下のようになります。pointcutを複数指定したい場合は､pointcut= get.*\nexecute.*のように\nで区切ってください。
\n以外の区切り文字を使ってはいけません。</p>
<pre>
public static final String ASPECT =
    "interceptor=aop.traceInterceptor, pointcut=getAaa";
</pre>


<!-- document end -->
<!-- don't edit start -->
</td>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="14"><img height="30" width="14" src="images/spacer.gif" alt=""></td>
<td width="766"><img height="30" width="592" src="images/spacer.gif" alt=""></td></tr><tr>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
<td width="766" class="copyright">&copy; Copyright The Seasar Foundation and the others 2004, all rights reserved.</td>
</tr></table>
<td class="backright" align="left" valign="top">&nbsp;</td></tr><tr>
<td class="backunder" align="left"  valign="top" width="780" height="16">&nbsp;</td>
<td class="backcorner" align="left" valign="top" height="16">&nbsp;</td>
</tr></table></body>
<!-- don't edit end -->
</html>
