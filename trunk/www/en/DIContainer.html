<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- don't edit start -->
<head><title>Seasar - DI Container with AOP - </title><meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
<meta http-equiv="Content-Style-Type" content="text/css">
<link href="seasar_p.css" type="text/css" rel="stylesheet" media="print">
<link href="seasar_b.css" type="text/css" rel="stylesheet" media="screen">
<script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script>
</head><body onload="preload('en')">
<img height="117" width="256" src="images/spacer.gif" alt=""><table width="100%" border="0" cellspacing="0" cellpadding="0" align="left"><tr>
<td align="left" valign="top" width="780"><table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr><td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt=""></td></tr>
<tr><td><img height="117" width="235" src="images/top02_b.gif" alt="Seasar"></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP"></td>
<td colspan="3">&nbsp;</td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td><a href="http://www.seasar.org/en/index.html"><img src="images/menu01_b_en.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)"></a></td>
<td><a href="http://www.seasar.org/en/projects.html"><img src="images/menu02_b_en.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)"></a></td>
<td><a href="http://www.seasar.org/en/products.html"><img src="images/menu06_b_en.gif" height="30" width="110" border="0" alt="" id="menu06" onmouseover="swap(6)" onmouseout="restore(6)"></a></td>
<td><a href="http://www.seasar.org/en/documents.html"><img src="images/menu04_b_en.gif" height="30" width="109" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)"></a></td>
<td><a href="http://www.seasar.org/en/resources.html"><img src="images/menu05_b_en.gif" height="30" width="113" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)"></a></td>
<!--
<td><img src="images/menu07_b_en.gif" height="30" width="109" border="0" alt=""  id="menu07" onmouseover="swap(7)" onmouseout="restore(7)"></td>
//-->
<td><img height="30" width="34" src="images/menu06.gif" alt=""></td></tr><tr>

<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt=""></td></tr></table>
<table  width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr align="left" valign="top"><td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td><td width="740" class="main">
<!-- don't edit end -->
<!-- document start -->
            <ul>
              <li><a href="#Quickstart">Quickstart</a>
			 　<ul>
				<li><a href="#FirstStep">First step</a>
				<li><a href="#NextStep">Next step</a>
　　　　　　　　</ul>
              </li>

              <li><a href="#S2ContainerReference">S2Container reference</a>
                <ul>
                  <li><a href="#CreateFile">Files to be Created</a></li>
                  <li><a href="#S2ContainerDefinition">S2Container Definition</a></li>
                  <li><a href="#S2ContainerCreation">S2Container Creation</a>
<ul>
<li><a href="#SingletonS2ContainerFactory">Using SingletonS2ContainerFactory</a>
<li><a href="#S2ContainerFactory">Using S2ContainerFactory</a>
</ul>
</li>
                  <li><a href="#getComponent">Acquiring Components</a></li>
                  <li><a href="#DIType">Dependency Injection Type</a>
                    <ul>
                      <li type="circle"><a href="#ConstructorInjection">Constructor Injection</a></li>
                      <li type="circle"><a href="#SetterInjection">Setter Injection</a></li>
                      <li type="circle"><a href="#MethodInjection">Method Injection</a></li>
                    </ul>
                  </li>
                  <li><a href="#Include">S2Container Definition division and include</a></li>
                  <li><a href="#Namespace">Namespace</a></li>
                  <li><a href="#InstanceMode">Instance Management</a></li>
                  <li><a href="#Lifecycle">Lifecycle</a></li>
                  <li><a href="#AutoBindingMode">Automatic Binding</a></li>
                  <li><a href="#UseS2Container">Using S2Container in Components</a></li>
                  <li><a href="#S2ContainerServlet">S2ContainerServlet</a></li>
                  <li><a href="#app.dicon">Purpose of app.dicon</a></li>
                  <li><a href="#Aop">AOPの適用</a></li>
				  <li><a href="#Meta">メタデータ</a></li>
				  <li><a href="#Request">Requestの自動バインディング</a></li>
				  <li><a href="#ComponentAutoRegister">コンポーネントの自動登録</a></li>
				  <li><a href="#AspectAutoRegister">アスペクトの自動登録</a></li>
				  <li><a href="#Hotswap">Hotswap</a></li>
                </ul>
              </li>
              <li><a href="#DefReference">S2Containerタグリファレンス</a>
                <ul>
                  <li><a href="#DOCTYPE">DOCTYPE</a></li>
                  <li><a href="#componentsTag">componentsタグ</a></li>
                  <li><a href="#includeTag">includeタグ</a></li>
                  <li><a href="#componentTag">componentタグ</a></li>
                  <li><a href="#argTag">argタグ</a></li>
                  <li><a href="#propertyTag">propertyタグ</a></li>
				  <li><a href="#metaTag">metaタグ</a></li>
                  <li><a href="#initMethodTag">initMethodタグ</a></li>
                  <li><a href="#destroyMethodTag">destroyMethodタグ</a></li>
                  <li><a href="#aspectTag">aspectタグ</a></li>
                  <li><a href="#descriptionTag">descriptionタグ</a></li>
                  <li><a href="#ognlExpr">OGNL式</a></li>
                </ul>
              </li>
			  <li><a href="#AnnotationReference">S2Containerアノテーションリファレンス</a>
                <ul>
                  <li><a href="#ComponentAnnotation">Componentアノテーション</a></li>
				  <li><a href="#BindingAnnotation">Bindingアノテーション</a></li>
				  <li><a href="#AspectAnnotation">Aspectアノテーション</a></li>
				  <li><a href="#InitMethodAnnotation">InitMethodアノテーション</a></li>
				</ul>
			  </li>
              <li>DIContainerエクササイズ</li>
            </ul>


<h2><a name="Quickstart">Quickstart</a></h2>
<p>S2Container is a light weight container for Dependency Injection (DI) operations. DI is an idea to separate the interface and implementation, to communicate with each other through the interface.</p>

<h3><a name="FirstStep">First Step</a></h3>
<p>Let us give this a try. The following objects will be used.</p>
<ul>
<li>Greeting Class
<ul>
<li>Returns a greeting string.</li>
</ul>
</li>

<li>Greeting Client Class
<ul>
<li>Outputs string obtained from the greeting class to console.</li>
</ul>
</li>

<li>Greeting Main Class
<ul>
<li>Startup Class. Also constructs greeting and greeting client class.
</li>
</ul>
</li>

</ul>
<h5>Greeting.java</h5>
<p>Greeting Interface.</p>
<pre>
package examples.di;

public interface Greeting {

    String greet();
}
</pre>

<h5>GreetingImpl.java</h5>
<p>Implementation of the greeting.</p>
<pre>
package examples.di.impl;

import examples.di.Greeting;

public class GreetingImpl implements Greeting {

    public String greet() {
        return "Hello World!";
    }
}
</pre>

<h5>GreetingClient.java</h5>
<p>Client interface to use the greeting.</p>
<pre>
package examples.di;

public interface GreetingClient {

    void execute();
}
</pre>

<h5>GreetingClientImpl.java</h5>
<p>Client implementation to use greeting. Instead of using Greeting Implementation (GreetingImpl) directly, the interface (Greeting) will be used. </p>
<pre>
package examples.di.impl;

import examples.di.Greeting;
import examples.di.GreetingClient;

public class GreetingClientImpl implements GreetingClient {

    private Greeting greeting;

    public void setGreeting(Greeting greeting) {
        this.greeting = greeting;
    }

    public void execute() {
        System.out.println(greeting.greet());
    }
}
</pre>

<p>Both function provider and user is prepared. Let us try running this. </p>
<h5>GreetingMain.java</h5>
<pre>
package examples.di.main;

import examples.di.Greeting;
import examples.di.impl.GreetingClientImpl;
import examples.di.impl.GreetingImpl;

public class GreetingMain {

    public static void main(String[] args) {
        Greeting greeting = new GreetingImpl();
        GreetingClientImpl greetingClient = new GreetingClientImpl();
        greetingClient.setGreeting(greeting);
        greetingClient.execute();
    }
}
</pre>
<p>The result will be as follows.</p>
<pre>
Hello World!
</pre>
<p>As shown here, the function user (GreetingClientImpl) uses the function through the interface (Greeting),
a third party (GreetingMain, in this case) provides the implementation object at runtime.
That is the basic style of DI </p>
<p>However, if one writes configurations into the source as GreetingMain,
the source code must be altered to reflect any changes.
DIContainer is used to avoid this.
DIContainer constructs objects by reading external configuration files.</p>
<p>We will write the configuration information into the configuration file.
That extension is &quot;.dicon&quot; in S2Container.</p>

<h5>GreetingMain2.dicon</h5>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE components PUBLIC<br>    &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;<br>    &quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;<br>&lt;components&gt;<br>    &lt;component name=&quot;greeting&quot;<br>        class=&quot;examples.di.impl.GreetingImpl&quot;/&gt;<br>    &lt;component name=&quot;greetingClient&quot;<br>        class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>        &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;
</pre>

<p>Look at <a href="#DefReference">S2Container Tag Reference</a> for details.
We will first describe the main points.</p>

<pre>&lt;component name=&quot;greeting&quot;<br>    class=&quot;examples.di.impl.GreetingImpl&quot;/&gt;
</pre>
<p>We define component as above. This is equivalent to the following Java code.</p>

<pre>
Greeting greeting = new GreetingImpl();
</pre>

<p>We define  a component name using the name property in the component tag, and a class name using the class property.
Next, we configure greetingClient.</p>

<pre>&lt;component name=&quot;greetingClient&quot;<br>    class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>    &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>&lt;/component&gt;
</pre>

<p>We define a property name using the name property in the property tag,
and specify the component name in the body. This is equivalent to the following Java code.
Take care not to surround the component name in double quotation marks,
as this will cause the contents to be interpreted as a string.</p>

<pre>GreetingClientImpl greetingClient = new GreetingClientImpl();
greetingClient.setGreeting(greeting);
</pre>

<p>The startup class using S2Container will be as follows.</p>
<h5>GreetingMain2.java</h5>
<pre>
package examples.di.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.di.GreetingClient;

public class GreetingMain2 {

    private static final String PATH =
        "examples/di/dicon/GreetingMain2.dicon";

    public static void main(String[] args) {
        S2Container container =
            S2ContainerFactory.create(PATH);
        GreetingClient greetingClient = (GreetingClient)
            container.getComponent("greetingClient");
        greetingClient.execute();
    }
}</pre>

<p>S2Container is created using S2ContainerFactor#create(String Path).
Read <a href="#S2ContainerCreation">Creating S2Container</a> for details.</p>

<p>The component(greetingClient) is acquired using S2Container#getComponent(String componentName).
Please reference <a href="#getComponent">Acquiring Components</a> for details.</p>

<p>As before, the result will be as follows.</p>
<pre>
Hello World!
</pre>

<p>AOP is often used with DI.
AOP is a technique to modularize the functions like logging that are spread over many classes.
We will now output a log (trace) from GreetingImpl, and GreetingClientImpl without altering the existing source code.
The configuration file with AOP will be as follows.</p>

<h5>GreetingMain3.dicon</h5>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE components PUBLIC<br>    &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;<br>    &quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;<br>&lt;components&gt;<br>    &lt;include path=&quot;aop.dicon&quot;/&gt;<br>    &lt;component name=&quot;greeting&quot;<br>        class=&quot;examples.di.impl.GreetingImpl&quot;&gt;<br>        &lt;aspect&gt;aop.traceInterceptor&lt;/aspect&gt;<br>    &lt;/component&gt;<br>    &lt;component name=&quot;greetingClient&quot;<br>        class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>        &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>        &lt;aspect&gt;aop.traceInterceptor&lt;/aspect&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;
</pre>

<p>Seasar2 contains commonly used AOP modules predefined within aop.dicon.
We use the include tag as follows.
Please reference <a href="#Include">S2Container Definition division and include</a> for details.</p>

<pre>&lt;include path=&quot;aop.dicon&quot;/&gt;
</pre>

<p>We define <a href="#aspectTag">the aspect tag</a> to apply AOP to a component, and specify the AOP module name in the body.
We will be using aop.traceInterceptor as the AOP module name.</p>

<pre>&lt;aspect&gt;aop.traceInterceptor&lt;/aspect&gt;
</pre>

<p>This concludes the configuration of AOP. We will now try running GreetingMain3.
The only difference from GreetingMain2 is the path of the configuration file.</p>

<h5>GreetingMain3.java</h5>
<pre>
package examples.di.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.di.GreetingClient;

public class GreetingMain3 {

    private static final String PATH =
        "examples/di/dicon/GreetingMain3.dicon";

    public static void main(String[] args) {
        S2Container container =
            S2ContainerFactory.create(PATH);
        GreetingClient greetingClient = (GreetingClient)
            container.getComponent("greetingClient");
        greetingClient.execute();
    }
}
</pre>

<p>The results will be as follows. We see the log output with no alteration to the original source code.</p>

<pre>
DEBUG 2005-10-11 21:01:49,655 [main] BEGIN examples.di.impl.GreetingClientImpl#execute()
DEBUG 2005-10-11 21:01:49,665 [main] BEGIN examples.di.impl.GreetingImpl#greet()
DEBUG 2005-10-11 21:01:49,665 [main] END examples.di.impl.GreetingImpl#greet() : Hello World!
Hello World!
DEBUG 2005-10-11 21:01:49,675 [main] END examples.di.impl.GreetingClientImpl#execute() : null
</pre>

<p>We have now mastered the basic use of S2Container.</p>

<h3><a name="NextStep">Next Step</a></h3>
<p>Writing the configuration file is still annoying, isn’t it?
S2Container also possesses the following concepts to minimize the amount of writing in configuration files.</p>

<ul>
<li><a name="CoC">Convention over Configuration</a></li>
</ul>

<p>This implements a number of practical conventions,
so that a program will run with no configuration as long as it follows these rules.
For example, the configuration file from earlier explicitly defines the property tag as follows.</p>

<pre>&lt;component name=&quot;greetingClient&quot;<br>    class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>    &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>&lt;/component&gt;
</pre>

<p>As long as the property type is interface and there is a component impementing interface in the container,
S2Container has a function to automatically DI.
This means S2Container will automatically process components as long as
they follow the DI convention of defining property type by interface.</p>

<p>"Convention" may sound annoying, but they are not only recommended but also making development easier.</p>

<p>We can simplify the configuration from above as follows.</p>
<pre>&lt;component name=&quot;greetingClient&quot;<br>    class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>&lt;/component&gt;
</pre>

<p>Actually, “Convention over Configuration” is used in the AOP example from earlier.
Normally, where (or which method) the AOP module is applied is defined in pointcut.
All methods defined by interface have the AOP module applied without the use of pointcut in <a href="aop.html">S2AOP</a>
as long as they follow the convention of using interface.
This is how there was no need to define a module in pointcut in the earlier example.</p>

<p>Using “Convention over Configuration” will simplify the configuration of DI and AOP.
However, component registration itself becomes a burden as the number of components increase.
The automation of this component registration is <a href="#ComponentAutoRegister">Component auto-registration</a> functionality.
The registration of GreetingImpl, GreetingClientImpl from earlier is automated as follows.</p>

<pre>&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister&quot;&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>&lt;/component&gt;</pre>

<p>This FileSystemComponentAutoRegister component searches classes defined in addClassPattern from the file system
and auto-registers them in S2Container.
Please refer to <a href="#MethodInjection">Method Injection</a> for details on the initMethod tag.</p>

<p>The first argument of addClassPattern method is the package name of the component to be auto-registered.
Child packages are also recursively searched.
The second argument is the class name, which may be a regular expression. 
Multiple definitions are separated by commas.</p>

<p>Auto-registration of components decreases the overall amount of work,
as the programmer is not required to configure anything for new components.</p>

<p>As we automate the registration of components,
next focus is the automation of aspect registration.
The configuration of <a href="#AspectAutoRegister">Aspect auto-registration</a> for GreetingImpl and GreetingClientImp is as follows.</p>

<pre>&lt;include path=&quot;aop.dicon&quot;/&gt;
...
&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.AspectAutoRegister&quot;&gt;<br>    &lt;property name=&quot;interceptor&quot;&gt;aop.traceInterceptor&lt;/property&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>&lt;/component&gt;
</pre>

<p>We specify the AOP module name in the interceptor property.
We will skip the explanation of the addClassPattern method, as it is identical to the component auto-registration.
The combination of component and aspect auto-registration looks like the following.</p>

<h5>GreetingMain4.dicon</h5>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot; <br>	&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;<br>    &lt;include path=&quot;aop.dicon&quot;/&gt;

    &lt;component<br>      class=&quot;org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister&quot;&gt;<br>        &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>            &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>            &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>        &lt;/initMethod&gt;<br>    &lt;/component&gt;

    &lt;component<br>      class=&quot;org.seasar.framework.container.autoregister.AspectAutoRegister&quot;&gt;<br>        &lt;property name=&quot;interceptor&quot;&gt;aop.traceInterceptor&lt;/property&gt;<br>        &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>            &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>            &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>        &lt;/initMethod&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;
</pre>

<p>We will now run GreetingMain4.
We must invoke S2Container#init() and S2Container#destroy() in the case of using auto-registration.</p>

<h5>GreetingMain4.java</h5>
<pre>
package examples.di.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.di.GreetingClient;

public class GreetingMain4 {

    private static final String PATH =
        "examples/di/dicon/GreetingMain4.dicon";

    public static void main(String[] args) {
        S2Container container =
            S2ContainerFactory.create(PATH);
        container.init();
        try {
            GreetingClient greetingClient = (GreetingClient)
                container.getComponent("greetingClient");
            greetingClient.execute();
        } finally {
            container.destroy();
        }
    }
}
</pre>

<p>The result will be identical to GreetingMain3 as follows.</p>
<pre>
DEBUG 2005-10-12 16:00:08,093 [main] BEGIN examples.di.impl.GreetingClientImpl#execute()
DEBUG 2005-10-12 16:00:08,103 [main] BEGIN examples.di.impl.GreetingImpl#greet()
DEBUG 2005-10-12 16:00:08,103 [main] END examples.di.impl.GreetingImpl#greet() : Hello World!
Hello World!
DEBUG 2005-10-12 16:00:08,103 [main] END examples.di.impl.GreetingClientImpl#execute() : null
</pre>

<p>Auto-registration and Auto-binding will work well in most cases.
Components can be excluded from auto-registration using the addIgnoreClassPattern method.</p>

<p><a href="#BindingAnnotation">Binding Annotation</a> can be used to fine tune configuration settings
without using configuration files for properties excluded from auto-binding.</p>

<p><a href="#Hotswap">Hotswap</a> can be used to retry immediately without restarting application
so that development is more efficient.</p>

<p>We have now mastered advanced use of S2Container. Please reference the manual as needed.</p>


<h2><a name="S2ContainerReference">S2Container Reference</a></h2>

<h3><a name="CreateFile">Files to be Created</a></h3>
<p>A definition file must be created in order to use S2Container.
A definition file is a XML file with a .dicon extension,
and serves as a blueprint for component creation.</p>

<h3><a name="S2ContainerDefinition">S2Container Definition</a></h3>
<p>The definition of S2Container is as follows.</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
            ...
    &lt;/component&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
            ...
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<p>DOCTYPE may not be abbreviated.
The above sample should be copied verbatim when creating a dicon file.
The root is the <a href="#componentsTag">components tag</a>.
We will define the component tag for every <a href="#componentTag">component tag</a>.
Please refer to the <a href="#DefReference">S2Container Definition Tag Reference</a> for additional details.</p>

<pre>
&lt;components&gt;
    &lt;component name=&quot;hoge&quot; class=&quot;examples.dicon.HogeImpl&quot;/&gt;
&lt;/components&gt;
</pre>

<h3><a name="S2ContainerCreation">S2Container Creation</a></h3>
<p>There are two methods of creating S2Container.</p>
<ul>
<li>Use SingletonS2ContainerFactory</li>
<li>Use S2ContainerFactory</li>
</ul>
<h4><a name="SingletonS2ContainerFactory">Using SingletonS2ContainerFactory</a></h4>
<p>We will use the following method when utilizing SingletonS2ContainerFactory.</p>
<p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#init()</p>
<p>app.dicon located in the directory as defined in CLASSPATH is used.</p>
<p>The created S2Container can be obtained by the following method from any location.</p>
<p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#getContainer()</p>
<pre>SingletonS2ContainerFactory.init();
...
S2Container container = SingletonS2ContainerFactory.getContainer();</pre>
<p>Use the following method before calling init() if specifying a path to the definition file.</p>
<p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#setConfigPath(String Path)</p>
<p>The arguments path is an absolute path of the definition file referencing the directory defined in CLASSPATH as root.
For example, WEB-INF/classes/aaa.dicon is aaa.dicon.  WEB-INF/classes/aaa/bbb/ccc.dicon becomes aaa/bbb/ccc.dicon.
The separator is “/” in both Windows and UNIX systems.</p>
<pre>private static final String PATH = &quot;aaa/bbb/ccc.dicon&quot;;
...
SingletonS2ContainerFactory.setConfigPath(PATH);
SingletonS2ContainerFactory.init();
...
S2Container container = SingletonS2ContainerFactory.getContainer();</pre>
<h4><a name="S2ContainerFactory">Using S2ContainerFactory</a></h4>
<p>We will use the following method when utilizing S2ContainerFactory.</p>
<p>- org.seasar.framework.container.factory.S2ContainerFactory#create(String path)</p>
<p>We will call the following method after creating S2Container.</p>
<p>- org.seasar.framework.container.S2Container#init()</p>
<pre>private static final String PATH = &quot;aaa/bbb/ccc.dicon&quot;;
...
S2Container container = S2ContainerFactory.create(PATH);
container.init();</pre>
<p>An instance of the container obtained using this method must be managed by an application.</p>

<h3><a name="getComponent">Acquiring Components</a></h3>
<p>To extract a component from S2Container, we use the following method.</p>
<p>- org.seasar.framework.container.S2Container#getComponent(Object componentKey)</p>

<p></p>
<p>A component name or component class can be specified as an argument. 
Please refer to <a href="#componentTag">component tag</a> for details.
When specifying a component class, the class must return true for the component class instanceof class. 
If there are multiple components that implement the specified class,
S2Container will fail to identify the target component and throw TooManyRegistrationRuntimeException.
Please specify a class that will uniquely identify an implemented component, or acquire using the component name.
If there are multiple components with identical names registered, S2Container will throw TooManyRegistrationRuntimeException as well.</p>

<h4>Example: When acquiring a component by class</h4>
<pre>
S2Container container = S2ContainerFactory.create(PATH);
Hoge hoge = (Hoge) container.getComponent(Hoge.class);
</pre>

<h4>Example: When acquiring a component by name</h4>
<pre>
S2Container container = S2ContainerFactory.create(PATH);
Hoge hoge = (Hoge) container.getComponent("hoge");
</pre>

<h3><a name="DIType">Dependency Injection Type</a></h3>
<p>
Dependency Injection has three different types, Constructor Injection, Setter Injection, and Method Injection.
Constructor Injection configures by the constructor,
Setter Injection configures by the setter method,
and Method Injection is configured by the initialization method.
Method injection is specific to S2Container.
S2Container supports all types and its hybrids.</p>

<h3><a name="ConstructorInjection">Constructor Injection</a></h3>
<p>Constructor Injection applies DI to the constructor arguments.
The following contents are written into the S2Container definition file.</p>
<ul>
<li><b>Specifying component</b><br/>
The component is constructed using the component tag. The class name is specified using the class property.
The name property can be used to give the component a name.</li>
<li><b>Specifying constructor argument</b><br/>
The arguments of the constructor are specified in the arg sub-tag of the component tag.
Strings are to be surrounded by double quotation marks (&quot;).</li>
</ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;arg&gt;...&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h3><a name="SetterInjection">Setter Injection</a></h3>
<p>Setter Injection applies DI using the setter method on specified properties.<br/>
The following contents are written into the S2Container definition file.</p>
<ul>
<li><b>Specifying component</b><br/>Specifying component is identical to constructor injection.</li>
<li><b>Specifying property</b><br/>The component properties are specified using the property sub-tag of the component tag.
The name property is used to specify a property name.</li>
</ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;property name=&quot;...&quot;&gt;...&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h3><a name="MethodInjection">Method Injection</a></h3>
<p>Method injection applies DI by calling a specified method.
The following contents are written into the S2Container definition file.</p>
<ul>
<li><b>Specifying component</b><br/>Specifying component is identical to constructor injection.</li>
<li><b>Specifing initialization method</b><br/>
The initMethod tag is used to call the specified method of the component.
The name property is used to specify a method name.
The arg sub-tag is used to define arguments.
The name property can be abbreviated, and <a href="#ognlExpr">OGNL expression</a> used in the body.</li>
</ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
        &lt;initMethod name=&quot;...&quot;&gt;
            &lt;arg&gt;...&lt;/arg&gt;
        &lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h3><a name="Include">S2Container Definition division and include</a></h3>
<p>Listing all components in one file quickly lead to an immense and unmanageable system.
To avoid this, S2Container has functionality to split the definitions into several pieces and recombine those pieces.
The inclusion of S2Container definition files are done as follows.</p>

<pre>&lt;components&gt;
    &lt;include path=&quot;bar.dicon&quot;/&gt;
&lt;/components&gt;
</pre>

<p>Specify the S2Container definition file to be included using the path property of <a href="#includeTag">the include tag</a>.
Please refer to <a href="#includeTag">include tag</a> for additional details.</p>
<p>
The search order for components start with those components registered with itself.
When no matches are found, the process searches in each child S2Container component registration list,
returning the first component found.</p>

<pre>
&lt;components&gt;
    &lt;include path=&quot;aaa.dicon&quot;/&gt;
    &lt;include path=&quot;bbb.dicon&quot;/&gt;
    &lt;component class=&quot;example.container.Foo&quot; /&gt;
&lt;/components&gt;
</pre>

<h3><a name="Namespace">Namespace</a></h3>
<p>
Namespace of components can be specified using the namespace property of the <a href="#componentsTag">components tag</a>. 
This can be used to prevent component name collisions (overlap) between the multiple divided component definitions.</p>
<h5>foo.dicon</h5>
<pre>
&lt;components namespace=&quot;foo&quot;&gt;
    &lt;component name=&quot;aaa&quot; .../&gt;
    &lt;component name=&quot;bbb&quot; ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>bar.dicon</h5>

<pre>
&lt;components namespace=&quot;bar&quot;&gt;
    &lt;include path=&quot;foo.dicon&quot;/&gt;
    &lt;component name=&quot;aaa&quot; .../&gt;
    &lt;component name=&quot;bbb&quot; ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
    &lt;component name=&quot;ccc&quot; ...&gt;
        &lt;arg&gt;foo.aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>app.dicon</h5>

<pre>
&lt;components&gt;
    &lt;include path=&quot;bar.dicon&quot;/&gt;
&lt;/components&gt;
</pre>

<p>Within a single component definition, items may be referenced without a namespace.
"namespace." is prefixed on the component name when referencing an external namespace.
"foo.aaa" and "bar.aaa" shares an identical component name, aaa,
but are recognized as unique components as they inhabit different namespaces, foo and bar.</p>

<h3><a name="InstanceMode">Instance Management</a></h3>
<p>The instance property of the <a href="#componentTag">component tag</a> is used to specify the method of component instance management.</p>

<table width="744" border="1">
  <tr bgcolor="#d1f3f4" align="center">
    <th width="104" scope="col">instance</th>
    <th width="624" scope="col">Description</th>
  </tr>
  <tr>
    <td>singleton(default)</td>
    <td>Every call of S2Container.getComponent() will return the same instance.</td>
  </tr>
  <tr>
    <td>prototype</td>
    <td>Every call of S2Container.getComponent() will return a new instance.</td>
  </tr>
  <tr>
<td>request</td>
<td>A new instance is created for each request.
The component is stored in the request as named using the name property.
<a href="#request">S2ContainerFilter</a> must be configured to use request.</td>
</tr>
<tr>
<td>session</td>
<td>A new instance is created for each session.
The component is stored in the session as named using the name property.
<a href="#request">S2ContainerFilter</a> must be configured to use session.</td>
</tr>
<tr>
<td>outer</td>
<td>The component instance is created external to S2Container, and only Dependency Injection is applied.
<a href="#Aop">Aspect</a> and <a href="#ConstructorInjection">Constructor Injection</a> cannot be used.</td>
</tr>
</table>

<h3><a name="Lifecycle">Lifecycle</a></h3>
<p><a href="#initMethodTag">initMethod tag</a> and <a href="#destroyMethodTag">destroyMethod tag</a> can be used to manage component lifecycles in S2Container. 
The method specified in the <a href="#initMethodTag">initMethod tag</a> is called at the initialization of S2Container, or S2Container.init().
Conversely, S2Container will call the method specified in the <a href="#destroyMethodTag">destroyMethod tag</a> at shutdown of S2Container, or S2Container.destroy().
initMethod is run in order of component registration in the container, and destroyMethod makes calls in reverse order.
destroyMethod is ignored by any method whose instance property is not set to singleton.
java.util.HashMap#put() method looks like the following when configured for initialization (aaa set as 111), or shutdown procedure (aaa set as null).</p>

<pre>
&lt;components namespace=&quot;bar&quot;&gt;
    &lt;component name=&quot;map&quot; class=&quot;java.util.HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;destroyMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;null&lt;/arg&gt;
        &lt;/destroyMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h3><a name="AutoBindingMode">Automatic Binding</a></h3>
<p>Inter-component dependencies are automatically resolved by the container when type is interface.
This is default behavior of S2Container, but can be more finely controlled using the autoBinding property of the <a href="#componentTag">component tag</a>.</p>

<table width="744" border="1">
<tr bgcolor="#d1f3f4" align="center">
<th width="104" scope="col">autoBinding</th>
<th width="624" scope="col">Description</th>
</tr>
<tr>
<td>auto(default)</td>
<td>
Automatic binding of constructor and property is applied.
</td>
</tr>
<tr>
<td>constructor</td>
<td>Automatic binding of constructor is applied.</td>
</tr>
<tr>
<td>property</td>
<td>Automatic binding of property is applied.</td>
</tr>
<tr>
<td>none</td>
<td>Manual binding of constructor and property only.</td>
</tr>
</table>

<br />
<p>Constructor auto-binding rules are as follows.</p>
<ul>
<li>When constructor arguments are 


explicitly

specified, auto-binding is not applied.</li>
<li>When above conditions are not true and a default constructor is specified with no arguments,
that constructor is used with no auto-binding.</li>
<li>When above conditions are not met, the constructor with the largest number of 'interface' type arguments is used.
In addition, components with implemented argument type are acquired from the container and applied.</li>
<li>When above conditions are not met, auto-binding is not applied.</li>
</ul>

<p>Property auto-binding rules are as follows.</p>
<ul>
<li>When property is explicitly selected, auto-binding is not applied.</li>
<li>When above conditions are not met,
if a component with an identical name to the property name is registered in container,
this component will be used.</li>
<li>When above conditions are not met,
if a component that has implemented 'interface' type property is registered in container,
this component will be used.</li>
<li>When above conditions are not met, auto-binding is not applied.</li>
</ul>
<p>The bindingType property of the property tag can be used to more finely control each property.</p>
<table width="744" border="1">
<tr bgcolor="#d1f3f4" align="center">
<th width="104" scope="col">bindingType</th>
<th width="624" scope="col">Description</th>
</tr>
<tr>
<td>must</td>
<td>An exception is throwed when auto-binding is not applied.
</td>
</tr>
<tr>
<td>should(default)</td>
<td>A warning is returned when auto-binding is not applied.</td>
</tr>
<tr>
<td>may</td>
<td>No response is returned when auto-binding is not applied.</td>
</tr>
<tr>
<td>none</td>
<td>Auto-binding is not applied even if the autoBinding property is set to auto or property.</td>
</tr>
</table>
<br/>

<h3><a name="UseS2Container">Using S2Container in Components.</a></h3>
<p>It is preferable that components are not dependent on S2Container.
However, there are certain components that would want to call the S2Container method.
S2Container itself is registered by the name of container.
Using this, an instance of the container can be acquired by specifying container in the body of arg and property tags.
It can also be configured using auto-binding by defining the setter method of the S2Container type.
Specifying container using arg and property tags looks like the following.</p>

<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.BarImpl&quot;&gt;
        &lt;arg&gt;container&lt;/arg&gt;
    &lt;/component&gt;

    &lt;component class=&quot;examples.dicon.FooImpl&quot;&gt;
        &lt;property name=&quot;foo&quot;&gt;container&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h3><a name="S2ContainerServlet">S2ContainerServlet</a></h3>
<p>We have explicitly created S2Container using Java applications so far.
But in the case of web applications, who will create S2Container?
The following class is prepared for this reason.</p>
<ul><li>org.seasar.framework.container.servlet#S2ContainerServlet</li></ul>
<p>The following is entered in web.xml in order to use S2ContainerServlet.</p>

<pre>
&lt;servlet&gt;
    &lt;servlet-name&gt;s2servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.seasar.framework.container.servlet.S2ContainerServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;configPath&lt;/param-name&gt;
        &lt;param-value&gt;app.dicon&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;debug&lt;/param-name&gt;
        &lt;param-value&gt;false&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;s2servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/s2servlet&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre>
<p>The path to the root S2Container definition is selected in configPath.
The definition file is placed in WEB-INF/classes.
Configure load-on-startup tag to make sure S2ContainerServlet is initialized first.
Once S2ContainerServlet is initialized, an instance of S2Container is acquired using the following method.</p>
<ul><li>org.seasar.framework.container.factory.SingletonS2ContainerFactory#getContainer()</li></ul>
<p>The lifecycle of S2Container is linked with S2ContainerServlet.
When the debug parameter is set to true, S2Container may be restarted while operating by using the following command.
In this example, xxx is the web application's context name.</p>
<pre>http://localhost:8080/xxx/s2servlet?command=restart</pre>
<p>ServletContext can be accessed as a component named servletContext when using S2ContainerServlet.</p>

<h3><a name="app.dicon">Purpose of app.dicon</a></h3>
<p>Name the root S2Container definition file "app.dicon" as convention.
It is recommended that the file be stored in WEB-INF/classes.</p>

<h3><a name="Aop">Use of AOP</a></h3>
<p>We can apply <a href="aop.html">AOP</a> to components.
For example, we do the following if we want to apply <a href="aop.html#TraceInterceptor">TraceInterceptor</a> to ArrayList.</p>

<pre>
&lt;components&gt;
    &lt;component name=&quot;traceInterceptor&quot;
               class=&quot;org.seasar.framework.aop.interceptors.TraceInterceptor&quot;/&gt;
    &lt;component class=&quot;java.util.ArrayList&quot;&gt;
        &lt;aspect&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;
    &lt;component class=&quot;java.util.Date&quot;&gt;
        &lt;arg&gt;0&lt;/arg&gt;
        &lt;aspect pointcut=&quot;getTime, hashCode&quot;&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<p>We specify the name of <a href="aop.html#Advice">Interceptor</a> in the body of the aspect tag.
We can specify target method names in the pointcut property.
Multiple entries can be entered separated by commas.
When pointcut is not specified, all interfaces implemented methods in the component are targeted.
A regular expression(JDK1.4 regex) can be used for method name.
A sample use of this definition is as follows.</p>

<pre>
private static final String PATH =
    &quot;examples/dicon/Aop.dicon&quot;;
S2Container container = S2ContainerFactory.create(PATH);
List list = (List) container.getComponent(List.class);
list.size();
Date date = (Date) container.getComponent(Date.class);
date.getTime();
date.hashCode();
date.toString();
</pre>

<p>The results will be the following.</p>

<pre>
BEGIN java.util.ArrayList#size()
END java.util.ArrayList#size() : 0
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
BEGIN java.util.Date#hashCode()
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
END java.util.Date#hashCode() : 0
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
</pre>


<h3><a name="Meta">Metadata</a></h3>

<p>Metadata can be defined in the components, component, arg, and property tags.
The meta tag is used as a child tag in the parent tag where the metadata is to be set.
Adding metadata to a components tag will look like the following example.</p>

<pre>&lt;components&gt;
    &lt;meta name=&quot;aaa&quot;&gt;111&lt;/meta&gt;
&lt;/components&gt;
</pre>

<h3><a name="request">Auto-binding of Requests</a></h3>
<p>HttpServletRequest can be automatically bound to a component.
For this, setRequest (HttpServletRequest request) method is defined within the component.
S2Container will then automatically configure a request.
Also, the following Filter must be defined in web.xml.</p>
<pre>&lt;web-app&gt;<br>    &lt;filter&gt;<br>        &lt;filter-name&gt;s2filter&lt;/filter-name&gt;<br>        &lt;filter-class&gt;org.seasar.framework.container.filter.S2ContainerFilter&lt;/filter-class&gt;<br>    &lt;/filter&gt;<br>    <br>    &lt;filter-mapping&gt;<br>        &lt;filter-name&gt;s2filter&lt;/filter-name&gt;<br>        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;<br>    &lt;/filter-mapping&gt;<br>&lt;/web-app&gt;
</pre>

<p>In this manner, HttpServletResponse and HttpSession can be automatically bound by defining the setter method.
Also, HttpServletRequest, HttpServletResponse, HttpSession can be accessed as components respectively named request, response, session by using S2ContainerFilter.</p>

<h3><a name="ComponentAutoRegister">Component Auto-registration</a></h3>
<p>DI configuration can be mostly automated using <a href="#AutoBindingMode">autobinding</a>.
Fine control can be exerted using <a href="#AnnotationReference">annotation</a>.
Taking this a step further is component auto-registration.</p>

<h5><a name="FileSystemComponentAutoRegister">org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister</a></h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>property</th>
<th>Description</th>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>A sample use of XML is as follows.<br>
<code>@org.seasar.framework.container.deployer.InstanceDefFactory@REQUEST</code></td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>Component to automatically name components from class name.
Requires implementation of org.seasar.framework.container.autoregister.AutoNaming interface.</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>method</th>
<th>Description</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>A class pattern to be auto-registered is registered.
The first argument is the component package name.
Child packages are searched recursively.
The second argument is class name.
One may use regular expressions, and multiple entries can be separated by commas.</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>Class patterns to be ignored by auto-registration are registered.
The first argument is the component package name.
Child packages are searched recursively.
The second argument is class name.
One may use regular expressions, and multiple entries can be separated by commas.</td>
</tr>
</table>
<h5><a name="JarComponentAutoRegister">org.seasar.framework.container.autoregister.JarComponentAutoRegister</a></h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>property</th>
<th>Description</th>
</tr>
<tr>
<td><code>jarFileNames</code></td>
<td>Target jar file names excluded extension are registered.
One may use regular expressions, and multiple entries can be separated by commas.</td>
</tr>
<tr>
<td><code>referenceClass</code></td>
<td>Class in jar is entered.
Default value is @org.aopalliance.intercept.MethodInterceptor@class.</td>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>A sample use of XML is as follows.<br>
<code>@org.seasar.framework.container.deployer.InstanceDefFactory@REQUEST</code></td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>Component to automatically name components from class name.
Requires implementation of org.seasar.framework.container.autoregister.AutoNaming interface.</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>method</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>A class pattern to be auto-registered is registered.
The first argument is the component package name.
Child packages are searched recursively.
The second argument is class name.
One may use regular expressions, and multiple entries can be separated by commas.</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>Class patterns to be ignored by auto-registration are registered.
The first argument is the component package name.
Child packages are searched recursively.
The second argument is class name.
One may use regular expressions, and multiple entries can be separated by commas.</td>
</tr>
</table>

<h5><a name="aComponentAutoRegister">org.seasar.framework.container.autoregister.ComponentAutoRegister</a></h5>
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>property</th>
<th>Description</th>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>A sample use of XML is as follows.<br>
<code>@org.seasar.framework.container.deployer.InstanceDefFactory@REQUEST</code></td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>Component to automatically name components from class name.
Requires implementation of org.seasar.framework.container.autoregister.AutoNaming interface.</td>
</tr>

</table>
<br />
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>method</th>
<th>Description</th>
</tr>
<tr>
<td><code>addReferenceClass</code></td>
<td>Classes in jars are added.</td>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>A class pattern to be auto-registered is registered.
The first argument is the component package name.
Child packages are searched recursively.
The second argument is class name.
One may use regular expressions, and multiple entries can be separated by commas.</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>Class patterns to be ignored by auto-registration are registered.
The first argument is the component package name.
Child packages are searched recursively.
The second argument is class name.
One may use regular expressions, and multiple entries can be separated by commas.</td>
</tr>

</table>
<br />
<p>AutoNaming automatially names components.</p>
<h5><a name="DefaultAutoNaming">org.seasar.framework.container.autoregister.DefaultAutoNaming</a></h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>property</th>
<th>Description</th>
</tr>
<tr>
<td><code>decapitalize</code></td>
<td>Set to true in order to decapitalize component name. Default value is true.</td>
</tr>


</table>
<br>
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>method</th>
<th>Deccription</th>
</tr>
<tr>
<td><code>setCustomizedName</code></td>
<td>Class to be not applied to default rule is registered.
The first argument is the class FQDN.
The second argument is the component name.</td>
</tr>
<tr>
<td><code>addIgnoreClassSuffix</code></td>
<td>Define the part removed from the tail of the class name.
"Impl" and "Bean" are already registered.</td>
</tr>
<tr>
<td><code>addReplaceRule</code></td>
<td>Add the replacement rule by regular expressions.
The first argument is the regular expressions.
The second argument is the replacement value.</td>
</tr>
<tr>
<td><code>clearReplaceRule</code></td>
<td>The replacement rules that are added by setCustomizedName, addIgnoreClassSuffix and addReplaceRuleare method are cleared.</td>
</tr>

</table>
<h5><a name="QualifiedAutoNaming">org.seasar.framework.container.autoregister.QualifiedAutoNaming</a></h5>
<p>パッケージ名またはその一部で修飾されたクラス名をコンポーネントの名前に設定します。
クラスの完全修飾名から最後がImplまたはBeanで終わっていたら削除し､
先頭を小文字、ピリオドの直後を大文字にした名前をコンポーネントの名前に設定します。<br>
パッケージの先頭部分から不要な部分を削除することができます。<br>
例えば､aaa.bbb.ccc.ddd.HogeImplクラスの場合で､先頭のaaa.bbbを削除するように指定した場合のコンポーネント名は､cccDddHogeになります。</p>
<table border="1">



<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>decapitalize</code></td>
<td>コンポーネント名の先頭を小文字にする場合はtrueを指定します。デフォルトはtrueです。</td>
</tr>



</table>
<br>
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>setCustomizedName</code></td>
<td>デフォルトのルールに従わないクラスを登録します。最初の引数は､クラスの完全修飾名です。
2番目の引数は､コンポーネント名です。</td>
</tr>
<tr>
<td><code>addIgnorePackagePrefix</code></td>
<td>パッケージ名の先頭から削除する部分を指定します。</td>
</tr>
<tr>
<td><code>addIgnoreClassSuffix</code></td>
<td>クラス名の末尾から削除する部分を指定します。デフォルトでImplおよびBeanが登録されています。</td>
</tr>
<tr>
<td><code>addReplaceRule</code></td>
<td>正規表現による置換ルールを追加します。最初の引数は正規表現です。2番目の引数は置換文字列です。</td>
</tr>
<tr>
<td><code>clearReplaceRule</code></td>
<td>setCustomizedName、addIgnorePackagePrefix、addIgnoreClassSuffix、addReplaceRuleで登録した変換規則をクリアします。デフォルトで登録されているImplおよびBeanもクリアされます。</td>
</tr>

</table>
<br />
<h5>例</h5>
<pre>
&lt;component
  class=&quot;org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister&quot;&gt;
    &lt;property name=&quot;autoNaming&quot;&gt;
        &lt;component class=&quot;org.seasar.framework.container.autoregister.DefaultAutoNaming&quot;&gt;
            &lt;initMethod name=&quot;setCustomizedName&quot;&gt;
                &lt;arg&gt;&quot;examples.di.impl.HogeImpl&quot;&lt;/arg&gt;
                &lt;arg&gt;&quot;hoge2&quot;&lt;/arg&gt;
            &lt;/initMethod&gt;
        &lt;/component&gt;
    &lt;/property&gt;
    &lt;initMethod name=&quot;addClassPattern&quot;&gt;
        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;
        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;
    &lt;/initMethod&gt;
&lt;/component&gt;
</pre>

<pre>
&lt;component class=&quot;org.seasar.framework.container.autoregister.JarComponentAutoRegister&quot;&gt;
    &lt;property name=&quot;referenceClass&quot;&gt;
        @junit.framework.TestSuite@class
    &lt;/property&gt;
    &lt;property name=&quot;jarFileNames&quot;&gt;&quot;junit.*&quot;&lt;/property&gt;
    &lt;initMethod name=&quot;addClassPattern&quot;&gt;
        &lt;arg&gt;&quot;junit.framework&quot;&lt;/arg&gt;
        &lt;arg&gt;&quot;TestSuite&quot;&lt;/arg&gt;
    &lt;/initMethod&gt;
&lt;/component&gt;
</pre>

<pre>
&lt;component class=&quot;org.seasar.framework.container.autoregister.ComponentAutoRegister&quot;&gt;
    &lt;initMethod name=&quot;addReferenceClass&quot;&gt;
        &lt;arg&gt;@aaa.bbb.ccc.ddd.HogeImpl@class&lt;/arg&gt;
    &lt;/initMethod&gt;
    &lt;initMethod name=&quot;addClassPattern&quot;&gt;
        &lt;arg&gt;&quot;aaa.bbb&quot;&lt;/arg&gt;
        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;
    &lt;/initMethod&gt;
&lt;/component&gt;
</pre>

<h3><a name="AspectAutoRegister">アスペクトの自動登録</a></h3>
<p><a href="#ComponentAutoRegister">コンポーネントの自動登録</a>により、コンポーネントの登録は自動化できます。
さらに、アスペクトの登録も自動化してしまおうというのが、アスペクトの自動登録機能です。アスペクトの自動登録には､AspectAutoRegisterコンポーネントを利用します。</p>
<h5>org.seasar.framework.container.autoregister.AspectAutoRegister</h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>interceptor</code></td>
<td>インターセプタを指定します。複数のインターセプタを指定したい場合は､<a href="aop.html#InterceptorChain">InterceptorChain</a>を使ってください。</td>
</tr>
<tr>
<td><code>pointcut</code></td>
<td> インターセプタを適用するメソッドをカンマ区切りで指定します。pointcutを指定しない場合は、コンポーネントが実装しているインターフェースのすべてのメソッドが対象になります。メソッド名には正規表現(JDK1.4のregex)も使えます。 </td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPatten</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<br />
<h5>例</h5>
<pre>&lt;include path=&quot;aop.dicon&quot;/&gt;
...
&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.AspectAutoRegister&quot;&gt;<br>    &lt;property name=&quot;interceptor&quot;&gt;aop.traceInterceptor&lt;/property&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>&lt;/component&gt;
</pre>

<h5><a name="InterfaceAspectAutoRegister">org.seasar.framework.container.autoregister.InterfaceAspectAutoRegister</a></h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>interceptor</code></td>
<td>インターセプタを指定します。複数のインターセプタを指定したい場合は､<a href="aop.html#InterceptorChain">InterceptorChain</a>を使ってください。</td>
</tr>
<tr>
<td><code>targetInterface</code></td>
<td> 指定したインターフェースを実装しているコンポーネントに対して､アスペクトを適用します。 </td>
</tr>
</table>
<br />

<br />
<h5>例</h5>
<pre>&lt;include path=&quot;aop.dicon&quot;/&gt;
...
&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.InterfaceAspectAutoRegister&quot;&gt;<br>    &lt;property name=&quot;interceptor&quot;&gt;aop.traceInterceptor&lt;/property&gt;
    &lt;property name=&quot;targetInterface&quot;&gt;@examples.Greeing@class&lt;/property&gt;<br>&lt;/component&gt;
</pre>

<h3><a name="Hotswap">Hotswap</a></h3>
<p>従来、ソースコードを書き換えてコンパイルした場合､コンパイル後の機能を試すためには､
アプリケーション(正確にはClassLoader)を再起動する必要がありました。
アプリケーションサーバ上で､アプリケーションを再起動するのは､非常に時間がかかるものです。
「かったるい」と思っていた方も多くいることでしょう。</p>
<p>Seasar2では、アプリケーションを稼動させたまま､クラスファイルを置き換えて、
即座に試すことのできる<b>Hotswap</b>機能を実現しています。
これであの「イライラ」からも解放されます。余分な待ち時間が無いので生産性を向上させることもできます。それでは、試してみましょう。</p>
<h4>Greeting.java</h4>
<pre>
package examples.hotswap;

public interface Greeting {

    String greet();
}
</pre>
<h4>GreetingImpl.java</h4>
<pre>
package examples.hotswap.impl;

import examples.hotswap.Greeting;

public class GreetingImpl implements Greeting {

    public String greet() {
        return "Hello";
    }
}
</pre>
<h4>hotswap.dicon</h4>
<pre>&lt;components&gt;<br>    &lt;component class=&quot;examples.hotswap.impl.GreetingImpl&quot;/&gt;<br>&lt;/components&gt;
</pre>
<p>ここまでは､特に変わったところはありません。ポイントはこれからです。
s2container.diconを使って、hotswapモードに切り替えます。</p>
<h4>s2container.dicon</h4>
<pre>&lt;components&gt;<br>    &lt;component<br>      class=&quot;org.seasar.framework.container.factory.S2ContainerFactory$DefaultProvider&quot;&gt;<br>        &lt;property name=&quot;hotswapMode&quot;&gt;true&lt;/property&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;<br></pre>
<p>s2container.diconはクラスパスの通っているルートのディレクトリに置いておけば､自動で認識されます。
S2ContainerFactory#configure()を使って明示的に指定することもできます。</p>
<h4>GreetingMain.dicon</h4>
<pre>
package examples.hotswap.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.hotswap.Greeting;

public class GreetingMain {

    private static final String CONFIGURE_PATH =
        "examples/hotswap/dicon/s2container.dicon";

    private static final String PATH =
        "examples/hotswap/dicon/hotswap.dicon";

    public static void main(String[] args) throws Exception {
        S2ContainerFactory.configure(CONFIGURE_PATH);
        S2Container container = S2ContainerFactory.create(PATH);
        System.out.println("hotswapMode:" + container.isHotswapMode());
        container.init();
        try {
            Greeting greeting = (Greeting) container
                    .getComponent(Greeting.class);
            System.out.println(greeting.greet());
            System.out.println("Let's modify GreetingImpl, then press ENTER.");
            System.in.read();
            System.out.println("after modify");
            System.out.println(greeting.greet());
        } finally {
            container.destroy();
        }
    }
}
</pre>
<p>hotswapを使うためには､S2Container#init()を呼び出す必要があります。
実行すると"Hello"と表示された後に､プログラムが停止するので､
GreetingImpl#greet()が"Hello2"を返すように修正してコンパイルします。
その後､コンソールにフォーカスを当ててENTERキーを押してください。
同じインスタンスなのにかかわらず、classファイルが入れ替わっていることがわかります。
これは、<a href="#InstanceMode">インスタンスモード</a>がsingletonの場合の例ですが､
<a href="#InstanceMode">インスタンスモード</a>がprototypeの場合は､S2Container#getComponent()のタイミングでクラスが入れ替わります。</p>
<h4>実行結果</h4>
<pre>
hotswapMode:true
Hello
Let's modify GreetingImpl, then press ENTER.

after modify
Hello2
</pre>
<p>hotswapを使うためには､コンポーネントがインターフェースを提供し､
コンポーネントの利用者側は､インターフェース経由でコンポーネントを利用する必要があります。
<a href="#InstanceMode">インスタンスモード</a>がrequest、sessionの場合は､
そのコンポーネントが他のコンポーネントから参照されていない場合には､
インターフェースなしでもhotswapを利用することができます。
</p>


<h2><a name="DefReference">S2Containerタグリファレンス</a></h2>

<h3><a name="DOCTYPE">DOCTYPE</a></h3>
<p>DOCTYPEは、XML宣言の次に指定します。下記のように指定してください。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;hello&quot; class=&quot;examples.dicon.HelloConstructorInjection&quot;&gt;
        &lt;arg&gt;&quot;Hello World!&quot;&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h3><a name="componentsTag">componentsタグ(必須)</a></h3>
            <p>ルートのタグになります。</p>
            <h4><a name="namespaceAttr">namespace属性(任意)</a></h4>
            <p><a href="#Namespace">名前空間</a>を指定することができます。Javaの識別子として使えるものにします</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components namespace=&quot;hoge&quot;&gt;
    ...
&lt;/components&gt;
</pre>

            <h3><a name="includeTag">includeタグ(任意)</a></h3>
            <p>分割されたS2Containerの定義を<a href="#Include">取り込む</a>場合に使います。</p>
            <h4><a name="pathAttr">path属性(必須)</a></h4>
            <p>定義ファイルのパスを指定することができます。CLASSPATHで指定されているディレクトリをルートとする定義ファイルの絶対パスです。例えば、WEB-INF/classes/aaa.dicon
の場合は aaa.dicon に、WEB-INF/classes/aaa/bbb/ccc.dicon の場合は aaa/bbb/ccc.dicon
になりますセパレータは、WindowsでもUnixでも/です。componentタグの前に記述する必要があります。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;include path=&quot;aaa/bbb/ccc.dicon&quot; /&gt;
&lt;/components&gt;
</pre>

            <h3><a name="componentTag">componentタグ(任意)</a></h3>
            <p>コンポーネントを定義します。</p>
            <h4><a name="classAttr">class属性(任意)</a></h4>
            <p>クラスの完全限定名を指定します。ボディで、<a href="#ognlExpr">OGNL式</a>を使ってコンポーネントを指定した場合は、class属性を省略することができます。OGNL式を使った場合にclass属性を指定すると、型チェックを行います。</p>
            <h4><a name="componentTag.nameAttr">name属性(任意)</a></h4>
            <p>名前を指定することもできます。Javaの識別子として使えるものにします。詳しくは、<a href="#getComponent">コンポーネントの取得</a>を参照してください。</p>
            <h4><a name="instanceAttr">instance属性(任意)</a></h4>
            <p>S2Containerがどのようにコンポーネントのインスタンスを管理するのかを指定することができます。singleton(デフォルト)、prototype、outer、request、sessionを指定することができます。詳しくは、<a href="#InstanceMode">インスタンス管理</a>を参照してください。</p>
            <h4><a name="autoBindingAttr">autoBinding属性(任意)</a></h4>
            <p>S2Containerがコンポーネントの依存関係をどのように解決するのかを指定できます。auto(デフォルト)、constructor、property、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。</p>

            <h3><a name="argTag">argタグ(任意)</a></h3>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使った場合は、コンストラクタの引数になります。記述した順番でコンストラクタに渡されます。
            <a href="#initMethodTag">initMethodタグ</a>、<a href="#destroyMethodTag">destroyMethodタグ</a>の子タグとして使った場合は、メソッドの引数になります。記述した順番でメソッドに渡されます。
            引数として渡される実際の値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

            <h3><a name="propertyTag">propertyタグ(任意)</a></h3>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使います。プロパティとして設定される実際の値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

			<h4><a name="propertyTag.nameAttr">name属性(必須)</a></h4>
            <p>プロパティ名を指定します。</p>

			<h4><a name="propertyTag.bindingTypeAttr">bindingType属性(任意)</a></h4>
            <p>プロパティごとに自動バインディングを細かく制御できます。must、should(デフォルト)、may、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。</p>

			<h3><a name="metaTag">metaタグ(任意)</a></h3>
            <p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとして使います。メタデータの値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

<h4><a name="propertyTag.nameAttr">name属性(任意)</a></h4>

            <p>メタ名を指定します。</p>

            <h3><a name="initMethodTag">initMethodタグ(任意)</a></h3>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使います。引数は、子タグで、<a href="#argTag">argタグ</a>を使います。name属性を書かずに、<a href="#ognlExpr">OGNL式</a>を使って、コンポーネントのメソッドを呼び出すこともできます。initMethodタグが定義されているコンポーネント自身を表す#self、System.outを表す#out、System.errを表す#errがinitMethodタグ内だけで有効なオブジェクトとして使えます。</p>
            <h4><a name="initMethodTag.nameAttr">name属性(任意)</a></h4>
            <p>メソッド名を指定します。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;java.util.HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;initMethod&gt;#self.put(&quot;aaa&quot;, 111)&lt;/initMethod&gt;
        &lt;initMethod&gt;#out.println(&quot;Hello&quot;)&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h3><a name="destroyMethodTag">destroyMethodタグ(任意)</a></h3>
            <p>initMethodタグと同様です。</p>

            <h3><a name="aspectTag">aspectタグ(任意)</a></h3>
            <p>アスペクトをコンポーネントに組み込みます。詳しくは、S2AOPの<a href="aop.html#aspectTag">aspectタグ</a>の説明を参照してください。</p>

            <h3><a name="descriptionTag">descriptionタグ(任意)</a></h3>

            <p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとしてdescriptionタグを使うことができます。自由に説明を記述できます。</p>

            <h3><a name="ognlExpr">OGNL式</a></h3>
            <p>S2Containerでは、式言語として<a href="http://www.ognl.org/">OGNL</a>を利用しています。XMLの中で、文字列で記述した内容(式)をJavaのオブジェクトに変換するためのものだと思って間違いないと思います。</p>

            <ul>
            <li>文字列は、&quot;hoge&quot;のように&quot;で囲みます。</li>
            <li>charは、'a'のように'で囲みます。</li>
            <li>数値は、123のようにそのまま記述します。</li>
            <li>論理値は、true,falseのようにそのまま記述します。</li>
            <li>new java.util.Date(0)のようにクラスの完全限定名でコンストラクタを呼び出すことができます。</li>
            <li> @java.lang.Math@max(1, 2)のようにstaticなメソッドを呼び出した結果を参照することができます。</li>
            <li>@java.lang.String@classのようにクラスを参照できます。</li>
            <li>hoge.toString()のようにコンポーネントのメソッドを呼び出した結果を参照することができます。この例は、どこかでhogeという名前のコンポーネントが定義されているという前提です。</li>
            </ul>
            詳しくは、<a href="http://www.ognl.org/2.6.7/Documentation/html/LanguageGuide/index.html">OGNLのマニュアル</a>を参照してください。<br/>
            <br/>

<h2><a name="AnnotationReference">S2Containerアノテーションリファレンス</a></h2>
<p>S2Containerでは、アノテーションの実装方法として､
Tigerアノテーション､backport175アノテーション､定数アノテーションの3種類を用意しています。一般的にアノテーションといえば､Java 5から導入された
Tigerアノテーションですが､それだけだと、JDK1.4のユーザが利用できなくなってしまいます。</p>
<p>できるだけ、多くの方にアノテーションを便利に使ってもらいたいため､JDK1.4で、
Tiger風アノテーション(JSR-175)を使うことのできる
<a href="http://backport175.codehaus.org/">backport175</a>アノテーション、public static finalな定数を利用する定数アノテーションを用意しています。 </p>

<h3><a name="ComponentAnnotation">Componentアノテーション</a></h3>
<p><a href="#componentTag">componentタグ</a>のかわりに使えるが、Componentアノテーションです。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Component(name="xxx", instance=InstanceType.PROTOTYPE,
        autoBinding=AutoBindingType.PROPERTY)
public class Xxx {
    ...
}
</pre>
<p>backport175アノテーションは以下のようになります。</p>
<pre>
/**
 * @org.seasar.framework.container.annotation.backport175.Component(
 *      name = "xxx",
 *      instance = "prototype",
 *      autoBinding = "property")
 */
public class Xxx {
    ...
}
</pre>
<p>定数アノテーションは以下のようになります。</p>
<pre>
public static final String COMPONENT =
  "name = xxx, instance = prototype, autoBinding = property";
</pre>

<h3><a name="BindingAnnotation">Bindingアノテーション</a></h3>
<p><a href="#propertyTag">propertyタグ</a>のかわりに使えるが、Bindingアノテーションです。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Binding("aaa2")
public void setAaa(String aaa) {
    ...
}

@Binding(bindingType=BindingType.NONE)
public void setBbb(String bbb) {
    ...
}

@Binding
public void setCcc(String ccc) {
    ...
}
</pre>
<p>backport175アノテーションは以下のようになります。</p>
<pre>
/**

 * @org.seasar.framework.container.annotation.backport175.Binding("aaa2")
 */
public void setAaa(String aaa) {
    ...
}

/**
 * @org.seasar.framework.container.annotation.backport175.Binding(bindingType="none")
 */
public void setBbb(String bbb) {
    ...
}

/**
 * @org.seasar.framework.container.annotation.backport175.Binding
 */
public void setCcc(String ccc) {
    ...
}
</pre>
<p>定数アノテーションはプロパティ名_BINDINGで指定します。</p>
<pre>
public static final String aaa_BINDING = "aaa2";

public static final String bbb_BINDING = "bindingType=none";

public static final String ccc_BINDING = null;

public void setAaa(String aaa) {
    ...
}

public void setBbb(String bbb) {
    ...
}

public void setCcc(String ccc) {
    ...
}
</pre>

<h3><a name="AspectAnnotation">Aspectアノテーション</a></h3>
<p><a href="aop.html#aspectTag">aspectタグ</a>のかわりに使えるが、Aspectアノテーションです。aspectタグと異なり､複数定義することはできないので､
複数のインターセプタを適用したい場合は､<a href="aop.html#InterceptorChain">InterceptorChain</a>を使ってください。ポイントカットを指定したいときは､pointcut属性を指定します。クラスに対するアノテーションの場合､pointcutを指定しないときは､そのクラスが実装しているすべてのインターフェースのメソッドが対象になります。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Aspect("aop.traceInterceptor")
public class Xxx {
    ...
}

public class Xxx {
    ...
    @Aspect("aop.traceInterceptor")
    public void hoge() {
        ...
    }
}
</pre>
<p>backport175アノテーションは以下のようになります。</p>
<pre>
/**
 * @org.seasar.framework.container.annotation.backport175.Aspect(
 *  "aop.traceInterceptor")
 */
public class Xxx {
    ...
}

public class Xxx {
    ...
    /**
     * @org.seasar.framework.container.annotation.backport175.Aspect(
     *  "aop.traceInterceptor")
     */
    public void hoge() {
        ...
    }
}
</pre>
<p>定数アノテーションは以下のようになります。pointcutを複数指定したい場合は､pointcut= get.*\nexecute.*のように\nで区切ってください。
\n以外の区切り文字を使ってはいけません。</p>
<pre>
public static final String ASPECT =
    "interceptor=aop.traceInterceptor, pointcut=getAaa";
</pre>

<h3><a name="InitMethodAnnotation">InitMethodアノテーション</a></h3>
<p><a href="#initMethodTag">initMethodタグ</a>のかわりに使えるのが、InitMethodアノテーションです。
initMethodタグと異なり､OGNLの式を書いたり、引数を設定することはできません。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
public class Xxx {
    ...
    @InitMethod
    public void init() {
        ...
    }
}
</pre>
<p>backport175アノテーションは以下のようになります。</p>
<pre>
public class Xxx {
    ...
    /**
     * @org.seasar.framework.container.annotation.backport175.InitMethod
     */
    public void init() {
        ...
    }
}
</pre>
<p>定数アノテーションは以下のようになります。初期化メソッドを複数指定したい場合は､カンマ(,)で区切ってください。</p>
<pre>
public static final String INIT_METHOD = "init";
</pre>

<!-- document end -->
<!-- don't edit start -->
</td>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="14"><img height="30" width="14" src="images/spacer.gif" alt=""></td>
<td width="766"><img height="30" width="592" src="images/spacer.gif" alt=""></td></tr><tr>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
<td width="766" class="copyright">&copy; Copyright The Seasar Foundation and the others 2004, all rights reserved.</td>
</tr></table>
<td class="backright" align="left" valign="top">&nbsp;</td></tr><tr>
<td class="backunder" align="left"  valign="top" width="780" height="16">&nbsp;</td>
<td class="backcorner" align="left" valign="top" height="16">&nbsp;</td>
</tr></table></body>
<!-- don't edit end -->
</html>
