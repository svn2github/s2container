<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<!-- don't edit start -->
<head>
<title>Seasar - DI Container with AOP -</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<link href="seasar_b.css" type="text/css" rel="stylesheet" media="screen" />
<link href="seasar_p.css" type="text/css" rel="stylesheet" media="print" />
<script src="seasar_b.js" type="text/JavaScript" language="JavaScript">
</script>
</head>
<body onload="preload('ja')">
<table width="100%" border="0" cellspacing="0" cellpadding="0" align="left">
<tr>
<td align="left" valign="top" width="780">
<table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr>
<td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt="" /></td>
</tr>
<tr>
<td width="235"><img height="117" width="235" src="images/top02_b.gif" alt="Seasar" /></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP" /></td>
<td colspan="3"><img height="117" width="256" src="images/spacer.gif" alt="" /></td>
</tr>
<tr>
<td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235" /></td>
<td><a href="http://www.seasar.org/index.html"><img src="images/menu01_b_ja.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)" name="menu01" /></a></td>
<td><a href="http://www.seasar.org/projects.html"><img src="images/menu02_b_ja.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)" name="menu02" /></a></td>
<td><a href="http://www.seasar.org/products.html"><img src="images/menu03_b_ja.gif" height="30" width="110" border="0" alt="" id="menu03" onmouseover="swap(3)" onmouseout="restore(3)" name="menu03" /></a></td>
<td><a href="http://www.seasar.org/resources.html"><img src="images/menu04_b_ja.gif" height="30" width="113" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)" name="menu04" /></a></td>
<td><img src="images/menu05_b_ja.gif" height="30" width="109" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)" name="menu05" /></td>
<td width="34"><img height="30" width="34" src="images/menu06.gif" alt="" /></td>
</tr>
<tr>
<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt="" /></td>
</tr>
</table>
<table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr align="left" valign="top">
<td width="18"><img height="14" width="18" src="images/spacer.gif" alt="" /></td>
<td width="744" class="main"><!-- don't edit end -->
<!-- document start -->
<ul>
<li><a href="#FeatureReference">機能リファレンス</a>
<ul>
<li><a href="#CreateFile">作成すべきファイル</a></li>
<li><a href="#S2ContainerDefinition">S2Containerの定義</a></li>
<li><a href="#S2ContainerCreation">S2Containerの生成</a>
<ul>
<li><a href="#SingletonS2ContainerFactory">SingletonS2ContainerFactory</a></li>
<li><a href="#S2ContainerFactory">S2ContainerFactory</a></li>
<li><a href="#S2ContainerServlet">S2ContainerServlet</a></li>
</ul>
</li>
<li><a href="#getComponent">コンポーネントの取得</a></li>
<li><a href="#DIType">Dependency Injectionのタイプ</a>
<ul>
<li type="circle"><a href="#ConstructorInjection">コンストラクタ・インジェクション</a></li>
<li type="circle"><a href="#SetterInjection">セッター・インジェクション</a></li>
<li type="circle"><a href="#MethodInjection">メソッド・インジェクション</a></li>
<li type="circle"><a href="#FieldInjection">フィールド・インジェクション</a></li>
</ul>
</li>
<li><a href="#InstanceMode">インスタンス管理</a></li>
<li><a href="#AutoBindingMode">自動バインディング</a></li>
<li><a href="#S2ContainerLifecycle">S2Containerのライフサイクル</a></li>
<li><a href="#ComponentLifecycle">コンポーネントのライフサイクル</a></li>
<li><a href="#Env">環境名</a></li>
<li><a href="#Include">定義ファイルのインクルード</a></li>
<li><a href="#ConditionalInclude">定義ファイルの条件インクルード</a></li>
<li><a href="#XInclude">定義ファイルの埋め込みインクルード(XInclude)</a></li>
<li><a href="#Namespace">名前空間</a></li>
<li><a href="#S2ContainerFilter">S2ContainerFilter</a></li>
<li><a href="#ImplicitComponent">暗黙的なコンポーネント</a></li>
<li><a href="#Aop">AOPの適用</a></li>
<li><a href="#Meta">メタデータ</a></li>
<li><a href="#ComponentAutoRegister">コンポーネントの自動登録</a></li>
<li><a href="#AspectAutoRegister">アスペクトの自動登録</a></li>
<li><a href="#MetaAutoRegister">メタデータの自動登録</a></li>
<li><a href="#SMARTdeploy">SMART deploy</a>
<ul>
<li><a href="#SMARTdeployS2ContainerDicon">SMART deployの切り替え</a></li>
<li><a href="#SMARTdeployPackage">SMART deployのパッケージ構成</a></li>
<li><a href="#Creator">クリエータ</a></li>
<li><a href="#Customizer">カスタマイザ</a></li>
<li><a href="#CustomizerConfigExample">カスタマイザ設定例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#TagReference">タグリファレンス</a>
<ul>
<li><a href="#DOCTYPE">DOCTYPE</a></li>
<li><a href="#componentsTag">componentsタグ</a></li>
<li><a href="#includeTag">includeタグ</a></li>
<li><a href="#componentTag">componentタグ</a></li>
<li><a href="#argTag">argタグ</a></li>
<li><a href="#propertyTag">propertyタグ</a></li>
<li><a href="#metaTag">metaタグ</a></li>
<li><a href="#initMethodTag">initMethodタグ</a></li>
<li><a href="#destroyMethodTag">destroyMethodタグ</a></li>
<li><a href="#aspectTag">aspectタグ</a></li>
<li><a href="#interTypeTag">interTypeタグ</a></li>
<li><a href="#descriptionTag">descriptionタグ</a></li>
<li><a href="#ognlExpr">OGNL式</a></li>
</ul>
</li>
<li><a href="#AnnotationReference">アノテーションリファレンス</a>
<ul>
<li><a href="#ComponentAnnotation">Componentアノテーション</a></li>
<li><a href="#BindingAnnotation">Bindingアノテーション</a></li>
<li><a href="#AspectAnnotation">Aspectアノテーション</a></li>
<li><a href="#InterTypeAnnotation">InterTypeアノテーション</a></li>
<li><a href="#InitMethodAnnotation">InitMethodアノテーション</a></li>
<li><a href="#DestroyMethodAnnotation">DestroyMethodアノテーション</a></li>
</ul>
</li>
</ul>

<h2><a name="FeatureReference" id="FeatureReference">機能リファレンス</a></h2>
<h3><a name="CreateFile" id="CreateFile"><b>作成すべきファイル</b></a></h3>
<p>S2Containerを使用するためには、定義ファイルを作成する必要があります。 
定義ファイルは、コンポーネントを組み立てるための設計書のようなものです。 
形式はXMLで、拡張子は、diconです。</p>
<h3><a name="S2ContainerDefinition" id="S2ContainerDefinition"><b>S2Containerの定義</b></a></h3>
<p>S2Containerの定義は、次のようになります。</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.4//EN"
"http://www.seasar.org/dtd/components24.dtd"&gt;
&lt;components&gt;
    &lt;component name="..." class="..."&gt;
            ...
    &lt;/component&gt;
    &lt;component name="..." class="..."&gt;
            ...
    &lt;/component&gt;
&lt;/components&gt;
</pre>
<p>DOCTYPEは省略できません。diconファイルを作成する場合は、上記のサンプルをコピー＆ペーストしてください。
ルートは<a href="#componentsTag">componentsタグ</a>です。
コンポーネントごとに、<a href="#componentTag">componentタグ</a>を定義していきます。
componentタグのclass属性でコンポーネントのクラスの完全限定名を指定します。
name属性には、コンポーネント名を指定します。
詳細は、<a href="#DefReference">S2Container定義タグリファレンス</a>を参照してください。</p>

<h3><a name="S2ContainerCreation" id="S2ContainerCreation">S2Containerの生成</a></h3>
<p>S2Containerを生成する方法は3通りあります。</p>

<h4><a name="SingletonS2ContainerFactory" id="SingletonS2ContainerFactory">SingletonS2ContainerFactory</a></h4>
<p>SingletonS2ContainerFactoryを使用するサンプルは次のようになります。</p>
<pre>
SingletonS2ContainerFactory.init();
S2Container container = SingletonS2ContainerFactory.getContainer();
</pre>
<p>何も指定しない場合、デフォルトの定義ファイルはCLASSPATHで指定されているディレクトリにあるapp.diconになります。
通常のWebアプリケーションの場合、WEB-INF/classes/app.diconです。</p>
<p>定義ファイルのパスを指定する場合はinit()を呼び出す前にsetConfigPath(String Path)を使用します。
引数pathはCLASSPATHで指定されているディレクトリをルートとする定義ファイルの絶対パスです。
例えば、WEB-INF/classes/aaa.dicon の場合は aaa.dicon に、
WEB-INF/classes/aaa/bbb/ccc.dicon の場合は aaa/bbb/ccc.dicon になります。セパレータは、WindowsでもUnixでも/です。</p>
<pre>
private static final String PATH = "aaa/bbb/ccc.dicon";
...
SingletonS2ContainerFactory.setConfigPath(PATH);
SingletonS2ContainerFactory.init();
S2Container container = SingletonS2ContainerFactory.getContainer();
</pre>
<p>Webアプリケーションの場合、SingletonS2ContainerFactory.init()は、
<a href="#S2ContainerServlet">S2ContainerServlet</a>が自動的に呼び出すので、
明示的に呼び出す必要はありません。
</p>

<h4><a name="S2ContainerFactory" id="S2ContainerFactory">S2ContainerFactory</a></h4>
<p>S2ContainerFactoryを使用するサンプルは次のようになります。</p>
<pre>
private static final String PATH = "aaa/bbb/ccc.dicon";
...
S2Container container = S2ContainerFactory.create(PATH);
</pre>
<p>この方法で取得したコンテナのインスタンスは、アプリケーションで管理する必要があります。
S2ContainerFactoryはSingletonS2ContainerFactoryが内部的に呼び出すクラスで、
通常は意識する必要はありません。
</p>

<h4><a name="S2ContainerServlet" id="S2ContainerServlet">S2ContainerServlet</a></h4>
<p>Webアプリケーションの場合、S2ContainerServletがSingletonS2ContainerFactory.init()を自動的に呼び出します。<br />
S2ContainerServletを使うためには、web.xmlに次の項目を記述します。</p>
<pre>
&lt;servlet&gt;
    &lt;servlet-name&gt;s2servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.seasar.framework.container.servlet.S2ContainerServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;configPath&lt;/param-name&gt;
        &lt;param-value&gt;app.dicon&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;debug&lt;/param-name&gt;
        &lt;param-value&gt;false&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;s2servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/s2servlet&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre>
<p>configPathで定義ファイルのパスを指定します。</p>
<p>debugパラメータをtrueにすると、次のようにして稼動中にS2Containerを再起動できます。
xxxはWebアプリケーションのコンテキスト名です。</p>
<pre>
http://localhost:8080/xxx/s2servlet?command=restart         
</pre>
<p>また、次のようにS2Containerにデプロイされているコンポーネントの定義を見ることもできます。
</p>
<pre>
http://localhost:8080/xxx/s2servlet?command=list         
</pre>
<br />
<img src="images/component_list.jpg"/>
<br />
<p>S2ContainerServletは、他のサーブレットよりもはやく起動されるようにload-on-startupタグを調整してください。</p>

<h3><a name="getComponent" id="getComponent">コンポーネントの取得</a></h3>
<p>S2Containerからコンポーネントを取り出すには、次のメソッドを使用します。</p>
<pre>
S2Container.getComponent(Object componentKey)
</pre>
<p>
componentKeyには、コンポーネントのクラスもしくはコンポーネント名を指定できます。</p>
<p>コンポーネントのクラスを指定する場合、コンポーネント instanceof クラスがtrueを返すクラスを指定することができます。
S2Containerの中に指定したクラスを実装しているコンポーネントが複数ある場合、
S2Containerは、どのコンポーネントを返せばよいのか判断できないため、
TooManyRegistrationRuntimeExceptionが発生します。
実装コンポーネントがユニークに決まるクラスを指定してください。</p>
<p>コンポーネント名で取得することもできます。
その場合も、同一の名前をもつコンポーネントが複数登録されている場合、
TooManyRegistrationRuntimeExceptionが発生します。
コンポーネント名指定の場合、スペルミスをする可能性もあるので、
できるだけクラス指定のほうが良いでしょう。</p>
<p>Java5でS2Tigerを利用している場合、SingletonS2Containerを使うことでキャストを不要にできます。
SingletonS2Containerを使う場合、あらかじめ<a href="#SingletonS2ContainerFactory">SingletonS2ContainerFactory</a>で、
S2Containerを初期化しておく必要があります。
SingletonS2Containerを利用するにはSeasar2.4以上が必要です。</p>
<pre>
Hoge hoge = (Hoge) container.getComponent(Hoge.class);
Hoge hoge = SingletonS2Container.getComponent(Hoge.class);
Hoge hoge = (Hoge) container.getComponent("hoge");
Hoge hoge = SingletonS2Container.getComponent("hoge");
</pre>

<h3><a name="DIType" id="DIType">Dependency Injectionのタイプ</a></h3>
<p>Dependency Injectionには次のようなタイプがあります。
コンストラクタ・インジェクション、セッター・インジェクション、メソッド・インジェクションは組み合わせて使うこともできます。</p>

<h4><a name="ConstructorInjection" id="ConstructorInjection">コンストラクタ・インジェクション</a></h4>
<p>コンストラクタの引数にDIを行なうのがコンストラクタ・インジェクションです。<br />
コンストラクタの引数には、componentタグの子タグであるargタグを使って指定します。
</p>
<pre>
&lt;components&gt;
    &lt;component name="..." class="..."&gt;
        &lt;arg&gt;...&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h4><a name="SetterInjection" id="SetterInjection">セッター･インジェクション</a></h4>
<p>セッターメソッドにDIを行なうのがセッター･インジェクションです。<br />
コンポーネントのプロパティには、componentタグの子タグであるpropertyタグを使って指定します。<br />
プロパティ名はname属性で指定します。</p>
<pre>
&lt;components&gt;
    &lt;component name="..." class="..."&gt;
        &lt;property name="..."&gt;...&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h4><a name="MethodInjection" id="MethodInjection">メソッド・インジェクション</a></h4>
<p>メソッドにDIを行なうのがメソッド・インジェクションです。<br />
コンポーネントのメソッドには、componentタグの子タグであるinitMethodタグを使って指定します。<br />
メソッド名はname属性で指定します。<br />
initMethodタグの子タグであるargタグで引数を指定することや、name属性を省略してボディで<a href="#ognlExpr">OGNL式</a>を使うこともできます。
</p>
<pre>
&lt;components&gt;
    &lt;component name="..." class="..."&gt;
        &lt;initMethod name="..."&gt;
            &lt;arg&gt;...&lt;/arg&gt;
        &lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h4><a name="FieldInjection" id="FieldInjection">フィールド・インジェクション</a></h4>
<p>フィールドにDIを行なうのがフィールド・インジェクションです。<br />
フィールドには、<a href="#BindingAnnotation">Bindingアノテーション</a>を使って指定します。この機能は、2.4から利用できます。
</p>
<pre>
@Binding("foo")
private Foo foo;
</pre>
<p>
バージョン2.4.17からは、publicなフィールドをプロパティとして認識するようになったので、
publicフィールドを定義しておけば<a href="#AutoBindingMode">自動バインディング</a>が
適用されます。上記のfooプロパティの例は次のようになります。
publicフィールドにBindingアノテーションを指定することもできます。
</p>
<pre>
public Foo foo;
</pre>

<h3><a name="InstanceMode" id="InstanceMode">インスタンス管理</a></h3>
<p><a href="#componentTag">componentタグ</a>のinstance属性で、
コンポーネントのインスタンスをどのように管理するのかを指定します。
</p>
<table width="744" border="1">
<tr bgcolor="#D1F3F4" align="center">
<th width="104" scope="col">instance属性</th>
<th width="624" scope="col">説明</th>
</tr>
<tr>
<td>singleton(default)</td>
<td>S2Container.getComponent()を何度呼び出しても同じインスタンスが返されます。</td>
</tr>
<tr>
<td>prototype</td>
<td>S2Container.getComponent()を呼び出すたびに新たなインスタンスが返されます。</td>
</tr>
<tr>
<td>request</td>
<td>リクエスト毎に1つのインスタンスが作成されます。
name属性に指定した名前で、コンポーネントがリクエストに格納されます。
requestを利用するためには<a href="#S2ContainerFilter">S2ContainerFilter</a>の設定が必要です。</td>
</tr>
<tr>
<td>session</td>
<td>セッション毎に1つのインスタンスが作成されます。
name属性に指定した名前で、コンポーネントがセッションに格納されます。
sessionを利用するためには<a href="#S2ContainerFilter">S2ContainerFilter</a>の設定が必要です。</td>
</tr>
<tr>
<td>application</td>
<td>Servletを使う場合は､ServletContext毎に1つのインスタンスが作成されます。
name属性に指定した名前で、コンポーネントがServletContextに格納されます。
applicationを利用するためには<a href="#S2ContainerFilter">S2ContainerFilter</a>の設定が必要です。</td>
</tr>
<tr>
<td>outer</td>
<td>コンポーネントのインスタンスは、S2Container外で作成し、Dependency Injectionだけを行います。<a href="#Aop">アスペクト</a>、<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>は適用できません。</td>
</tr>
</table>

<h3><a name="AutoBindingMode" id="AutoBindingMode">自動バインディング</a></h3>
<p><a href="#DIType">DI</a>の指定を省略した場合、
コンポーネント間の依存関係は、型および名前によってS2Containerが自動的に解決します。
<a href="#componentTag">componentタグ</a>のautoBinding属性を指定することで細かく制御することもできます。</p>
<table width="744" border="1">
<tr bgcolor="#D1F3F4" align="center">
<th width="104" scope="col">autoBinding</th>
<th width="624" scope="col">説明</th>
</tr>
<tr>
<td>auto(default)</td>
<td>コンストラクタとプロパティの自動バインディングが適用されます。</td>
</tr>
<tr>
<td>constructor</td>
<td>コンストラクタの自動バインディングが適用されます。</td>
</tr>
<tr>
<td>property</td>
<td>プロパティの自動バインディングが適用されます。</td>
</tr>
<tr>
<td>none</td>
<td>自動バインディンは適用されません。</td>
</tr>
</table>
<br />
<p>コンストラクタの自動バインディングのルールは次の順番で適用されます。</p>
<ul>
<li>コンストラクタ・インジェクションが明示的に指定されている場合、
自動バインディングは適用されません。</li>
<li>引数のないデフォルトコンストラクタが定義されている場合、
自動バインディングは適用されません。</li>
<li>引数の型がすべてインターフェースで最も引数の数の多いコンストラクタを選択され、
その引数の型のコンポーネントが設定されます。</li>
</ul>
<p>プロパティの自動バインディングのルールは次の順番で適用されます。</p>
<ul>
<li>セッター・インジェクションが明示的に指定されている場合、
自動バインディングは適用されません。</li>
<li>プロパティ名と同一のコンポーネントがコンテナに登録されていて、
プロパティに代入可能なら、 そのコンポーネントが設定されます。</li>
<li>プロパティの型を実装したコンポーネントがコンテナに1つ登録されていれば、 そのコンポーネントが設定されます。</li>
</ul>
<p>propertyタグのbindingType属性で、プロパティごとに細かく制御することもできます。</p>
<table width="744" border="1">
<tr bgcolor="#D1F3F4" align="center">
<th width="104" scope="col">bindingType</th>
<th width="624" scope="col">説明</th>
</tr>
<tr>
<td>must</td>
<td>自動バインディングが適用されない場合､例外が発生します。</td>
</tr>
<tr>
<td>should(default)</td>
<td>自動バインディングが適用されない場合､警告を通知します。</td>
</tr>
<tr>
<td>may</td>
<td>自動バインディングが適用されない場合､何もおきません。</td>
</tr>
<tr>
<td>none</td>
<td>自動バインディングは適用されません。</td>
</tr>
</table>
<br />

<h3><a name="S2ContainerLifecycle" id="S2ContainerLifecycle">S2Containerのライフサイクル</a></h3>
<p>Webアプリケーションの場合、<a href="#S2ContainerServlet">S2ContainerServlet</a>の初期化時にS2Container.init()が呼び出され、
S2ContainerServletの終了時にS2Container.destroy()が呼び出されます。</p>
<p>S2Container.init()が呼び出されたときに、シングルトンのコンポーネントは初期化され、
S2Container.destroy()が呼び出されたときに、シングルトンのコンポーネントは破棄されることになります。</p>
<p>Webアプリケーション以外の場合、明示的にS2Container.init()、
S2Container.destroy()を呼び出す必要があります。</p>

<h3><a name="ComponentLifecycle" id="ComponentLifecycle">コンポーネントのライフサイクル</a></h3>
<p>コンポーネントを初期化するメソッドを<a href="#initMethodTag">initMethodタグ</a>で指定できます。
シングルトンのコンポーネントはS2Container.init()時に初期化されますが、
それ以外のコンポーネントは取得されるときに初期化が行なわれます。</p>
<p>コンポーネントを破棄するメソッドを<a href="#destroyMethodTag">destroyMethodタグ</a>で指定できます。
シングルトンのコンポーネントはS2Container.destroy()時に破棄されます。
それ以外のコンポーネントはdestroyMethodを指定しても無視されます。</p>
<p>initMethodはコンポーネントがコンテナに登録した順番に実行され、
destroyMethodはその逆順に呼び出されることになります。</p>
<p>HashMapを使ったサンプルは、次のようになります。</p>
<pre>
&lt;components&gt;
    &lt;component class="java.util.HashMap"&gt;
        &lt;initMethod name="put"&gt;
            &lt;arg&gt;"aaa"&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;destroyMethod name="remvoe"&gt;
            &lt;arg&gt;"aaa"&lt;/arg&gt;
        &lt;/destroyMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h3><a name="Env" id="Env">環境名</a></h3>
<p>環境名とは実行環境を表現する名前で、<code>env.txt</code>というテキストファイルによって指定します。
この<code>env.txt</code>ファイルはクラスパス上に配置します。
Webアプリケーションでは<code>WEB-INF/classes</code>になります。
いくつかの機能で、環境名によって処理をカスタマイズすることができます。
この機能はSeasar2.4以上が必要です。</p>
<p>標準的な名称は次のようになります。</p>
<ul>
<li><code>ut</code><br />
単体テスト環境を表します。</li>
<li><code>ct</code><br />
結合テスト環境を表します。</li>
<li><code>it</code><br />
統合テスト環境を表します。</li>
<li><code>product</code><br />
運用環境を表します。<code>env.txt</code>ファイルが存在しない場合のデフォルトです。</li>
</ul>

<h3><a name="Include" id="Include">定義ファイルのインクルード</a></h3>
<p>定義ファイルに別の定義ファイルをインクルードすることができます。</p>
<pre>
&lt;components&gt;
    &lt;include path="bar.dicon"/&gt;
&lt;/components&gt;
</pre>
<p><a href="#includeTag">includeタグ</a>のpath属性で定義ファイルのパスを指定します。<br />
コンポーネントを探す場合、最初に自分自身に登録されているコンポーネントを探し、
見つからない場合は、インクルードいる順に子供の定義ファイルを検索し、
最初に見つかったコンポーネントが対象になります。</p>

<h3><a name="ConditionalInclude" id="ConditionalInclude">定義ファイルの条件インクルード</a></h3>
<p>一つのアプリケーションで利用されるdiconファイルであっても、
状況によって異なった設定が必要になることがあります。
RDBMSの接続情報などは、<a href="#Env">環境</a>によって変える必要があることがほとんどです、</p>
<p>このような場合に、diconファイルの記述を変更することなく、
環境に応じた設定をするための機能が条件インクルードです。
条件インクルードでは、環境ごとに必要な設定を記述したdiconファイルをインクルードすることができます。</p>
<p>条件インクルードは環境別のdiconファイルをインクルードするために、2つの方法を提供します。</p>
<ul>
<li>暗黙的な条件インクルード<br />
<code>include</code>タグの<code>path</code>属性で指定されたdicon名に、
環境名(環境を表す名前)をサフィックスとして持つdiconがあればそれをインクルードする機能です。</li>
<li>明示的な条件インクルード<br />
OGNL式によって指定した条件が真となる場合のみdiconをインクルードする機能です。</li>
</ul>
<h4><a name="ImplicitConditionalInclude" id="ImplicitConditionalInclude">暗黙的な条件インクルード</a></h4>
<p>暗黙的な条件インクルードとは、<code>include</code>タグの<code>path</code>属性で指定されたdicon名に、
環境名をサフィックスとして持つdiconがあればそれをインクルードする機能です。</p>
<p>暗黙的な条件インクルードを使う場合，インクルードする側のdiconは通常通り記述します．</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&lt;
&lt;!DOCTYPE components PUBLIC <strong>"-//SEASAR//DTD S2Container 2.4//EN"</strong>
    <strong>"http://www.seasar.org/dtd/components24.dtd"</strong>&gt;
&lt;components&gt;
    <strong>&lt;include path="foo.dicon"/&gt;</strong>
&lt;/components&gt;
</pre>
<p>インクルードされる側のdiconは、拡張子を除いたファイル名の最後にサフィックスを付加します。
サフィックスは，アンダースコアと環境名をつなげたものです。</p>
<ul>
<li><code>foo_ut.dicon</code><br />
環境名が<code>ut</code>の場合にインクルードされます。</li>
<li><code>foo_ct.dicon</code><br />
環境名が<code>ct</code>の場合にインクルードされます。</li>
<li><code>foo.dicon</code><br />
環境名が<code>ut</code>でも<code>ct</code>でもない場合にインクルードされます。</li>
</ul>
<h4><a name="ExplicitConditionalInclude" id="ExplicitConditionalInclude">明示的な条件インクルード</a></h4>
<p>より複雑な状況でインクルードするdiconを切り替えたい場合には、
<code>include</code>タグの<code>condition</code>属性でインクルードする条件をOGNL式で明示的に指定することができます。
この場合には、指定された条件が満たされた場合のみ、指定されたdiconがインクルードされます。</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC <strong>"-//SEASAR//DTD S2Container 2.4//EN"</strong>
    <strong>"http://www.seasar.org/dtd/components24.dtd"</strong>
&gt;
&lt;components&gt;
    <strong>&lt;include condition="#ENV == 'ct'" path="hotdeploy.dicon"/&gt;</strong>
    <strong>&lt;include condition="#ENV != 'ct'" path="cooldeploy.dicon"/&gt;</strong>
&lt;/components&gt;
</pre>
<p>この例では、<code>#ENV</code>で参照することのできる環境名が<code>'ct'</code>であればhotdeploy.diconを、
それ以外であればcooldeploy.diconをインクルードします。</p>
<p><code>include</code>タグの<code>condition</code>属性には、
<code>static</code>メソッドの呼び出しを含む任意のOGNL式を記述することができます。
OGNL式については「<a href="ognl.html">OGNLガイド</a>」を参照してください。</p>
<p>条件インクルードはSeasar2.4以上が必要です。</p>

<h3><a name="XInclude" id="XInclude">設定ファイルの埋め込みインクルード(XInclude)</a></h2>
<p><a href="http://www.w3.org/TR/xinclude/">XInclude (XML Inclusion)</a> は、
複数の XML ドキュメントを一つの XML ドキュメントに統合するための仕様です。
Seasar2.4 で導入された XInclude のサポートにより、複数の dicon ファイルを一つの dicon ファイルのように扱うことが可能になります。</p>
<h4>前提条件</h4>
<p>XInclude を利用するには、Java5 以降でかつXInclude に対応した XML パーサが必要です。
Java5 にバンドルされているXML パーサは XInclude に対応しています。</p>
<p>Teeda、S2JSF、Mayaa 等にバンドルされている Xerces 2.6.2 は XInclude に対応していません。
Xerces 2.6.2 は Tomcat 5.0 でも利用されています。
これらの環境で XInclude を使用するには次の設定が必要です．</p>
<ul>
<li><code>META-INF/services</code>ディレクトリを作成し、
<code>javax.xml.parsers.SAXParserFactory</code> というファイルを作成し、
以下の内容を記述します (SunのJDK/JREの場合)。
</ul>
<pre>com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl</pre>
<h4>XInclude の使い方</h4>
<p>XInclude を使って他の dicon ファイルを取り込むには、次のように記述します。</p>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC <strong>"-//SEASAR//DTD S2Container 2.4//EN"</strong>
    <strong>"http://www.seasar.org/dtd/components24.dtd"</strong>
&gt;
&lt;components
    <strong>xmlns:xi="http://www.w3.org/2001/XInclude"</strong>
&gt;
    <strong>&lt;xi:include href="/foo.dicon"/&gt;</strong>
    <strong>&lt;xi:include href="/bar.dicon"/&gt;</strong>
&lt;/components&gt;
</pre>
<ul>
<li>文書型宣言で Seasar2.4 の DTD を指定します。</li>
<li><code>components</code>タグで XInclude の名前空間を宣言します。</li>
<li><code>components</code>の子タグに <code>xi:include</code> タグを記述します。
<code>href</code> 属性で取り込む dicon ファイルのパスを指定します。
<strong>パスの先頭は必ずスラッシュ ('/') にしてください．</strong></li>
</ul>
<p>これにより、<code>foo.dicon</code> と <code>bar.dicon</code> の内容 (<code>components</code> 子タグ) が取り込まれます。
<code>xi:include</code> 要素は <code>component</code> タグと混在して記述することができます。</p>
<p><code>foo.dicon</code> と <code>bar.dicon</code> が次の内容だった場合</p>
<h4><code>foo.dicon</code></h4>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.4//EN"
    "http://www.seasar.org/dtd/components24.dtd"&gt;
&lt;components&gt;
    &lt;component name="foo1"&gt;"Foo1"&lt;/component&gt;
    &lt;component name="foo2"&gt;"Foo2"&lt;/component&gt;
&lt;/components&gt;
</pre>
<h4><code>bar.dicon</code></h4>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.4//EN"
    "http://www.seasar.org/dtd/components24.dtd"&gt;
&lt;components&gt;
    &lt;component name="bar1"&gt;"Bar1"&lt;/component&gt;
    &lt;component name="bar2"&gt;"Bar2"&lt;/component&gt;
&lt;/components&gt;
</pre>
<p>最初に示したdicon は次のように記述した場合と同じになります。</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.4//EN"
    "http://www.seasar.org/dtd/components24.dtd"
&gt;
&lt;components
    xmlns:xi="http://www.w3.org/2001/XInclude"
&gt;
    &lt;component name="foo1"&gt;"Foo1"&lt;/component&gt;
    &lt;component name="foo2"&gt;"Foo2"&lt;/component&gt;
    &lt;component name="bar1"&gt;"Bar1"&lt;/component&gt;
    &lt;component name="bar2"&gt;"Bar2"&lt;/component&gt;
&lt;/components&gt;
</pre>
<h4><code>include</code>タグとの違い</h4>
<p>&lt;include&gt;タグと XInclude (&lt;xi:include&gt;) は一見似ているようですが、実際には大きく異なります。</p>
<p>次のように &lt;include&gt; を利用すると、それぞれの dicon ファイルを読み込んだ S2Containerが合計 3 つインスタンス化されます。</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.4//EN"
    "http://www.seasar.org/dtd/components24.dtd"
&gt;
&lt;components
    xmlns:xi="http://www.w3.org/2001/XInclude"
&gt;
    <strong>&lt;include path="foo.dicon"/&gt;</strong>
    <strong>&lt;include path="bar.dicon"/&gt;</strong>
&lt;/components&gt;
</pre>
<p>親となる dicon に定義されたコンポーネントからは <code>foo.dicon</code> と <code>bar.dicon</code> に定義されたコンポーネントが見えます (DI の対象となる)が、
<code>foo.dicon</code> に定義されたコンポーネントからは 親の dicon に定義されたコンポーネントも <code>bar.dicon</code> に定義されたコンポーネントも見えません (DI の対象とならない)。
<code>bar.dicon</code> に定義されたコンポーネントも 親の dicon に定義されたコンポーネントや <code>foo.dicon</code> に定義されたコンポーネントが見えません (DI の対象とならない)。</p>
<p>一方，XInclude を利用した場合には，親のdiconも，<code>foo.dicon</code> および <code>bar.dicon</code> も一つの S2 コンテナに読み込まれるため、
どこの dicon に定義したコンポーネントからであっても他の dicon に定義されたコンポーネントが見えます (DI の対象となる)。</p>
<p>また、次のようにaaa.diconとbbb.diconから同じjdbc.diconをXIncludeしたとします。</p>
<h5>aaa.dicon</h5>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.4//EN"
    "http://www.seasar.org/dtd/components24.dtd"
&gt;
&lt;components
    xmlns:xi="http://www.w3.org/2001/XInclude"
&gt;
    <strong>&lt;xi:include path="jdbc.dicon"/&gt;</strong>
&lt;/components&gt;
</pre>
<h5>bbb.dicon</h5>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.4//EN"
    "http://www.seasar.org/dtd/components24.dtd"
&gt;
&lt;components
    xmlns:xi="http://www.w3.org/2001/XInclude"
&gt;
    <strong>&lt;xi:include path="jdbc.dicon"/&gt;</strong>
&lt;/components&gt;
</pre>
<p>この場合、jdbc.diconの中身は、aaa.diconとbbb.diconに物理的に別のものとしてコピーされます。
一方、includeタグを使った場合は、aaa.diconとbbb.diconに取り込まれたjdbc.diconは同じものをさしています。
</p>
<p>XIncludeは1つのdiconファイルを物理的に分割する場合に使ってください。</p>

<h3><a name="Namespace" id="Namespace">名前空間</a></h3>
<p>定義ファイルを分割した場合に、複数の定義ファイルで名前が衝突しないように、
<a href="#componentsTag">componentsタグ</a>のnamespace属性で名前空間を指定することができます。</p>
<h5>foo.dicon</h5>
<pre>
&lt;components namespace="foo"&gt;
    &lt;component name="aaa" .../&gt;
    &lt;component name="bbb" ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>
<h5>bar.dicon</h5>
<pre>
&lt;components namespace="bar"&gt;
    &lt;include path="foo.dicon"/&gt;
    &lt;component name="aaa" .../&gt;
    &lt;component name="bbb" ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
    &lt;component name="ccc" ...&gt;
        &lt;arg&gt;foo.aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>
<h5>app.dicon</h5>
<pre>
&lt;components&gt;
    &lt;include path="bar.dicon"/&gt;
&lt;/components&gt;
</pre>
<p>同じ定義ファイルのコンポーネントは名前空間なしで参照できます。
他の定義ファイルのコンポーネントを参照する場合は、名前空間.をコンポーネント名の頭につけます。
foo.aaaとbar.aaaは同じ名前がついていますが、名前空間が異なっているので、違うコンポーネントになります。</p>

<h3><a name="S2ContainerFilter" id="S2ContainerFilter">S2ContainerFilter</a></h3>
<p>request、session、applicationで<a href="#InstanceMode">インスタンス管理</a>をしたい場合、
S2ContainerFilterをweb.xmlに登録します。</p>
<pre>
&lt;web-app&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;s2filter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.seasar.framework.container.filter.S2ContainerFilter&lt;/filter-class&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;s2filter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</pre>

<h3><a name="ImplicitComponent" id="ImplicitComponent">暗黙的なコンポーネント</a></h3>
<p>定義ファイルに記述しなくても暗黙的に使えるコンポーネントが存在します。
これらのコンポーネントは、次のようにプロパティを定義しておけば自動的にDIされます。</p>
<pre>
S2Container container;

HttpServletRequest request;

HttpServletResponse response;

HttpServlet servlet;

ServletContext application;

//ServletContextの属性にMapインターフェースでアクセスできます。
Map applicationScope;

//ServletContextの初期化パラメータにMapインターフェースでアクセスできます。
Map initParam;

//HttpSessionの属性にMapインターフェースでアクセスできます。
Map sessionScope;

//HttpServletRequestの属性にMapインターフェースでアクセスできます。
Map requestScope;

//Cookieの属性にMapインターフェースでアクセスできます。
Map cookie;

//HttpServletRequestのheaderにMapインターフェースでアクセスできます。戻り値はStringです。
Map header;

//HttpServletRequestのheaderにMapインターフェースでアクセスできます。戻り値はStringの配列です。
Map headerValues;

//HttpServletRequestのパラメータにMapインターフェースでアクセスできます。戻り値はStringです。
Map param;

//HttpServletRequestのパラメータにMapインターフェースでアクセスできます。戻り値はStringの配列です。
Map paramValues;
</pre>
<p>containerはコンポーネント自身が登録されているS2Containerになります。
ルートのS2Containerはcontainer.getRoot()で取得します。</p>
<p>container以外のコンポーネントを使うには<a href="#S2ContainerFilter">S2ContainerFilter</a>が必要です。</p>

<h3><a name="Aop" id="Aop">AOPの適用</a></h3>
<p>コンポーネントに<a href="aop.html#Aspect">アスペクト</a>を適用することもできます。
詳しい説明は、<a href="aop.html">S2AOP</a>を参照してください。</p>

<h3><a name="Meta" id="Meta">メタデータ</a></h3>
<p>components、component、arg、propertyタグにメタデータを指定することもできます。metaタグはメタデータを指定したいタグの子タグに指定します。例えば、componentsタグにメタデータを指定したい場合次のようにします。</p>
<pre>
&lt;components&gt;
    &lt;meta name="aaa"&gt;111&lt;/meta&gt;
&lt;/components&gt;
</pre>

<h3><a name="ComponentAutoRegister" id="ComponentAutoRegister">コンポーネントの自動登録</a></h3>
<p><a href="#AutoBindingMode">自動バインディング</a>により、DIの設定はほぼ自動化できます。 
さらに、コンポーネントの登録も自動化してしまおうというのが、コンポーネントの自動登録機能です。</p>
<h5><a name="FileSystemComponentAutoRegister" id="FileSystemComponentAutoRegister">org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister</a></h5>
<p>ファイルシステムからクラスを検索としてコンポーネントを自動登録するコンポーネントです。</p>
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>自動登録されるコンポーネントに適用するInstanceDefを指定します。XMLで指定する場合､<br />
<code>@org.seasar.framework.container.deployer.InstanceDefFactory@REQUEST</code><br />
のように指定します。</td>
</tr>
<tr>
<td><code>autoBindingDef</code></td>
<td>自動登録されるコンポーネントに適用するAutoBindingDefを指定します。XMLで指定する場合､<br />
<code>@org.seasar.framework.container.assembler.AutoBindingDefFactory@NONE</code><br />
のように指定します。</td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>クラス名からコンポーネント名を自動的に決定するコンポーネント。org.seasar.framework.container.autoregister.AutoNamingインターフェースを実装している必要があります。デフォルトは､org.seasar.framework.container.autoregister.DefaultAutoNamingクラスのインスタンスになります。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<h5><a name="JarComponentAutoRegister" id="JarComponentAutoRegister">org.seasar.framework.container.autoregister.JarComponentAutoRegister</a></h5>
<p>Jarファイルの中からクラスを検索としてコンポーネントを自動登録するコンポーネントです。</p>
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>jarFileNames</code></td>
<td>対象のjarファイル名を指定します。正規表現も使えます。ただし､拡張子は含まれません。複数指定する場合は､「,」で区切ります。例えば､myapp.*, yourapp.*のようになります。</td>
</tr>
<tr>
<td><code>referenceClass</code></td>
<td>このプロパティで指定されたクラスが存在するjarファイルの親ディレクトリをベースのディレクトリ(例えば、WEB-INF/lib)とみなします。デフォルトは、org.aopalliance.intercept.MethodInterceptor.classになります。</td>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>自動登録されるコンポーネントに適用するInstanceDefを指定します。XMLで指定する場合､<br />
<code>@org.seasar.framework.container.deployer.InstanceDefFactory@REQUEST</code><br />
のように指定します。</td>
</tr>
<tr>
<td><code>autoBindingDef</code></td>
<td>自動登録されるコンポーネントに適用するAutoBindingDefを指定します。XMLで指定する場合､<br />
<code>@org.seasar.framework.container.assembler.AutoBindingDefFactory@NONE</code><br />
のように指定します。</td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>クラス名からコンポーネント名を自動的に決定するコンポーネント。org.seasar.framework.container.autoregister.AutoNamingインターフェースを実装している必要があります。デフォルトは､org.seasar.framework.container.autoregister.DefaultAutoNamingクラスのインスタンスになります。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<h5><a name="aComponentAutoRegister" id="aComponentAutoRegister">org.seasar.framework.container.autoregister.ComponentAutoRegister</a></h5>
<p>ファイルシステムまたはJarファイルからクラスを検索としてコンポーネントを自動登録するコンポーネントです。</p>
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>自動登録されるコンポーネントに適用するInstanceDefを指定します。XMLで指定する場合､@org.seasar.framework.container.deployer.InstanceDefFactory@REQUESTのように指定します。</td>
</tr>
<tr>
<td><code>autoBindingDef</code></td>
<td>自動登録されるコンポーネントに適用するAutoBindingDefを指定します。XMLで指定する場合､<br />
<code>@org.seasar.framework.container.assembler.AutoBindingDefFactory@NONE</code><br />
のように指定します。</td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>クラス名からコンポーネント名を自動的に決定するコンポーネント。org.seasar.framework.container.autoregister.AutoNamingインターフェースを実装している必要があります。デフォルトは､org.seasar.framework.container.autoregister.DefaultAutoNamingクラスのインスタンスになります。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addReferenceClass</code></td>
<td>このメソッドで指定されたクラスが存在するディレクトリまたはJarファイルを基点としてクラスを検索します。</td>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<br />
<h4>AutoNaming</h4>
<p>AutoNamingによってコンポーネントに自動的に名前をつけることができます。</p>
<h5><a name="DefaultAutoNaming" id="DefaultAutoNaming">org.seasar.framework.container.autoregister.DefaultAutoNaming</a></h5>
<p>クラスの完全修飾名からパッケージ部分を除き、最後がImplまたはBeanで終わっていたら削除し､ 先頭を小文字にした名前をコンポーネントの名前に設定します。 例えば､aaa.HogeImplクラスの場合､コンポーネント名は､hogeになります。</p>
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>decapitalize</code></td>
<td>コンポーネント名の先頭を小文字にする場合はtrueを指定します。デフォルトはtrueです。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>setCustomizedName</code></td>
<td>デフォルトのルールに従わないクラスを登録します。最初の引数は､クラスの完全修飾名です。 2番目の引数は､コンポーネント名です。</td>
</tr>
<tr>
<td><code>addIgnoreClassSuffix</code></td>
<td>クラス名の末尾から削除する部分を指定します。デフォルトでImplおよびBeanが登録されています。</td>
</tr>
<tr>
<td><code>addReplaceRule</code></td>
<td>正規表現による置換ルールを追加します。最初の引数は正規表現です。2番目の引数は置換文字列です。</td>
</tr>
<tr>
<td><code>clearReplaceRule</code></td>
<td>setCustomizedName、addIgnoreClassSuffix、addReplaceRuleで登録した変換規則をクリアします。デフォルトで登録されているImplおよびBeanもクリアされます。</td>
</tr>
</table>
<h5><a name="QualifiedAutoNaming" id="QualifiedAutoNaming">org.seasar.framework.container.autoregister.QualifiedAutoNaming</a></h5>
<p>パッケージ名またはその一部で修飾されたクラス名をコンポーネントの名前に設定します。 クラスの完全修飾名から最後がImplまたはBeanで終わっていたら削除し､ 先頭を小文字、ピリオドの直後を大文字にした名前をコンポーネントの名前に設定します。<br />
パッケージの先頭部分から不要な部分を削除することができます。<br />
例えば､aaa.bbb.ccc.ddd.HogeImplクラスの場合で､先頭のaaa.bbbを削除するように指定した場合のコンポーネント名は､cccDddHogeになります。</p>
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>decapitalize</code></td>
<td>コンポーネント名の先頭を小文字にする場合はtrueを指定します。デフォルトはtrueです。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>setCustomizedName</code></td>
<td>デフォルトのルールに従わないクラスを登録します。最初の引数は､クラスの完全修飾名です。 2番目の引数は､コンポーネント名です。</td>
</tr>
<tr>
<td><code>addIgnorePackagePrefix</code></td>
<td>パッケージ名の先頭から削除する部分を指定します。</td>
</tr>
<tr>
<td><code>addIgnoreClassSuffix</code></td>
<td>クラス名の末尾から削除する部分を指定します。デフォルトでImplおよびBeanが登録されています。</td>
</tr>
<tr>
<td><code>addReplaceRule</code></td>
<td>正規表現による置換ルールを追加します。最初の引数は正規表現です。2番目の引数は置換文字列です。</td>
</tr>
<tr>
<td><code>clearReplaceRule</code></td>
<td>setCustomizedName、 addIgnorePackagePrefix、 addIgnoreClassSuffix、 addReplaceRuleで登録した変換規則をクリアします。デフォルトで登録されているImplおよびBeanもクリアされます。</td>
</tr>
</table>
<h5>例</h5>
<pre>
&lt;component
  class="org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister"&gt;
    &lt;property name="autoNaming"&gt;
        &lt;component class="org.seasar.framework.container.autoregister.DefaultAutoNaming"&gt;
            &lt;initMethod name="setCustomizedName"&gt;
                &lt;arg&gt;"examples.di.impl.HogeImpl"&lt;/arg&gt;
                &lt;arg&gt;"hoge2"&lt;/arg&gt;
            &lt;/initMethod&gt;
        &lt;/component&gt;
    &lt;/property&gt;
    &lt;initMethod name="addClassPattern"&gt;
        &lt;arg&gt;"examples.di.impl"&lt;/arg&gt;
        &lt;arg&gt;".*Impl"&lt;/arg&gt;
    &lt;/initMethod&gt;
&lt;/component&gt;
</pre>
<pre>
&lt;component class="org.seasar.framework.container.autoregister.JarComponentAutoRegister"&gt;
    &lt;property name="referenceClass"&gt;
        @junit.framework.TestSuite@class
    &lt;/property&gt;
    &lt;property name="jarFileNames"&gt;"junit.*"&lt;/property&gt;
    &lt;initMethod name="addClassPattern"&gt;
        &lt;arg&gt;"junit.framework"&lt;/arg&gt;
        &lt;arg&gt;"TestSuite"&lt;/arg&gt;
    &lt;/initMethod&gt;
&lt;/component&gt;
</pre>
<pre>
&lt;component class="org.seasar.framework.container.autoregister.ComponentAutoRegister"&gt;
    &lt;initMethod name="addReferenceClass"&gt;
        &lt;arg&gt;@aaa.bbb.ccc.ddd.HogeImpl@class&lt;/arg&gt;
    &lt;/initMethod&gt;
    &lt;initMethod name="addClassPattern"&gt;
        &lt;arg&gt;"aaa.bbb"&lt;/arg&gt;
        &lt;arg&gt;".*Impl"&lt;/arg&gt;
    &lt;/initMethod&gt;
&lt;/component&gt;
</pre>
<h3><a name="AspectAutoRegister" id="AspectAutoRegister">アスペクトの自動登録</a></h3>
<p><a href="#ComponentAutoRegister">コンポーネントの自動登録</a>により、コンポーネントの登録は自動化できます。 
さらに、アスペクトの登録も自動化してしまおうというのが、アスペクトの自動登録機能です。
アスペクトについては、<a href="#aspectTag">aspectタグ</a>を参照してください。</p>
<p>コンポーネントの自動登録と組み合わせる場合は､コンポーネントの自動登録の設定よりも後に、アスペクトの自動登録の設定を記述する必要があります。 アスペクトを適用されるコンポーネントは、アスペクトの自動登録の設定よりも後に記述する必要があります。</p>
<pre>
&lt;components&gt;
    &lt;!-- 1.コンポーネントの自動登録 --&gt;
    &lt;component class="org.seasar.framework.container.autoregister.ComponentAutoRegister"&gt;
        ...
    &lt;/component&gt;

    &lt;!-- 2.アスペクトの自動登録 --&gt;
    &lt;component class="org.seasar.framework.container.autoregister.AspectAutoRegister"&gt;
        ...
    &lt;/component&gt;

    &lt;!-- 3.その他のコンポーネント --&gt;
    &lt;component class="..."&gt;
        ...
    &lt;/component&gt;
    ...
&lt;components&gt;
</pre>
<h5>org.seasar.framework.container.autoregister.AspectAutoRegister</h5>
<p>クラス名のパターンを指定してアスペクトを自動登録するコンポーネントです。</p>
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>interceptor</code></td>
<td>インターセプタを指定します。複数のインターセプタを指定したい場合は､<a href="aop.html#InterceptorChain">InterceptorChain</a>を使ってください。</td>
</tr>
<tr>
<td><code>pointcut</code></td>
<td>インターセプタを適用するメソッドをカンマ区切りで指定します。pointcutを指定しない場合は、コンポーネントが実装しているインターフェースのすべてのメソッドが対象になります。メソッド名には正規表現(JDK1.4のregex)も使えます。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<br />
<h5>例</h5>
<pre>
&lt;include path="aop.dicon"/&gt;
...
&lt;component<br />  class="org.seasar.framework.container.autoregister.AspectAutoRegister"&gt;<br />    &lt;property name="interceptor"&gt;aop.traceInterceptor&lt;/property&gt;<br />    &lt;initMethod name="addClassPattern"&gt;<br />        &lt;arg&gt;"examples.di.impl"&lt;/arg&gt;<br />        &lt;arg&gt;".*Impl"&lt;/arg&gt;<br />    &lt;/initMethod&gt;<br />&lt;/component&gt;
</pre>
<h5><a name="InterfaceAspectAutoRegister" id="InterfaceAspectAutoRegister">org.seasar.framework.container.autoregister.InterfaceAspectAutoRegister</a></h5>
<p>あるインタフェースを実装したクラスに対してアスペクトを自動登録するコンポーネントです。</p>
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>interceptor</code></td>
<td>インターセプタを指定します。複数のインターセプタを指定したい場合は､<a href="aop.html#InterceptorChain">InterceptorChain</a>を使ってください。</td>
</tr>
<tr>
<td><code>targetInterface</code></td>
<td>指定したインターフェースを実装しているコンポーネントに対して､アスペクトを適用します。</td>
</tr>
</table>
<h5>例</h5>
<pre>
&lt;include path="aop.dicon"/&gt;
...
&lt;component<br />  class="org.seasar.framework.container.autoregister.InterfaceAspectAutoRegister"&gt;<br />    &lt;property name="interceptor"&gt;aop.traceInterceptor&lt;/property&gt;
    &lt;property name="targetInterface"&gt;@examples.Greeing@class&lt;/property&gt;<br />&lt;/component&gt;
</pre>
<h3><a name="MetaAutoRegister" id="MetaAutoRegister">メタデータの自動登録</a></h3>
<p>メタデータも自動登録することができます。</p>
<p>コンポーネントの自動登録と組み合わせる場合は､コンポーネントの自動登録の設定よりも後に、メタデータの自動登録の設定を記述する必要があります。 メタデータを参照するコンポーネントは、メタデータの自動登録の設定よりも後に記述する必要があります。</p>
<pre>
&lt;components&gt;
    &lt;!-- 1.コンポーネントの自動登録 --&gt;
    &lt;component class="org.seasar.framework.container.autoregister.ComponentAutoRegister"&gt;
        ...
    &lt;/component&gt;

    &lt;!-- 2.メタデータの自動登録 --&gt;
    &lt;component class="org.seasar.framework.container.autoregister.MetaAutoRegister"&gt;
        ...
    &lt;/component&gt;

    &lt;!-- 3.その他のコンポーネント --&gt;
    &lt;component class="..."&gt;
        ...
    &lt;/component&gt;
    ...
&lt;components&gt;
</pre>
<h5>org.seasar.framework.container.autoregister.MetaAutoRegister</h5>
<p>クラス名のパターンを指定してメタデータを自動登録するコンポーネントです。<br />
自動登録されるメタデータは、このコンポーネント自身の定義にautoRegisterという名前を持つメタデータの子として記述します。</p>
<table border="1">
<tr bgcolor="#D1F3F4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<h5>例</h5>
<pre>
&lt;component
  class="org.seasar.framework.container.autoregister.MetaAutoRegister"&gt;
    &lt;meta name="autoRegister"&gt;
        &lt;meta name="hoge"&lt;/meta&gt;
    &lt;/meta&gt;
    &lt;initMethod name="addClassPattern"&gt;
        &lt;arg&gt;"examples.di.impl"&lt;/arg&gt;
        &lt;arg&gt;".*Impl"&lt;/arg&gt;
    &lt;/initMethod&gt;
&lt;/component&gt;
</pre>
<p>この例では、hogeという名前のメタデータが他のコンポーネント定義に自動登録されます。</p>

<h3><a name="SMARTdeploy" id="SMARTdeploy">SMART deploy</a></h3>
<p><a href="#ComponentAutoRegister">コンポーネントの自動登録</a>、
<a href="#AspectAutoRegister">アスペクトの自動登録</a>によりほとんど定義ファイルを書く必要はなくなりました。
しかし、コンポーネントのソースコードを書き換えるたびにアプリケーションサーバを再起動しなければならないという問題は、
まだ解決されていません。
</p>
<p>
この問題を解決するために開発されたのが、Seasar2.4から登場したHOT deploy機能です。
HOT deployを使うと、アプリケーションサーバを起動したままで、
ソースコードの修正が即座に反映されるので、「さくさく感のある開発」が可能になります。
</p>
<p>
開発時には便利なHOT deployですが、若干のオーバーヘッドがあり、
運用時には有効な機能だとはいえません。
運用時には、パフォーマンスや安定性が求められるでしょう。
このために用意されているのが、COOL deployです。
COOL deployを使うと、アプリケーションの起動時にすべてのデプロイを行い、
クラスのタイムスタンプチェックなどは一切行なわないので、
オーバヘッドなしで本来のパフォーマンスを発揮できます。
</p>
<p>
HOT deployとCOOL deployの中間に位置するのがWARM deployです。
JUnitなどでテストをすることを思い浮かべてください。
テストを実行しているときに、ソースコードを修正することはないので、
HOT deployの機能は不要です。
しかし、COOL deployのようにすべてのデプロイが、テストメソッドごとに行なわれると、
テストの時間が無駄に長くなってしまいます。
必要なコンポーネントだけがデプロイされるのが望ましいでしょう。
このように必要なコンポーネントだけがデプロイされ、
修正を即座に認識しないのがWARM deployの機能です。
</p>
<p>HOT deploy、COOL deploy、WARM deployをあわせてSMART deployと呼びます。</p>

<h4><a name="SMARTdeployS2ContainerDicon" id="SMARTdeployS2ContainerDicon">SMART deployの切り替え</a></h4>
<p>
SMART deployの切り替えは、<a href="#Env">環境名</a>を変えるだけでOKです。
例えば、次のようにs2container.diconが設定されている場合、
utのときにはWARM deploy、ctのときはHOT deploy、それ以外はCOOL deployになります。
</p>
<pre>
&lt;components&gt;
    &lt;include condition="#ENV == 'ut'" path="warmdeploy.dicon"/&gt;
    &lt;include condition="#ENV == 'ct'" path="hotdeploy.dicon"/&gt;
    &lt;include condition="#ENV != 'ut' and #ENV != 'ct'" path="cooldeploy.dicon"/&gt;
&lt;/components&gt;
</pre>
<p>s2container.diconはS2Containerをカスタマイズするための定義ファイルです。
クラスパスの通っているディレクトリにおいておくだけでS2Containerが自動認識します。
通常は、WEB-INF/classesに配置します。
</p>

<h4><a name="SMARTdeployPackage" id="SMARTdeployPackage">SMART deployのPackage構成</a></h4>
<p>SMART deployで推奨しているパッケージ構成は次のようになります。</p>
<dl>
<dd>examples.aaa</dd>
<dd>examples.aaa.web.xxx</dd>
<dd>examples.aaa.web.yyy</dd>
<dd>examples.aaa.entity</dd>
<dd>examples.aaa.dao</dd>
<dd>examples.aaa.dto</dd>
<dd>examples.aaa.service</dd>
<dd>examples.aaa.util</dd>
<dd>examples.aaa.helper</dd>
<dd>examples.aaa.interceptor</dd>
<dd>examples.aaa.converter</dd>
<dd>examples.aaa.validator</dd>
</dl>
<p>examples.aaaを<a name="rootPackage">ルートパッケージ</a>と呼びます。
ルートパッケージの配下に役割に応じてパッケージを配置します。</p>
<p>examples.aaa.web.xxx、examples.aaa.web.yyyを<a name="subApplicationPackage">サブアプリケーションパッケージ</a>と呼びます。
xxx、yyyがサブアプリケーション名になります。
サブアプリケーションはユースケースと置き換えても良いでしょう。
複数の関連のある画面を1つにまとめたものがサブアプリケーションです。
典型的なWebアプリケーションは、一覧画面、編集画面、確認画面でサブアプリケーションが構成されます。</p>
<p>サブアプリケーションパッケージに格納するのは、ユースケース固有のクラスです。
HTMLと一対一に結びつくPageクラスやPageクラスとDTOの変換を行なうDxoクラスが、
サブアプリケーションパッケージに格納する代表的なクラスです。</p>
<p>examples.aaa.entityを<a name="entityPackage">エンティティパッケージ</a>と呼びます。
このパッケージには、テーブルと一対一に対応するEntityクラスを格納します。</p>
<p>examples.aaa.daoを<a name="daoPackage">Daoパッケージ</a>を呼びます。
このパッケージには、Entityと一対一に対応するDaoクラスを格納します。</p>
<p>examples.aaa.dtoを<a name="dtoPackage">Dtoパッケージ</a>を呼びます。
このパッケージには、DTOクラスを格納します。</p>
<p>examples.aaa.serviceを<a name="servicePackage">サービスパッケージ</a>と呼びます。
このパッケージには、複数のサブアプリケーションから共通に使われるユースケースを実装するServiceクラスを格納します。</p>
<p>examples.aaa.utilを<a name="utilPackage">ユーティリティパッケージ</a>と呼びます。
このパッケージには、Utilityクラスを格納します。</p>
<p>examples.aaa.helperを<a name="helperPackage">ヘルパパッケージ</a>と呼びます。
このパッケージにも、Utilityクラスを格納します。
ユーティリティパッケージとの違いは、DIやパラメータが必要なクラスを格納することです。</p>
<p>examples.aaa.interceptorを<a name="interceptorPackage">インタセプタパッケージ</a>を呼びます。
このパッケージには、AOPのモジュールを格納します。</p>
<p>examples.aaa.converterを<a name="converterPackage">コンバータパッケージ</a>を呼びます。
このパッケージには、データ変換を行なうモジュールを格納します。</p>
<p>examples.aaa.validatorを<a name="validatorPackage">バリデータパッケージ</a>を呼びます。
このパッケージには、値の検証用のモジュールを格納します。</p>
<p>entity、daoなどのルートパッケージ直下のパッケージを共通パッケージと呼びます。
複数のサブアプリケーションから共通に使われるクラスを格納します。
DTOクラスなどで特定のサブアプリケーションでしか使わない場合は、
Dtoパッケージではなく、サブアプリケーションパッケージに格納してください。</p>

<h4><a name="Creator">クリエータ</a></h4>
<p>
クリエータとはSMART deployの命名規約に従いコンポーネント定義を作成するコンポーネントの総称です。
クリエータは規約に従いインスタンス属性やコンポーネント名などコンポーネントに必要な情報を決定しコンポーネント定義を作成します。
</p>
<p>
Seasar2にはあらかじめ以下に示すクリエータが用意されています。
これらのクリエータは、それぞれ規約に合致するクラスのコンポーネント定義を作成します。
クリエータはcreator.diconに定義する必要があります。
</p>
<h5>クリエータ一覧</h5>
<table border="1">
<tr nowrap bgcolor="#d1f3f4" align="center">
<th width="200">クリエータのクラスの単純名</th>
<th width="150">コンポーネント化対象とするクラスの名前のサフィックス</th>
<th width="150">作成するコンポーネントのインスタンス属性</th></tr>
<tr><td>ActionCreator</td><td>Action</td><td>request</td></tr>
<tr><td>ConverterCreator</td><td>Converter</td><td>prototype</td></tr>
<tr><td>DaoCreator</td><td>Dao</td><td>prototype</td></tr>
<tr><td>DtoCreator</td><td>Dto</td><td>request</td></tr>
<tr><td>DxoCreator</td><td>Dxl</td><td>singleton</td></tr>
<tr><td>HelperCreator</td><td>Helper</td><td>prototype</td></tr>
<tr><td>InterceptorCreator</td><td>Interceptor</td><td>prototype</td></tr>
<tr><td>LogicCreator</td><td>Logic</td><td>prototype</td></tr>
<tr><td>PageCreator</td><td>Page</td><td>request</td></tr>
<tr><td>ServiceCreator</td><td>Service</td><td>prototype</td></tr>
<tr><td>ValidatorCreator</td><td>Validator</td><td>prototype</td></tr>
</table>
<br />
<p>
クリエータが作成するコンポーネント定義に設定されるインスタンス属性は、あらかじめクリエータごとにデフォルトの値が指定されています。
</p>
<p>
クリエータは、コンポーネント名から対象となるクラスを一定のルールにしたがって見つけます。</p>
<p>例えば、hogeDaoという名前のコンポーネントがある場合、
最初にコンポーネント名のサフィックスを求めます。
サフィックスとはコンポーネント名の後ろから最初に大文字の部分までをさします。
hogeDaoの場合、サフィックスはDaoになります。
次にサフィックスの先頭を小文字(dao)にして、
パッケージ名を組み立てます。
daoの場合は、ルートパッケージ.daoになります。
コンポーネント名の先頭を大文字にしてパッケージ名とつなぎ合わせてクラス名を求めます。
今回の場合は、ルートパッケージ.dao.HogeDaoになります。</p>
<p>
サブアプリケーションパッケージにあるコンポーネントは、
サブアプリケーション_がコンポーネント名のプレフィックスにつきます。
例えば、ルートパッケージ.web.emp.EmpListPageクラスのコンポーネント名は、
emp_empListPageになります。
クラス名の最初はempListPageのように小文字になりますが、
XXaaaPageのように2つ以上大文字が続いている場合は、
大文字のままです。これはJavaBeansの仕様です。
</p>
<br />

<h4><a name="Customizer">カスタマイザ</a></h4>
<p>
カスタマイザとはコンポーネント定義をカスタマイズするコンポーネントの総称です。
クリエータに呼び出されたカスタマイザは自身に定義されたカスタマイズ処理をコンポーネント定義に対し実行します。
カスタマイザの機能の代表例はアスペクト定義（インターセプタ）の追加です。
例えば、サービスのカスタマイザにトレース出力のアスペクト定義を設定すると、サービスのクリエータによって作成されたすべてのコンポーネントにトレース出力のインターセプタが自動で適用されます。
</p>
<p>
S2Containerにはdefault-customizer.diconに定義されたデフォルトカスタマイザとstd-customizer.diconに定義された標準カスタマイザがあらかじめ用意されています。
アプリケーションで定義するカスタマイザはcustomizer.diconに記述してください。
</p>

<h5><a name="DefaultCustomizer">デフォルトカスタマイザ</a></h5>
<p>
デフォルトカスタマイザはクリエータに関連付けられるカスタマイザです。
クリエータがコンポーネント定義を作成したあとにこれらのカスタマイザが呼び出されます。
デフォルトカスタマイザには以下のコンポーネントがあります。
</p>
<table border="1">
<tr nowrap bgcolor="#d1f3f4" align="center">
<th width="200">コンポーネント名</th><th width="400">説明</th></tr>
<tr><td>actionCustomizer</td><td>Action用のカスタマイザ</td></tr>
<tr><td>converterCustomizer</td><td>Converter用のカスタマイザ</td></tr>
<tr><td>daoCustomizer</td><td>Dao用のカスタマイザ</td></tr>
<tr><td>dtoCustomizer</td><td>Dto用のカスタマイザ</td></tr>
<tr><td>dxoCustomizer</td><td>Dxoカスタマイザ</td></tr>
<tr><td>helperCustomizer</td><td>Helper用のカスタマイザ</td></tr>
<tr><td>logicCustomizer</td><td>Logic用のカスタマイザ</td></tr>
<tr><td>interceptorCustomizer</td><td>Interceptor用のカスタマイザ</td></tr>
<tr><td>pageCustomizer</td><td>Page用のカスタマイザ</td></tr>
<tr><td>serviceCustomizer</td><td>Service用のカスタマイザ</td></tr>
<tr><td>validatorCustomizer</td><td>Validator用のカスタマイザ</td></tr>
</table>
<p>

</p>
<p>
これらのコンポーネントの実体は<code>org.seasar.framework.container.customizer.CustomizerChain</code>です。
</p>
<p>
<code>CustomizerChain</code>には任意の数のカスタマイザを設定（チェイン）可能ですが、デフォルトカスタマイザのコンポーネントには何も設定されていません。
したがって、デフォルトカスタマイザはクリエータから呼び出されても何の処理も実行しません。
デフォルトカスタマイザがそのように定義されている理由は、カスタマイザをどのように設定するかはアプリケーション開発者に委ねられているからです。
</p>
<p>
カスタマイザの設定はデフォルトカスタマイザの設定を上書きする形でcustomizer.diconに記述します。
その設定は通常<code>CustomizerChain</code>に任意の標準カスタマイザを追加することで行います。
</p>

<h5><a name="StandardCustomizer">標準カスタマイザ</a></h5>
<p>
標準カスタマイザは標準的に利用されることを想定したコンポーネントです。
標準カスタマイザには以下のコンポーネントがあります。
</p>
<table border="1">
<tr nowrap bgcolor="#d1f3f4" align="center">
<th width="200">コンポーネント名</th><th width="200">関連付けられたインターセプト名</th><th width="300">説明</th></tr>
<tr><td>traceCustomizer</td><td>aop.traceInterceptor</td><td>トレース出力のためのカスタマイザ</td></tr>
<tr><td>simpleTraceCustomizer</td><td>aop.simpleTraceInterceptor</td><td>引数や戻り値を出力しない単純なトレースのためのカスタマイザ</td></tr>
<tr><td>classLoaderAwareTraceCustomizer</td><td>aop.classLoaderAwareTraceInterceptor</td><td>クラスローダーの情報を含めたトレース出力のためのカスタマイザ</td></tr>
<tr><td>syncCustomizer</td><td>aop.syncInterceptor</td><td>同期処理のためのカスタマイザ</td></tr>
<tr><td>traceThrowsCustomizer</td><td>aop.traceThrowsInterceptor</td><td>例外のトレース出力のためのカスタマイザ</td></tr>
<tr><td>toStringCustomizer</td><td>aop.toStringInterceptor</td><td>オブジェクトのフィールドの値を文字列化するためのカスタマイザ</td></tr>
<tr><td>removeSessionCustomizer</td><td>aop.removeSessionInterceptor</td><td>メソッドの実行後にHTTPセッションから属性を削除するためのカスタマイザ</td></tr>
<tr><td>commandTraceCustomizer</td><td>aop.traceInterceptor</td><td>do.*, initialize, prerenderをポイントカットとしてトレース出力するカスタマイザ</td></tr>
<tr><td>requiredTxCustomizer</td><td>j2ee.requiredTx</td><td>Requiredのトランザクション属性を有効にするためのカスタマイザ</td></tr>
<tr><td>requiresNewTxCustomizer</td><td>j2ee.requiresNewTx</td><td>RequiresNewのトランザクション属性を有効にするためのカスタマイザ</td></tr>
<tr><td>mandatoryTxCustomizer</td><td>j2ee.mandatoryTx</td><td>Mandatoryのトランザクション属性を有効にするためのカスタマイザ</td></tr>
<tr><td>notSupportedTxCustomizer</td><td>j2ee.notSupportedTx</td><td>NotSupportedのトランザクション属性を有効にするためのカスタマイザ</td></tr>
<tr><td>neverTxCustomizer</td><td>j2ee.neverTx</td><td>Neverのトランザクション属性を有効にするためのカスタマイザ</tr>
<tr><td>s2DxoCustomizer</td><td>dxo.interceptor</td><td>Dxoを利用するためのカスタマイザ</td></tr>
<tr><td>s2DaoCustomizer</td><td>dao.interceptor</td><td>S2Daoを利用するためのカスタマイザ</td></tr>
<tr><td>kuinaDaoCustomizer</td><td>kuinaDao.interceptor</td><td>Kuina-Daoを利用するためのカスタマイザ</td></tr>
</table>
<p>

</p>
<p>
これらのコンポーネントの実体は<code>org.seasar.framework.container.customizer.AspectCustomizer</code>です。
<code>AspectCustomizer</code>はコンポーネント定義にアスペクト定義を登録するカスタマイザです。
</p>
<p>
標準カスタマイザはインターセプタと関連づけられています。
実行時、標準カスタマイザは関連付けられたインターセプタからアスペクト定義を作成しコンポーネント定義に登録します。
</p>

<h5><a name="CustomizerConfig">カスタマイザの設定</a></h5>
<p>
アプリケーションで使用するカスタマイザの設定はcustomizer.diconに定義します。
例えば、サービスのコンポーネントに標準のカスタマイザである<code>traceCustomizer</code>と<code>traceThrowsCustomizer</code>を適用する場合、次のように記述します。
</p>
<pre>
&lt;components&gt;
  &lt;include path=&quot;default-customizer.dicon&quot;/&gt;
  ...
  &lt;component name=&quot;<b>serviceCustomizer</b>&quot; 
  　　class=&quot;<b>org.seasar.framework.container.customizer.CustomizerChain</b>&quot;&gt;
    &lt;initMethod name=&quot;<b>addCustomizer</b>&quot;&gt;
      &lt;arg&gt;<b>traceCustomizer</b>&lt;/arg&gt;
    &lt;/initMethod&gt;
    &lt;initMethod name=&quot;<b>addCustomizer</b>&quot;&gt;
      &lt;arg&gt;<b>traceThrowsCustomizer</b>&lt;/arg&gt;
    &lt;/initMethod&gt;
  &lt;/component&gt;
  ...
&lt;/components&gt;
</pre>
<p>
定義するコンポーネントの名前はデフォルトカスタマイザ一覧に示したコンポーネント名と同じにしてください。
こうすることでcusomizer.diconの定義がdefault-customizar.diconの定義より優先されます。
</p>

<h4><a name="CustomizerConfigExample">カスタマイザ設定例</a></h4>
<p>
カスタマイザの設定例を紹介します。
ここで紹介する設定はすべてcusomizer.diconに記述されることを想定しています。
</p>
<h5>特定のパターンに従ってカスタマイザを適用する</h3>
<ul>
	<li><h5>パターンに合致するコンポーネントにのみカスタマイザを適用する場合</h5></li>
<p>
例えば、サービスのコンポーネントのうち「Hoge」で始まるクラス名をもつコンポーネントにtraceCustomizerを適用する場合、
次のように<code>addClassPattern</code>メソッドを使用し条件を引数で渡します。
第1引数にはパッケージ名、第2引数にはクラス名の正規表現を指定します。
第1引数のパッケージ名は、前方一致条件として使用されます。
たとえば、「example.hoge」を指定した場合「example.hoge」も「example.hoge.foo」もパターンに合致するとみなされます。
</p>
<pre>
  &lt;component name=&quot;serviceCustomizer&quot; 
    class=&quot;org.seasar.framework.container.customizer.CustomizerChain&quot;&gt;
    &lt;initMethod name=&quot;<b>addClassPattern</b>&quot;&gt;
      &lt;arg&gt;"example.service"&lt;/arg&gt;
      &lt;arg&gt;"Hoge.*"&lt;/arg&gt;
    &lt;/initMethod&gt;
    &lt;initMethod name=&quot;addCustomizer&quot;&gt;
      &lt;arg&gt;traceCustomizer&lt;/arg&gt;
    &lt;/initMethod&gt;    
  &lt;/component&gt;
</pre>

	<li><h5>パターンに合致するコンポーネントにはカスタマイザを適用しない場合</h5></li>
<p>
逆に、サービスのコンポーネントのうち「Hoge」で始まるクラス名をもつコンポーネントにはtraceCustomizerを適用しない場合、
次のように<code>addIgnoreClassPattern</code>メソッドを使用し条件を引数で渡します。
第1引数にはパッケージ名、第2引数にはクラス名の正規表現を指定します。
第1引数のパッケージ名は、前方一致条件として使用されます。
</p>
<pre>
  &lt;component name=&quot;serviceCustomizer&quot; 
    class=&quot;org.seasar.framework.container.customizer.CustomizerChain&quot;&gt;
    &lt;initMethod name=&quot;<b>addIgnoreClassPattern</b>&quot;&gt;
      &lt;arg&gt;"example.service"&lt;/arg&gt;
      &lt;arg&gt;"Hoge.*"&lt;/arg&gt;
    &lt;/initMethod&gt;
    &lt;initMethod name=&quot;addCustomizer&quot;&gt;
      &lt;arg&gt;traceCustomizer&lt;/arg&gt;
    &lt;/initMethod&gt;    
  &lt;/component&gt;
</pre>
</ul>

<h5><a name="SMARTdeployTransaction">トランザクション制御を設定する</a></h5>
<ul>
	<li><h5>サービスのコンポーネントに適用する場合</h5></li>
	<p>
		<code>serviceCustomizer</code>にトランザクション制御を有効にするためのカスタマイザを設定します。
		ここではRequiredのトランザクション属性に対応する<code>requiredTxCustomizer</code>を使用します。
	</p>
<pre>
  &lt;component name=&quot;serviceCustomizer&quot; 
    class=&quot;org.seasar.framework.container.customizer.CustomizerChain&quot;&gt;
    &lt;initMethod name=&quot;addCustomizer&quot;&gt;
      &lt;arg&gt;<b>requiredTxCustomizer</b>&lt;/arg&gt;
    &lt;/initMethod&gt;
  &lt;/component&gt;
</pre>
	<p>
		この設定ではサービスのコンポーネントが実装するインタフェースのすべてのメソッドがトランザクション制御の対象になります。
	</p>

	<li><h5>ページのコンポーネントに適用する場合</h5></li>
	<p>
		<code>pageCustomizer</code>にトランザクション制御を有効にするためのカスタマイザを設定します。
		<code>addAspectCustomizer()</code>メソッドの第1引数にインターセプタのコンポーネント名、
		第2引数にトランザクション制御の対象となる特定のメソッドをポイントカットとして指定します。
	</p>	
<pre>
  &lt;component name=&quot;pageCustomizer&quot; 
    class=&quot;org.seasar.framework.container.customizer.CustomizerChain&quot;&gt;
    &lt;initMethod name=&quot;addAspectCustomizer&quot;&gt;
      &lt;arg&gt;<b>&quot;j2ee.requiredTx&quot;</b>&lt;/arg&gt;
      &lt;arg&gt;<b>&quot;do.*, initialize, prerender&quot;</b>&lt;/arg&gt;
    &lt;/initMethod&gt;
  &lt;/component&gt;
</pre>

	<li><h5>EJB 3.0のステートレスセッションBeanを利用する場合</h5></li>
	<p>
		EJB 3.0のステートレスセッションBeanはデフォルトでトランザクション制御を行う機能が備わっているのでcusomizer.diconに対する設定は不要です。
		S2ContainerのEJB 3.0サポートについては<a href="http://s2container.seasar.org/ja/ejb3.html">EJB3.0 Simplified API</a>を参照してください。
	</p>
</ul>

<h5><a name="useLookupAdapter">インスタンス属性がsingleton以外のインターセプタを利用する</a></h5>
<p>
	インターセプタを適用する<code>AspectCustomizer</code>の<code>useLookupAdapter</code>プロパティに<code>true</code>を設定をします。
</p>
<pre>
  &lt;component name=&quot;pageCustomizer&quot; 
    class=&quot;org.seasar.framework.container.customizer.CustomizerChain&quot;&gt;
    &lt;initMethod name=&quot;addCustomizer&quot;&gt;
      &lt;arg&gt;
        &lt;component class=&quot;org.seasar.framework.container.customizer.AspectCustomizer&quot;&gt;
          <b>&lt;property name=&quot;useLookupAdapter&quot;&gt;true&lt;/property&gt;</b>
          &lt;property name=&quot;interceptorName&quot;&gt;&quot;app_aop.authenticateInterceptor&quot;&lt;/property&gt;
          &lt;property name=&quot;pointcut&quot;&gt;&quot;do.*&quot;&lt;/property&gt;
        &lt;/component&gt;
      &lt;/arg&gt;
    &lt;/initMethod&gt;
  &lt;/component&gt;
</pre>
<p>
	※ この例で使用した「app_aop.authenticateInterceptor」という名前のインターセプタは標準で用意されているものではありません。
</p>
<h5>複数のデータソースを利用する</h5>
<p>
データソースごとにカスタマイザを作成し、それらのカスタマイザをdaoCustomizerに設定してください。
S2Daoを使用した例については<a href="http://www.seasar.org/wiki/index.php?FAQ%2FS2DAO#w7da6e0e">SMART deployで複数データソースに対応するには?</a>を参照してください。
</p>

<h2><a name="TagReference" id="TagReference">タグリファレンス</a></h2>
<h3><a name="DOCTYPE" id="DOCTYPE">DOCTYPE</a></h3>
<p>DOCTYPEは、XML宣言の次に指定します。下記のように指定してください。</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.3//EN"
"http://www.seasar.org/dtd/components23.dtd"&gt;
&lt;components&gt;
    &lt;component name="hello" class="examples.dicon.HelloConstructorInjection"&gt;
        &lt;arg&gt;"Hello World!"&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>
<h3><a name="componentsTag" id="componentsTag">componentsタグ(必須)</a></h3>
<p>ルートのタグになります。</p>
<h4><a name="namespaceAttr" id="namespaceAttr">namespace属性(任意)</a></h4>
<p><a href="#Namespace">名前空間</a>を指定することができます。Javaの識別子として使えるものにします</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.3//EN"
"http://www.seasar.org/dtd/components23.dtd"&gt;
&lt;components namespace="hoge"&gt;
    ...
&lt;/components&gt;
</pre>
<h3><a name="includeTag" id="includeTag">includeタグ(任意)</a></h3>
<p>分割されたS2Containerの定義を<a href="#Include">取り込む</a>場合に使います。</p>
<h4><a name="pathAttr" id="pathAttr">path属性(必須)</a></h4>
<p>定義ファイルのパスを指定することができます。CLASSPATHで指定されているディレクトリをルートとする定義ファイルの絶対パスです。例えば、WEB-INF/classes/aaa.dicon の場合は aaa.dicon に、WEB-INF/classes/aaa/bbb/ccc.dicon の場合は aaa/bbb/ccc.dicon になりますセパレータは、WindowsでもUnixでも/です。</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.3//EN"
"http://www.seasar.org/dtd/components23.dtd"&gt;
&lt;components&gt;
    &lt;include path="aaa/bbb/ccc.dicon" /&gt;
&lt;/components&gt;
</pre>
<h3><a name="componentTag" id="componentTag">componentタグ(任意)</a></h3>
<p>コンポーネントを定義します。</p>
<h4><a name="classAttr" id="classAttr">class属性(任意)</a></h4>
<p>クラスの完全限定名を指定します。ボディで、<a href="#ognlExpr">OGNL式</a>を使ってコンポーネントを指定した場合は、class属性を省略することができます。OGNL式を使った場合にclass属性を指定すると、型チェックを行います。</p>
<h4><a name="componentTag.nameAttr" id="componentTag.nameAttr">name属性(任意)</a></h4>
<p>名前を指定することもできます。Javaの識別子として使えるものにします。詳しくは、<a href="#getComponent">コンポーネントの取得</a>を参照してください。</p>
<h4><a name="instanceAttr" id="instanceAttr">instance属性(任意)</a></h4>
<p>S2Containerがどのようにコンポーネントのインスタンスを管理するのかを指定することができます。singleton(デフォルト)、prototype、outer、request、sessionを指定することができます。詳しくは、<a href="#InstanceMode">インスタンス管理</a>を参照してください。</p>
<h4><a name="autoBindingAttr" id="autoBindingAttr">autoBinding属性(任意)</a></h4>
<p>S2Containerがコンポーネントの依存関係をどのように解決するのかを指定できます。auto(デフォルト)、constructor、property、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。</p>
<h3><a name="argTag" id="argTag">argタグ(任意)</a></h3>
<p><a href="#componentTag">componentタグ</a>の子タグとして使った場合は、コンストラクタの引数になります。記述した順番でコンストラクタに渡されます。 <a href="#initMethodTag">initMethodタグ</a>、<a href="#destroyMethodTag">destroyMethodタグ</a>の子タグとして使った場合は、メソッドの引数になります。記述した順番でメソッドに渡されます。 引数として渡される実際の値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>
<h3><a name="propertyTag" id="propertyTag">propertyタグ(任意)</a></h3>
<p><a href="#componentTag">componentタグ</a>の子タグとして使います。プロパティとして設定される実際の値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>
<h4><a name="propertyTag.nameAttr" id="propertyTag.nameAttr">name属性(必須)</a></h4>
<p>プロパティ名を指定します。</p>
<h4><a name="propertyTag.bindingTypeAttr" id="propertyTag.bindingTypeAttr">bindingType属性(任意)</a></h4>
<p>プロパティごとに自動バインディングを細かく制御できます。must、should(デフォルト)、may、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。</p>
<h3><a name="metaTag" id="metaTag">metaタグ(任意)</a></h3>
<p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとして使います。メタデータの値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>
<h4><a name="propertyTag.nameAttr" id="propertyTag.nameAttr">name属性(任意)</a></h4>
<p>メタ名を指定します。</p>
<h3><a name="initMethodTag" id="initMethodTag">initMethodタグ(任意)</a></h3>
<p><a href="#componentTag">componentタグ</a>の子タグとして使います。引数は、子タグで、<a href="#argTag">argタグ</a>を使います。name属性を書かずに、<a href="#ognlExpr">OGNL式</a>を使って、コンポーネントのメソッドを呼び出すこともできます。initMethodタグが定義されているコンポーネント自身を表す#self、System.outを表す#out、System.errを表す#errがinitMethodタグ内だけで有効なオブジェクトとして使えます。</p>
<h4><a name="initMethodTag.nameAttr" id="initMethodTag.nameAttr">name属性(任意)</a></h4>
<p>メソッド名を指定します。</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR//DTD S2Container 2.3//EN"
"http://www.seasar.org/dtd/components23.dtd"&gt;
&lt;components&gt;
    &lt;component class="java.util.HashMap"&gt;
        &lt;initMethod name="put"&gt;
            &lt;arg&gt;"aaa"&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;initMethod&gt;#self.put("aaa", 111)&lt;/initMethod&gt;
        &lt;initMethod&gt;#out.println("Hello")&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>
<h3><a name="destroyMethodTag" id="destroyMethodTag">destroyMethodタグ(任意)</a></h3>
<p>initMethodタグと同様です。</p>

<h3><a name="aspectTag" id="aspectTag">aspectタグ(任意)</a></h3>
<p><a href="aop.html#Advice">Advice</a>(以下Interceptor)をコンポーネントに組み込みます。
Interceptorの指定は、ボディで他のコンポーネントを参照するか、子タグでcomponentタグを使います。
1つのコンポーネントに複数のアスペクトを組み込んだ場合はアスペクトの登録順に組み込まれ実行されます。</p>
<h4><a name="aspectWarning" id="aspectWarning">注意点</a></h4>
<ul>
<li>finalなクラスにはアスペクトを適用できません。</li>
<li>finalまたはstaticまたは非publicなメソッドにはアスペクトを適用できません。</li>
<li>aspectタグで指定されたコンポーネントは、
コンテナの初期化時にコンテナから取得されます。
そのため、aspectタグで指定されたコンポーネントのinstance属性がprototypeだったとしても、
Interceptor のメソッドが呼び出される度に新しいインスタンスが作成されるわけではありません。
singleton以外のスコープにしたい場合は、
<a href="aop.html#InterceptorLifecycleAdapter">InterceptorLifecycleAdapter</a>を使ってください。
</li>
</ul>

<h4><a name="pointcut">pointcut属性(任意)</a></h4>
<p>カンマ区切りで対象となるメソッド名を指定することができます。
pointcutを指定しない場合は、コンポーネントが実装しているインターフェースのすべてのメソッドが対象になります。
<b>publicなメソッドがすべて対象になるわけではないので注意してください。</b>
メソッド名には正規表現(JDK1.4のregex)も使えます。</p>
<h4>設定例</h4>
<p>pointcut属性を指定してjava.util.DateのgetTime()メソッドとhashCode()メソッドを対象とする場合以下のようになります。</p>
<pre>
&lt;component class="java.util.Date"&gt;
    &lt;aspect pointcut="getTime,hashCode"&gt;
        &lt;component class="org.seasar.framework.aop.interceptors.TraceInterceptor"/&gt;
    &lt;/aspect&gt;
&lt;/component&gt;
</pre>
<p>
正規表現を使ってjava.util.Dateのpublicなメソッドすべてを対象としたい場合は、以下のように設定します。
</p>
<pre>
&lt;component class="java.util.Date"&gt;
    &lt;aspect pointcut=".*"&gt;
        &lt;component class="org.seasar.framework.aop.interceptors.TraceInterceptor"/&gt;
    &lt;/aspect&gt;
&lt;/component&gt;
</pre>
<p>
pointcutの対象から外したいメソッドがある場合は以下のようにします。<br />
以下は「do」で始まり，その後に「ABC」が続くメソッドをpointcutの対象から外す例です。
doABC()メソッド、doABCDEF()メソッドがpointcutの対象から外れます。
</p>
<pre>
&lt;component class="java.util.Date"&gt;
    &lt;aspect pointcut="do(?!ABC).*"&gt;
        &lt;component class="org.seasar.framework.aop.interceptors.TraceInterceptor"/&gt;
    &lt;/aspect&gt;
&lt;/component&gt;
</pre>
<p>
また、以下のような設定も可能です。<br />
「do」で始まり，その後に「ABC」または「BCD」が続くメソッドをpointcutの対象から外す例です。
</p>
<pre>
&lt;component class="java.util.Date"&gt;
    &lt;aspect pointcut="do(?!ABC|BCD).*"&gt;
        &lt;component class="org.seasar.framework.aop.interceptors.TraceInterceptor"/&gt;
    &lt;/aspect&gt;
&lt;/component&gt;
</pre>

<h3><a name="interTypeTag" id="interTypeTag">interTypeタグ(任意)</a></h3>
<p><a href="aop.html#InterType">InterType</a>をコンポーネントに組み込みます。InterTypeの指定は、
ボディで他のコンポーネントを参照するか、子タグでcomponentタグを使います。
1つのコンポーネントに複数のInterTypeを組み込んだ場合はInterTypeの登録順に組み込まれます。</p>
<h5>設定例</h5>
<pre>
&lt;component class="java.util.Date"&gt;
    &lt;interType&gt;
        &lt;component class="org.seasar.framework.aop.intertype.PropertyInterType"/&gt;
    &lt;/interType&gt;
&lt;/component&gt;
</pre>

<h3><a name="descriptionTag" id="descriptionTag">descriptionタグ(任意)</a></h3>
<p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとしてdescriptionタグを使うことができます。自由に説明を記述できます。</p>
<h3><a name="ognlExpr" id="ognlExpr">OGNL式</a></h3>
<p>S2Containerでは、式言語として<a href="http://www.ognl.org/">OGNL</a>を利用しています。XMLの中で、文字列で記述した内容(式)をJavaのオブジェクトに変換するためのものだと思って間違いないと思います。</p>
<ul>
<li>文字列は、"hoge"のように"で囲みます。</li>
<li>charは、'a'のように'で囲みます。</li>
<li>数値は、123のようにそのまま記述します。</li>
<li>論理値は、true,falseのようにそのまま記述します。</li>
<li>new java.util.Date(0)のようにクラスの完全限定名でコンストラクタを呼び出すことができます。</li>
<li>@java.lang.Math@max(1, 2)のようにstaticなメソッドを呼び出した結果を参照することができます。</li>
<li>@java.lang.String@classのようにクラスを参照できます。</li>
<li>hoge.toString()のようにコンポーネントのメソッドを呼び出した結果を参照することができます。この例は、どこかでhogeという名前のコンポーネントが定義されているという前提です。</li>
</ul>
詳しくは、<a href="ognl.html">OGNLガイド</a>を参照してください。<br />
<br />

<h2><a name="AnnotationReference" id="AnnotationReference">アノテーションリファレンス</a></h2>
<p>S2Containerでは、アノテーションの実装方法として､ Tigerアノテーション､
定数アノテーションの2種類を用意しています。
一般的にアノテーションといえば､Java 5から導入された Tigerアノテーションですが､
JDK1.4のユーザでも利用できるように、public static finalな定数を利用する定数アノテーションも用意しています。</p>
<h3><a name="ComponentAnnotation" id="ComponentAnnotation">Componentアノテーション</a></h3>
<p><a href="#componentTag">componentタグ</a>のかわりに使えるのが、Componentアノテーションです。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Component(name="xxx", instance=InstanceType.PROTOTYPE,
        autoBinding=AutoBindingType.PROPERTY)
public class Xxx {
    ...
}
</pre>
<p>定数アノテーションは以下のようになります。</p>
<pre>
public static final String COMPONENT =
  "name = xxx, instance = prototype, autoBinding = property";
</pre>

<h3><a name="BindingAnnotation" id="BindingAnnotation">Bindingアノテーション</a></h3>
<p><a href="#propertyTag">propertyタグ</a>のかわりに使えるのが、Bindingアノテーションです。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Binding("aaa2")
public void setAaa(String aaa) {
    ...
}

@Binding(bindingType=BindingType.NONE)
public void setBbb(String bbb) {
    ...
}

@Binding
public void setCcc(String ccc) {
    ...
}

@Binding
private Foo foo;
</pre>
<p>定数アノテーションはプロパティ名_BINDINGで指定します。</p>
<pre>
public static final String aaa_BINDING = "aaa2";

public static final String bbb_BINDING = "bindingType=none";

public static final String ccc_BINDING = null;

public void setAaa(Aaa aaa) {
    ...
}

public void setBbb(Bbb bbb) {
    ...
}

public void setCcc(Ccc ccc) {
    ...
}
</pre>

<h3><a name="AspectAnnotation" id="AspectAnnotation">Aspectアノテーション</a></h3>
<p><a href="#aspectTag">aspectタグ</a>のかわりに使えるのが、Aspectアノテーションです。
aspectタグと異なり､複数定義することはできないので､ 複数のインターセプタを適用したい場合は､
<a href="aop.html#InterceptorChain">InterceptorChain</a>を使ってください。
ポイントカットを指定したいときは､pointcut属性を指定します。
クラスに対するアノテーションの場合､pointcutを指定しないときは､
そのクラスが実装しているすべてのインターフェースのメソッドが対象になります。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Aspect("aop.traceInterceptor")
public class Xxx {
    ...
}

public class Xxx {
    ...
    @Aspect("aop.traceInterceptor")
    public void hoge() {
        ...
    }
}
</pre>
<p>定数アノテーションは以下のようになります。pointcutを複数指定したい場合は､pointcut= get.*\nexecute.*のように\nで区切ってください。 \n以外の区切り文字を使ってはいけません。</p>
<pre>
public static final String ASPECT =
    "value=aop.traceInterceptor, pointcut=getAaa";
</pre>

<h3><a name="InterTypeAnnotation" id="InterTypeAnnotation">InterTypeアノテーション</a></h3>
<p><a href="#interTypeTag">interTypeタグ</a>のかわりに使えるのが、InterTypeアノテーションです。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@InterType({"aop.propertyInterType", "aop.someInterType"})
public class Xxx {
    ...
}
</pre>
<p>定数アノテーションは以下のようになります。</p>
<pre>
public static final String INTER_TYPE =
    "aop.propertyInterType, aop.someInterType";
</pre>

<h3><a name="InitMethodAnnotation" id="InitMethodAnnotation">InitMethodアノテーション</a></h3>
<p><a href="#initMethodTag">initMethodタグ</a>のかわりに使えるのが、InitMethodアノテーションです。
initMethodタグと異なり､OGNLの式を書いたり、引数を設定することはできません。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
public class Xxx {
    ...
    @InitMethod
    public void init() {
        ...
    }
}
</pre>
<p>定数アノテーションは以下のようになります。初期化メソッドを複数指定したい場合は､カンマ(,)で区切ってください。</p>
<pre>
public static final String INIT_METHOD = "init";
</pre>

<h3><a name="DestroyMethodAnnotation" id="DestroyMethodAnnotation">DestroyMethodアノテーション</a></h3>
<p><a href="#destroyMethodTag">destroyMethodタグ</a>のかわりに使えるのが、DestroyMethodアノテーションです。
destroyMethodタグと異なり､OGNLの式を書いたり、引数を設定することはできません。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
public class Xxx {
    ...
    @DestroyMethod
    public void destroy() {
        ...
    }
}
</pre>
<p>定数アノテーションは以下のようになります。destroyメソッドを複数指定したい場合は､カンマ(,)で区切ってください。</p>
<pre>
public static final String DESTROY_METHOD = "destroy";
</pre>
<!-- document end -->
<!-- don't edit start --></td>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt="" /></td>
</tr>
<tr>
<td width="14"><img height="30" width="14" src="images/spacer.gif" alt="" /></td>
<td width="766"><img height="30" width="592" src="images/spacer.gif" alt="" /></td>
</tr>
<tr>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt="" /></td>
<td width="766" class="copyright">Copyright© 2004-2005, The Seasar Foundation and the others. All rights reserved.</td>
</tr>
</table>
</td>
<td class="backright" align="left" valign="top">&nbsp;</td>
</tr>
<tr>
<td class="backunder" align="left" valign="top" width="780" height="16">&nbsp;</td>
<td class="backcorner" align="left" valign="top" height="16">&nbsp;</td>
</tr>
</table>
<!-- don't edit end -->
</body>
</html>
