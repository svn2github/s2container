<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<title>S2JDBC - JdbcManager</title>
	</properties>
	<body>
		<section name="JdbcManager">
			<p></p>
			<ul>
				<li>
					<p>
						<a href="#概要">概要</a>
					</p>
				</li>
				<li>
					<p>
						<a href="#検索">検索</a>
					</p>
					<ul>
						<li>
							<p>
								<a href="#複数件検索">複数件検索</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#1件検索">1件検索</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#結合">結合</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#検索条件">検索条件</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#ソート順">ソート順</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#ページング">ページング</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#最大行数">最大行数</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#フェッチサイズ">フェッチサイズ</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#クエリタイムアウト">クエリタイムアウト</a>
							</p>
						</li>
					</ul>
				</li>
				<li>
					<p>
						<a href="#挿入">挿入</a>
					</p>
					<ul>
						<li>
							<p>
								<a href="#1件挿入">1件挿入</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#バッチ挿入">バッチ挿入</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#nullの項目を挿入しない">
									nullの項目を挿入しない
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#指定したプロパティのみを挿入対象にする">
									指定したプロパティのみを挿入対象にする
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#指定したプロパティを挿入対象から除外する">
									指定したプロパティを挿入対象から除外する
								</a>
							</p>
						</li>
					</ul>
				</li>
				<li>
					<p>
						<a href="#更新">更新</a>
					</p>
					<ul>
						<li>
							<p>
								<a href="#1件更新">1件更新</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#バッチ更新">バッチ更新</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#バージョンプロパティを通常の更新対象にする">
									バージョンプロパティを通常の更新対象にする
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#nullの項目を更新しない">
									nullの項目を更新しない
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#指定したプロパティのみを更新対象にする">
									指定したプロパティのみを更新対象にする
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#指定したプロパティを更新対象から除外する">
									指定したプロパティを更新対象から除外する
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#変更のあったプロパティのみを更新対象にする">
									変更のあったプロパティのみを更新対象にする
								</a>
							</p>
						</li>
					</ul>
				</li>
				<li>
					<p>
						<a href="#削除">削除</a>
					</p>
					<ul>
						<li>
							<p>
								<a href="#1件削除">1件削除</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#バッチ削除">バッチ削除</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#バージョンをチェックしないで削除する">
									バージョンをチェックしないで削除する
								</a>
							</p>
						</li>
					</ul>
				</li>
				<li>
					<p>
						<a href="#SQLを使った検索">SQLを使った検索</a>
					</p>
					<ul>
						<li>
							<p>
								<a href="#SQLを使った複数件検索">SQLを使った複数件検索</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#SQLを使った1件検索">SQLを使った1件検索</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#SQLを使ったページング">SQLを使ったページング</a>
							</p>
						</li>
					</ul>
				</li>
				<li>
					<p>
						<a href="#SQLを使った挿入・更新・削除">SQLを使った挿入・更新・削除</a>
					</p>
					<ul>
						<li>
							<p>
								<a href="#SQLを使った1件挿入・更新・削除">
									SQLを使った1件挿入・更新・削除
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#SQLを使ったバッチ挿入・更新・削除">
									SQLを使ったバッチ挿入・更新・削除
								</a>
							</p>
						</li>
					</ul>
				</li>
				<li>
					<p>
						<a href="#SQLを使ったプロシージャ呼び出し">
							SQLを使ったプロシージャ呼び出し
						</a>
					</p>
				</li>
				<li>
					<p>
						<a href="#S2Dao譲りのSQLファイル">S2Dao譲りのSQLファイル</a>
					</p>
					<ul>
						<li>
							<p>
								<a href="#SQLファイルのパス">
									SQLファイルのパス
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#SQLファイルを使った複数件検索">
									SQLファイルを使った複数件検索
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#SQLファイルを使った1件検索">
									SQLファイルを使った1件検索
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#SQLファイルを使ったページング">SQLファイルを使ったページング</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#SQLファイルを使った更新">
									SQLファイルを使った更新
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#SQLファイルを使ったバッチ更新">
									SQLファイルを使ったバッチ更新
								</a>
							</p>
						</li>
						<li>
							<p>
								<a href="#SQLファイルを使ったプロシージャ呼び出し">
									SQLファイルを使ったプロシージャ呼び出し
								</a>
							</p>
						</li>
					</ul>
				</li>
			</ul>
		</section>

		<section name="概要">
			<p>
				JdbcManagerは、データベースにアクセスするために使われるAPIです。 設定ファイルを
				<a href="s2jdbc_setup.html">セットアップ</a>
				して、 利用したいクラスで次のようにプロパティを定義しておけば、
				Seasar2によってJdbcManagerは自動的に設定されます。
			</p>
			<source><![CDATA[
public JdbcManager jdbcManager;
]]></source>
			<p>
				Connection, Statementは同一トランザクション中はキャッシュされ、
				トランザクション終了時に自動的にクローズされます。
				トランザクション外で呼び出されたときは、キャッシュは行なわれず毎回自動的にクローズされます。
			</p>
			<p>
				トランザクション管理は、
				<a href="tx.html">S2Tx</a>
				を使ってください。
			</p>
		</section>

		<section name="検索">
			<subsection name="複数件検索">
				<p>複数件を検索する場合は、gerResultList()を使います。</p>
				<source><![CDATA[
List<Employee> results = jdbcManager.from(Employee.class).getResultList();
]]></source>
				<p>検索するエンティティは、from()で指定します。</p>
			</subsection>

			<subsection name="1件検索">
				<p>1件検索する場合は、getSingleResult()を使います。</p>
				<source><![CDATA[
Employee result = jdbcManager.from(Employee.class).getSingleResult();
]]></source>
				<p>
					結果が複数件になる場合は、
					<code>
						javax.persistence.NonUniqueResultException
					</code>
					が発生します。
				</p>
			</subsection>

			<subsection name="結合">
				<p>
					他のエンティティを結合する場合は、join()を使います。
					引数は、結合したいエンティティのプロパティ名です。
				</p>
				<source><![CDATA[
List<Employee> results = jdbcManager.from(Employee.class).join("department").getResultList();
]]></source>
				<p>
					デフォルトは、左外部結合で、結合で指定したエンティティは、検索結果に含まれます。
					次のように内部結合にすることもできます。
				</p>
				<source><![CDATA[
List<Employee> results = jdbcManager.from(Employee.class)
                                    .join("department", JoinType.INNER).getResultList();
]]></source>
				<p>検索条件には含めたいけど、検索結果には含めたくない場合、 3番名の引数をfalseにします。</p>
				<source><![CDATA[
List<Employee> results = jdbcManager.from(Employee.class)
                                    .join("department", JoinType.INNER, false)
                                    .where("department.name = 'RESEARCH'")
                                    .getResultList();
]]></source>
				<p>
					結合は、employee.addressのようにネストすることもできます。
					ネストする場合は、必ずベースとなる結合を先に指定します。
					employee.addressの場合、employeeがベースとなる結合です。
				</p>
				<source><![CDATA[
List<Department> results = jdbcManager.from(Department.class)
                                    .join("employee")
                                    .join("employee.address")
                                    .getResultList();
]]></source>
				<p>結合は、多対一関連、一対多関連、一対一関連のどれでも可能で、 いくつでもネストすることが可能です。</p>
			</subsection>

			<subsection name="検索条件">
				<p>
					検索条件を指定する場合は、where()を使います。
					where()に書くことのできる条件は、SQLと同じです。
					SQLとの違いは、カラム名の変わりにプロパティ名を書くことです。
					関連先のプロパティを指定する場合は、join()で指定した名前. プロパティ名になります。
				</p>
				<source><![CDATA[
jdbcManager.from(Department.class)
    .join("employeeList")
    .join("employeeList.address")
    .where("employeeList.salary between ? and ? and employeeList.address.street like ?", ...)
    .getResultList();
]]></source>
				<p>
					検索条件の入力画面などでは、ユーザの入力があった部分をandでつないで、
					条件を組み立てるということが良く行われます。 このようなケースを簡単に処理するために、
					SimpleWhereとMapでも、検索条件を指定できるようにしています。
				</p>
				<p>
					名前、仕事タイプ、給与の上限下限を条件に検索する画面を考えてみましょう。
					べたに検索条件を組み立てるとはこんな感じになるはずです。
				</p>
				<source><![CDATA[
public String departmentName;
public String[] jobTypes = new String[0];
public BigDecimal salaryMax;
public BigDecimal salaryMin;
...
StringBuilder sb = new StringBuilder(100);
boolean found = false;
List<Object> values = new ArrayList<Object>();
if (departmentName != null) {
    sb.append("department.name = ?");
    values.add(departmentName);
    found = true;
}
if (jobTypes.length > 0) {
    if (found) {
        sb.append(" and ");
    }
    sb.append("jobType in (");
    for (JobType jt : jobTypes) {
        sb.append("?, ");
        values.add(jt);
    }
    sb.setLength(sb.length() - 2);
    sb.append(")");
    found = true;
}
if (salaryMin != null) {
    if (found) {
        sb.append(" and ");
    }
    sb.append("salary >= ?");
    values.add(salaryMin);
    found = true;
}
if (salaryMax != null) {
    if (found) {
        sb.append(" and ");
    }
    sb.append("salary <= ?");
    values.add(salaryMax);
    found = true;
}
jdbcManager.from(Employee.class).where(sb.toString(), values.toArray()).getResultList();
]]></source>
				<p>SimpleWhereを使って組み立てれば、こんなに簡単になります。</p>
				<source><![CDATA[
public String departmentName;
public String[] jobTypes = new String[0];
public BigDecimal salaryMax;
public BigDecimal salaryMin;
...
jdbcManager.from(Employee.class)
    .where(new SimpleWhere()
        .eq("department.name", departmentName)
        .in("jobType", jobTypes)
        .ge("salary", salaryMin)
        .le("salary", salaryMax))
    .getResultList();
]]></source>
				<p>SimpleWhereには次のメソッドがあります。</p>
				<table border="1">
					<tbody>
						<tr>
							<th>メソッド</th>
							<th>説明</th>
						</tr>
						<tr>
							<td>
								eq(String propertyName, Object value)
							</td>
							<td>
								<code>propertyName = ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								ne(String propertyName, Object value)
							</td>
							<td>
								<code>propertyName &lt;&gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								lt(String propertyName, Object value)
							</td>
							<td>
								<code>propertyName &lt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								le(String propertyName, Object value)
							</td>
							<td>
								<code>propertyName &lt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								gt(String propertyName, Object value)
							</td>
							<td>
								<code>propertyName &gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								ge(String propertyName, Object value)
							</td>
							<td>
								<code>propertyName &gt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								in(String propertyName, Object...
								values)
							</td>
							<td>
								<code>propertyName in (?, ...)</code>
								の条件を追加します。 valuesの配列の長さが0の時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								not in(String propertyName, Object...
								values)
							</td>
							<td>
								<code>
									propertyName not in (?, ...)
								</code>
								の条件を追加します。 valuesの配列の長さが0の時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								like(String propertyName, String value)
							</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								starts(String propertyName, String
								value)
							</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最後に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td>
								ends(String propertyName, String value)
							</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td>
								contains(String propertyName, String
								value)
							</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初と最後に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td>
								isNull(String propertyName, Boolean
								value)
							</td>
							<td>
								<code>propertyName is null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								isNotNull(String propertyName, Boolean
								value)
							</td>
							<td>
								<code>propertyName is not null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
							</td>
						</tr>
						<!--
							<tr>
							<td>or()</td>
							<td>
							これまでに追加された条件とこれから追加される条件をORで結合します。 次に
							or() が呼び出されるまでの条件は AND で結合されます。
							</td>
							</tr>
							<tr>
							<td>ignoreWhitespace()</td>
							<td>
							上記のメソッドに渡されたパラメータ値がnullの場合に加え、
							空文字列や空白だけの文字列の場合も条件に追加しないことを指定します。
							このメソッドが呼び出された後に追加される条件にのみ適用されます。
							</td>
							</tr>
						-->
					</tbody>
				</table>
				<!--
					<p>ORを使うには次のようにします。</p>
					<source><![CDATA[
					jdbcManager.from(Employee.class)
					.where(new SimpleWhere()
					.le("salary", salaryMin).or().ge("salary", salaryMax)
					.or().
					.getResultList();
					]]></source>
				-->
				<p>Mapを使うと次のようになります。</p>
				<source><![CDATA[
public String departmentName;
public String[] jobTypes = new String[0];
public BigDecimal salaryMax;
public BigDecimal salaryMin;
...
Map<String, Object> w = new HashMap<String, Object>();
w.put("department.name", departmentName);
w.put("jobType_IN", jobTypes);
w.put("salary_LE", salaryMax);
w.put("salary_GE", salaryMin);
jdbcManager.from(Employee.class).where(w).getResultList();
]]></source>
				<p>
					マップのキーにプロパティ名_サフィックスを指定します。 サフィックスがない場合は、
					<code>_EQ</code>
					が指定されたとみなされます。
				</p>
				<p>次のサフィックスを使うことができます。</p>
				<table border="1">
					<tbody>
						<tr>
							<th>サフィックス</th>
							<th>説明</th>
						</tr>
						<tr>
							<td>_EQ</td>
							<td>
								<code>propertyName = ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>_NE</td>
							<td>
								<code>propertyName &lt;&gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>_LT</td>
							<td>
								<code>propertyName &lt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>_LE</td>
							<td>
								<code>propertyName &lt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>_GT</td>
							<td>
								<code>propertyName &gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>_GE</td>
							<td>
								<code>propertyName &gt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>_IN</td>
							<td>
								<code>propertyName in (?, ...)</code>
								の条件を追加します。 valuesの配列の長さが0の時は追加されません。
								値は配列のみをサポートしています。
							</td>
						</tr>
						<tr>
							<td>_NOT_IN</td>
							<td>
								<code>
									propertyName not in (?, ...)
								</code>
								の条件を追加します。 valuesの配列の長さが0の時は追加されません。
								値は配列のみをサポートしています。
							</td>
						</tr>
						<tr>
							<td>_LIKE</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>_STARTS</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最後に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td>_ENDS</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td>_CONTAINS</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初と最後に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td>_IS_NULL</td>
							<td>
								<code>propertyName is null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
								値はBooleanのみをサポートしています。
							</td>
						</tr>
						<tr>
							<td>_IS_NOT_NULL</td>
							<td>
								<code>propertyName is not null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
								値はBooleanのみをサポートしています。
							</td>
						</tr>
					</tbody>
				</table>
				<p>
					マップの組み立てを手動でやる必要は、基本的にありません。
					なぜなら、SimpleWhereのほうが便利だからです。 マップを使う場合は、次のように
					<code>
						org.seasar.framework.beans.util.BeanUtil.createProperties()
					</code>
					と組み合わせます。
					<code>createProperties()</code>
					の第二引数には、プロパティ名のプレフィックスを指定します。
					プレフィックスを指定した場合、プレフィックスを持つプロパティだけが対象になります。
					プロパティ名がマップのキーに変換されるときに、 プレフィックスは削除され、'$'は'.'に変換されます。
				</p>
				<source><![CDATA[
public String where_department$name;
public String[] where_jobType_IN = new String[0];
public BigDecimal where_salary_LE;
public BigDecimal where_salary_GE;
...
jdbcManager.from(Employee.class)
    .where(BeanUtil.createProperties(this, "where_"))
    .getResultList();
]]></source>
				<!--
					<p>マップを使った場合にはORはサポートされていません。</p>
				-->
			</subsection>

			<subsection name="ソート順">
				<p>
					ソート順を指定する場合は、
					<code>orderBy()</code>
					を使います。
					<code>orderBy()</code>
					に書くことのできる条件は、SQLと同じです。
					SQLとの違いは、カラム名の変わりにプロパティ名を書くことです。
					関連先のプロパティを指定する場合は、join()で指定した名前. プロパティ名になります。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .join("department")
    .orderBy("name, department.name")
    .getResultList();
]]></source>
			</subsection>

			<subsection name="ページング">
				<p>
					ページングを指定する場合は、
					<code>limit(), offset()</code>
					を使います。
					<code>limit()</code>
					には、取得する行数を指定します。
					<code>offset()</code>
					には、最初に取得する行の位置を指定します。 最初の行の位置は0になります。
					ページングを指定するには、必ず
					<a href="#ソート順">ソート順</a>
					の指定も必要です。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .orderBy("name")
    .limit(100)
    .offset(10)
    .getResultList();
]]></source>
			</subsection>

			<subsection name="最大行数">
				<p>
					最大行数を指定する場合は、
					<code>maxRows()</code>
					を使います。 最大行数を超える行は、通知なしに除外されます。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .maxRows(1000)
    .getResultList();
]]></source>
			</subsection>

			<subsection name="フェッチサイズ">
				<p>
					フェッチサイズを指定する場合は、
					<code>fetchSize()</code>
					を使います。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .fetchSize(100)
    .getResultList();
]]></source>
			</subsection>

			<subsection name="クエリタイムアウト">
				<p>
					クエリタイムアウト(秒)を指定する場合は、
					<code>queryTimeout()</code>
					を使います。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .queryTimeout(10)
    .getResultList();
]]></source>
			</subsection>
		</section>

		<section name="挿入">
			<subsection name="1件挿入">
				<p>
					エンティティを挿入する場合は、
					<code>insert()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int count = jdbcManager.insert(employee).execute();
]]></source>
				<p>
					引数はエンティティで、戻り値は、更新した行数です。 挿入するときに、識別子を自動設定することができます。
					詳しくは、
					<a href="s2jdbc_entity.html#識別子定義">識別子定義</a>
					を参照してください。
				</p>
			</subsection>

			<subsection name="バッチ挿入">
				<p>
					複数のエンティティをバッチ挿入する場合は、
					<code>insertBatch()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager.insertBatch(employees).execute();
]]></source>
				<p>
					引数はエンティティのリストあるいは配列(可変長引数)で、戻り値は、更新した行数の配列です。
					挿入するときに、識別子を自動設定することができます。 詳しくは、
					<a href="s2jdbc_entity.html#識別子定義">識別子定義</a>
					を参照してください。
				</p>
			</subsection>

			<subsection name="nullの項目を挿入しない">
				<p>
					挿入の対象からnullの項目を除外する場合は、
					<code>excludesNull()</code>
					を使います。 バッチ系の挿入は、すべてのエンティティに同じSQLを適用しなければならないので、
					nullを除外してバッチ挿入することはできません。
					なぜなら、すべてのエンティティのnullの項目が同じだとは限らないからです。
				</p>
				<source><![CDATA[
int count = jdbcManager.insert(employee).excludesNull().execute();
]]></source>
			</subsection>

			<subsection name="指定したプロパティのみを挿入対象にする">
				<p>
					指定したプロパティのみを挿入対象にする場合は、
					<code>includes()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.insert(employee).includes("id", "name").execute();
]]></source>
			</subsection>

			<subsection name="指定したプロパティを挿入対象から除外する">
				<p>
					指定したプロパティを挿入対象から除外する場合は、
					<code>excludes()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.insert(employee).excludes("version").execute();
]]></source>
			</subsection>
		</section>

		<section name="更新">
			<subsection name="1件更新">
				<p>
					エンティティを更新する場合は、
					<code>update()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int count = jdbcManager.update(employee).execute();
]]></source>
				<p>
					引数はエンティティで、戻り値は、更新した行数です。
					更新するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>
					を参照してください。
				</p>
			</subsection>

			<subsection name="バッチ更新">
				<p>
					複数のエンティティをバッチ更新する場合は、
					<code>updateBatch()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager.updateBatch(employees).execute();
]]></source>
				<p>
					引数はエンティティのリストあるいは配列(可変長引数)で、戻り値は、更新した行数の配列です。
					更新するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>
					を参照してください。
				</p>
			</subsection>

			<subsection name="バージョンプロパティを通常の更新対象にする">
				<p>
					バージョンプロパティを通常の更新対象に含め、バージョンチェックの対象外にする場合は、
					<code>includesVersion()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.update(employee).includesVersion().execute();
]]></source>
			</subsection>

			<subsection name="nullの項目を更新しない">
				<p>
					更新の対象からnullの項目を除外する場合は、
					<code>excludesNull()</code>
					を使います。 バッチ系の更新は、すべてのエンティティに同じSQLを適用しなければならないので、
					nullを除外してバッチ更新することはできません。
					なぜなら、すべてのエンティティのnullの項目が同じだとは限らないからです。
				</p>
				<source><![CDATA[
int count = jdbcManager.update(employee).excludesNull().execute();
]]></source>
			</subsection>

			<subsection name="指定したプロパティのみを更新対象にする">
				<p>
					指定したプロパティのみを更新対象にする場合は、
					<code>includes()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.update(employee).includes("id", "name").execute();
]]></source>
			</subsection>

			<subsection name="指定したプロパティを更新対象から除外する">
				<p>
					指定したプロパティを更新対象から除外する場合は、
					<code>excludes()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.update(employee).excludes("version").execute();
]]></source>
			</subsection>

			<subsection name="変更のあったプロパティのみを更新対象にする">
				<p>
					変更のあったプロパティのみを更新対象にする場合は、
					<code>changedFrom()</code>
					を使います。 最初の引数は、比較の対象にする以前のエンティティもしくはマップです。
				</p>
				<source><![CDATA[
Employee before = ...;
int count = jdbcManager.update(employee).changedFrom(before).execute();
]]></source>
			</subsection>
		</section>

		<section name="削除">
			<subsection name="1件削除">
				<p>
					エンティティを削除する場合は、
					<code>delete()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int count = jdbcManager.delete(employee).execute();
]]></source>
				<p>
					引数はエンティティで、戻り値は、更新した行数です。
					削除するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>
					を参照してください。
				</p>
			</subsection>

			<subsection name="バッチ削除">
				<p>
					複数のエンティティをバッチ削除する場合は、
					<code>deleteBatch()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager.deleteBatch(employees).execute();
]]></source>
				<p>
					引数はエンティティのリストあるいは配列(可変長引数)で、戻り値は、更新した行数の配列です。
					削除するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>
					を参照してください。
				</p>
			</subsection>

			<subsection name="バージョンをチェックしないで削除する">
				<p>
					バージョンをチェックしないで削除する場合は、
					<code>ignoreVersion()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.delete(employee).ignoreVersion().execute();
]]></source>
			</subsection>
		</section>

		<section name="SQLを使った検索">
			<subsection name="SQLを使った複数件検索">
				<p>
					SQLを使って複数件検索をする場合は、
					<code>selectBySql()</code>
					と
					<code>getResultList()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
List<EmployeeDto> results = jdbcManager.selectBySql(
    EmployeeDto.class, "select ... where department_id = ?", 10)
    .getResultList();
]]></source>
				<p>
				結果を<code>Map</code>で受け取ることもできます。
				</p>
				<source><![CDATA[
List<RowMap> results = jdbcManager.selectBySql(
    RowMap.class, "select ...")
    .getResultList();
]]></source>
				<p>
				RowMapはMap&lt;String, Object&gt;なクラスで、
				存在しないキーにアクセスすると
				例外が発生します。
				キーの値は、AAA_BBBのような'_'記法の値ををaaaBbbのようなキャメル記法に
				変換したものです。
				</p>
				<p>
					このルールは、convention.diconで指定されている
					<code>
						org.seasar.framework.convention.impl.PersistenceNamingConventionImpl
					</code>
					のfromColumnNameToPropertyName()の実装を変えることで、カスタマイズすることができます。
				</p>
			</subsection>

			<subsection name="SQLを使った1件検索">
				<p>
					SQLを使って1件検索をする場合は、
					<code>selectBySql()</code>
					と
					<code>getSingleResult()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
Integer count = jdbcManager.selectBySql(
    Integer.class, "select count(*) from emp")
    .getSingleResult();
]]></source>
				<p>
				結果を<code>Map</code>で受け取ることもできます。
				</p>
				<source><![CDATA[
RowMap result = jdbcManager.selectBySql(
    RowMap.class, "select ...")
    .getSingleResult();
]]></source>
				<p>
				RowMapはMap&lt;String, Object&gt;なクラスで、
				存在しないキーにアクセスすると
				例外が発生します。
				キーの値は、AAA_BBBのような'_'記法の値ををaaaBbbのようなキャメル記法に
				変換したものです。
				</p>
				<p>
					このルールは、convention.diconで指定されている
					<code>
						org.seasar.framework.convention.impl.PersistenceNamingConventionImpl
					</code>
					のfromColumnNameToPropertyName()の実装を変えることで、カスタマイズすることができます。
				</p>
			</subsection>
			
			<subsection name="SQLを使ったページング">
				<p>
					ページングを指定する場合は、
					<code>limit(), offset()</code>
					を使います。
					<code>limit()</code>
					には、取得する行数を指定します。
					<code>offset()</code>
					には、最初に取得する行の位置を指定します。 最初の行の位置は0になります。
					ページングを指定するには、必ず<code>ordey by</code>句が必要です。
					order by句で指定するカラムは、selectリストにも含めるようにしてください。
				</p>
				<source><![CDATA[
jdbcManager.selectBySql(EmployeeDto.class,
    "select id, name from employee order by name")
    .limit(100)
    .offset(10)
    .getResultList();
]]></source>
			</subsection>
		</section>

		<section name="SQLを使った挿入・更新・削除">
			<subsection name="SQLを使った1件挿入・更新・削除">
				<p>
					SQLを使ってエンティティを更新する場合は、
					<code>updateBySql()</code>
					、
					<code>params()</code>
					、
					<code>execute()</code>
					を組み合わせます。
					<code>updateBySql()</code>
					の2番目以降の引数はパラメータのクラスの可変長引数です。 挿入、削除も
					<code>updateBySql()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.updateBySql(
    "update employee set salary = ? where id = ?", BigDecimal.class, Integer.class)
    .params(null, 1)
    .execute();
]]></source>
			</subsection>

			<subsection name="SQLを使ったバッチ挿入・更新・削除">
				<p>
					SQLを使って複数エンティティをバッチ更新する場合は、
					<code>updateBatchBySql()</code>
					、
					<code>params()</code>
					、
					<code>execute()</code>
					を組み合わせます。
					<code>updateBatchBySql()</code>
					の2番目以降の引数はパラメータのクラスの可変長引数です。 挿入、削除も
					<code>updateBatchBySql()</code>
					を使います。
				</p>
				<source><![CDATA[
List<EmployeeDto> dtoList = ...;
...
SqlBatchUpdate batchUpdate = jdbcManager.updateBatchBySql(
    "update employee set salary = ? where id = ?", BigDecimal.class, Integer.class);
for (EmployeeDto dto : dtoList) {
    batchUpdate.params(dto.salary, dto.id);
}
int[] countArray = batchUpdate.execute();
]]></source>
			</subsection>
		</section>

		<section name="SQLを使ったプロシージャ呼び出し">
			<p>
				SQLを使ってプロシージャを呼び出す場合は、
				<code>callBySql()</code>
				、
				<code>call()</code>
				を組み合わせます。 最初の例は、パラメータのない場合です。
			</p>
			<source><![CDATA[
jdbcManager.callBySql("{call myproc()}").call();
]]></source>
			<p>
				INのパラメータが1つだけで、そのパラメータが
				<code>null</code>
				にならない場合は、
				<code>callBySql()</code>
				の2番目の引数で値を直接指定します。
			</p>
			<source><![CDATA[
jdbcManager.callBySql("{call myproc(?)}", "hoge").call();
]]></source>
			<p>
				上記以外の場合は、
				<code>callBySql()</code>
				の2番目の引数にJavaBeansを指定します。
				プロシージャを呼び出すパラメータの順番にJavaBeansのフィールドを定義します。
				<br />
				<ul>
					<li>
						<p>
							フィールド名が_OUTで終わっている場合
							<code>OUT</code>
							パラメータになります。
						</p>
					</li>
					<li>
						<p>
							フィールド名が_IN_OUTで終わっている場合
							<code>IN OUT</code>
							パラメータになります。
						</p>
					</li>
					<li>
						<p>
							フィールド名が_INで終わっている場合
							<code>IN</code>
							パラメータになります。
						</p>
					</li>
					<li>
						<p>
							フィールド名が_OUT、_IN_OUT、_INで終わっていない場合は、
							<code>IN</code>
							パラメータになります。
						</p>
					</li>
				</ul>
			</p>
			<source><![CDATA[
public class MyDto {

    public String result_OUT;
    
    public int arg1_IN_OUT;
    
    public int arg2_IN;
}
]]></source>
			<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1_IN_OUT = 1;
dto.arg2_IN = 2;
jdbcManager.callBySql("{? = call myproc(?, ?)}", dto).call();
System.out.println(dto.result_OUT);
System.out.println(dto.arg1_IN_OUT);
]]></source>
			<p>
				プロシージャが結果セットを返す場合は、
				対応するフィールドの型をList&lt;結果セットに対応する型&gt;にします。
			</p>
			<source><![CDATA[
public class MyDto {

    public List<EmployeeDto> result_OUT;
    
    public int arg1_IN;
}
]]></source>
			<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1_IN = 1;
jdbcManager.callBySql("{? = call myproc(?)}", dto).call();
System.out.println(dto.result_OUT);
]]></source>
		</section>
			<p>
			オラクルとMySQL以外は、結果セットの受け取りをパラメータで定義する必要はありません。
			JavaBeansの最初のフィールドを結果セット用に定義し、
			2番目以降をパラメータに対応したフィールドにします。
			</p>
			<source><![CDATA[
public class MyDto {

    public List<EmployeeDto> result_OUT;
    
    public int arg1_IN;
}
]]></source>
			<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1_IN = 1;
jdbcManager.callBySql("{call myproc(?)}", dto).call();
System.out.println(dto.result_OUT);
]]></source>

		<section name="S2Dao譲りのSQLファイル">
			<p>S2Dao譲りのSQLファイルを使うこともできます。</p>
			<p>
				SQLファイルとは、SQLをソースコードに記述するのではなく、 ファイルに記述したものです。
				単純なSQLだとソースコードに直接記述したほうが、
				めんどくさくなくて楽(わざわざファイルを作る必要がない)ですが、
				複雑なSQLは、ファイルに記述したほうが、メンテナンス性が高いでしょう。
			</p>
			<p>
				SQLファイルは、クラスパス上にあるならどこにおいてもかまいませんが、
				<code>ルートパッケージ.entity.エンティティ名</code>
				のパッケージ配下に置くことを推奨します。 例えば、
				<code>Employee</code>
				エンティティに関するSQLは、
				<code>examples.entity.Employee</code>
				パッケージにおくと良いでしょう。
			</p>
			<p>
				複数のテーブルを結合するような場合は、 一番主軸となっているテーブルのエンティティを選びます。
				プロシージャの場合も同様です。
			</p>
			<p>何のパラメータもない単純なSQLファイルは次のようになります。</p>
			<source><![CDATA[
select * from employee
where
salary >= 1000
and salary <= 2000
]]></source>
			<p>
				1000の部分を
				<code>salaryMin</code>
				というパラメータで置き換えるには、
				次のように置き換えたいリテラルの左にSQLコメントでパラメータ名を埋め込みます。
				リテラルを文字列として直接置き換えるのではなく、
				<code>PreparedStatment</code>
				を使ったバインド変数に置き換えるので、SQLインジェクション対策も問題ありません。
			</p>
			<source><![CDATA[
select * from employee
where
salary >= /*salaryMin*/1000
and salary <= 2000
]]></source>
			<p>
				同様に2000の部分も
				<code>salaryMax</code>
				というパラメータで置き換えます。
			</p>
			<source><![CDATA[
select * from employee
where
salary >= /*salaryMin*/1000
and salary <= /*salaryMax*/2000
]]></source>
			<p>
				<code>in</code>
				を置き換える場合は次のようにします。 ()で囲まれている部分を置き換えます。
				idのパラメータの型は、配列かリストになります。
			</p>
			<source><![CDATA[
select * from employee
where
id in /*id*/(1, 2)
]]></source>
			<p>
				<code>like</code>
				を置き換える場合は次のようにします。 '(シングルクオート)で囲まれている部分を置き換えます。
				ワイルドカードを使いたい場合は、パラメータの値に埋め込んでください。
			</p>
			<source><![CDATA[
select * from employee
where
name like /*name*/'S%'
]]></source>
			<p>
				検索条件の入力画面などで、何か条件が入力されていれば、
				検索条件に追加し、入力されていなければ条件には追加しないということを実装してみましょう。
				このような場合は、IFコメントとENDコメントを組み合わせます。
			</p>
			<source><![CDATA[
select * from employee
where
/*IF salaryMin != null*/
salary >= /*salaryMin*/1000
/*END*/
/*IF salaryMax != null*/
and salary <= /*salaryMax*/2000
/*END*/
]]></source>
			<p>
				IFコメントの内容が
				<code>true</code>
				なら、 IFコメントとENDコメントで囲んでいる内容が出力されます。
				IFコメントの条件は、OGNLによって評価されます。 詳しくは、
				<a href="ognl.html">OGNLガイド</a>
				を参照してください。
			</p>
			<p>
				上記のように記述すると、salaryMinがnullでsalaryMaxがnullではないときは、
				次のような不正(andがwhereの直後にある)なSQLになります。
			</p>
			<source><![CDATA[
select * from employee
where
and salary <= ?
]]></source>
			<p>
				また、salaryMinもsalaryMaxもnullの場合も、
				次のような不正(whereだけがある)なSQLになります。
			</p>
			<source><![CDATA[
select * from employee
where
]]></source>
			<p>
				こういう問題に対応するためには、where句の部分を次のように、 BEGINコメントとENDコメントで囲みます。
			</p>
			<source><![CDATA[
select * from employee
/*BEGIN*/
where
/*IF salaryMin != null*/
salary >= /*salaryMin*/1000
/*END*/
/*IF salaryMax != null*/
and salary <= /*salaryMax*/2000
/*END*/
/*END*/
]]></source>
			<p>
				このようにすると、salaryMinがnullでsalaryMaxがnullではないときは、
				salaryMaxの条件は、BEGINコメントとENDコメントで囲まれた最初の条件なので、
				<code>and</code>
				の部分が自動的に削除されて次のようになります。
			</p>
			<source><![CDATA[
select * from employee
where
salary <= ?
]]></source>
			<p>
				また、salaryMinもsalaryMaxもnullの場合は、
				BEGINコメントとENDコメントで囲まれた部分で1つも条件に一致するものがないので、
				BEGINコメントとENDコメントで囲まれた部分がカットされて次のようになります。
			</p>
			<source><![CDATA[
select * from employee
]]></source>
			<p>
				バインド変数ではなく、SQLに直接リテラルを埋め込むには、 埋め込み変数コメントを使います。
				<br />
				埋め込み変数コメントは、/*$パラメータ名*/のように指定します。
				直接リテラルを埋め込むとSQLインジェクションの危険がありますが、
				埋め込み変数の値に、セミコロン(;)が入っていると例外にしているので、 問題はありません。
			</p>
			<p>
			<code>order by</code>句をパラメータで変えたい場合は、
			/*$orderBy*/と指定します。
			</p>
			<source><![CDATA[
select * from employee order by /*$orderBy*/id
]]></source>
			<p>ELSEコメントは、IFコメントとENDコメントの間に行コメントとして埋め込みます。</p>
			<source><![CDATA[
/*IF jobType != null*/
jobType = /*jobType*/'CLERK'
-- ELSE jobType is null
/*END*/
]]></source>

			<subsection name="SQLファイルのパス">
				<p>
					SQLファイルのパスは、
					<code>examples.entity.Employee.selectAll</code>
					のように指定します。 このパスに対するデフォルトの物理的なファイルは、
					<code>examples/entity/Employee/selectAll.sql</code>
					になります。 ただし、
					<a href="s2jdbc_setup.html#ダイアレクト">ダイアレクト</a>
					のサフィックスに対応するファイルがあれば、 そちらが優先されます。
				</p>
				<p>
					例えば、オラクルを使っている場合、
					<code>
						examples/entity/Employee/selectAll_oracle.sql
					</code>
					があれば、デフォルトより優先されます。
				</p>
			</subsection>

			<subsection name="SQLファイルを使った複数件検索">
				<p>
					SQLファイルを使って複数件検索をする場合は、
					<code>selectBySqlFile()</code>
					と
					<code>getResultList()</code>
					を組み合わせます。
					<code>selectBySqlFile()</code>
					の2番目の引数は、
					<a href="#SQLファイルのパス">SQLファイルのパス</a>
					です。
				</p>
				<p>SQLファイルにパラメータがない場合は、次のようにして呼び出します。</p>
				<source><![CDATA[
List<EmployeeDto> results = jdbcManager.selectBySqlFile(
    EmployeeDto.class, "examples.entity.Employee.selectAll")
    .getResultList();
]]></source>
				<p>
					SQLファイルのパラメータが1つの場合は、
					<code>selectBySqlFile()</code>
					の3番目の引数で値を直接指定します。
				</p>
				<source><![CDATA[
List<EmployeeDto> results = jdbcManager.selectBySqlFile(
    EmployeeDto.class, "examples.entity.Employee.selectAll", 10)
    .getResultList();
]]></source>
				<p>
					SQLファイルのパラメータが複数の場合は、
					<code>selectBySqlFile()</code>
					の3番目の引数をJavaBeansにして、
					パラメータの名前とJavaBeansのプロパティ名を一致させます。
				</p>
				<source><![CDATA[
package examples.entity.Employee;

public class SelectAllParam {
    public BigDecimal salaryMin;
    public BigDecimal salaryMax;
}
]]></source>
				<source><![CDATA[
select * from employee where
salary <= /*salaryMin*/1000
and salary >= /*salaryMax*/2000
]]></source>
				<source><![CDATA[
SelectAllParam param = new SelectAllParam();
param.salaryMin = new BigDecimal(1200);
param.salaryMax = new BigDecimal(1800);
List<EmployeeDto> results = jdbcManager.selectBySqlFile(
    EmployeeDto.class, "examples.entity.Employee.selectAll", param)
    .getResultList();
]]></source>
				<p>
					パラメータ用のJavaBeansにlimit、offsetという名前のプロパティがあれば、
					ページングが行なわれます。
				</p>
				<div
					style="background-color: red; font-weight: bold; font-size: larger;">
					<p>
						limit,
						offsetはパラメータ用のJavaBeansのプロパティの予約語なので注意してください。
					</p>
				</div>
				<p>
				結果を<code>Map</code>で受け取ることもできます。
				</p>
				<source><![CDATA[
List<RowMap> results = jdbcManager.selectBySqlFile(
    RowMap.class, "examples.entity.Employee.selectAll")
    .getResultList();
]]></source>
				<p>
				RowMapはMap&lt;String, Object&gt;なクラスで、
				存在しないキーにアクセスすると
				例外が発生します。
				キーの値は、AAA_BBBのような'_'記法の値ををaaaBbbのようなキャメル記法に
				変換したものです。
				</p>
				<p>
					このルールは、convention.diconで指定されている
					<code>
						org.seasar.framework.convention.impl.PersistenceNamingConventionImpl
					</code>
					のfromColumnNameToPropertyName()の実装を変えることで、カスタマイズすることができます。
				</p>
			</subsection>

			<subsection name="SQLファイルを使った1件検索">
				<p>
					SQLファイルを使って1件検索をする場合は、
					<code>selectBySqlFile()</code>
					と
					<code>getSingleResult()</code>
					を組み合わせます。
					<code>selectBySqlFile()</code>
					の2番目の引数は、
					<a href="#SQLファイルのパス">SQLファイルのパス</a>
					です。
				</p>
				<p>SQLファイルにパラメータがない場合は、次のようにして呼び出します。</p>
				<source><![CDATA[
EmployeeDto result = jdbcManager.selectBySqlFile(
    EmployeeDto.class, "examples.entity.Employee.selectSingle")
    .getSingleResult();
]]></source>
				<p>
					SQLファイルのパラメータが1つの場合は、
					<code>selectBySqlFile()</code>
					の3番目の引数で値を直接指定します。
				</p>
				<source><![CDATA[
EmployeeDto result = jdbcManager.selectBySqlFile(
    EmployeeDto.class, "examples.entity.Employee.selectSingle", 10)
    .getSingleResult();
]]></source>
				<p>
					SQLファイルのパラメータが複数の場合は、
					<code>selectBySqlFile()</code>
					の3番目の引数をJavaBeansにして、
					パラメータの名前とJavaBeansのプロパティ名を一致させます。
				</p>
				<p>
					パラメータ用のJavaBeansにlimit、offsetという名前のプロパティがあれば、
					ページングが行なわれます。
				</p>
				<div
					style="background-color: red; font-weight: bold; font-size: larger;">
					<p>
						limit,
						offsetはパラメータ用のJavaBeansのプロパティの予約語なので注意してください。
					</p>
				</div>
				<p>
				結果を<code>Map</code>で受け取ることもできます。
				</p>
				<source><![CDATA[
RowMap result = jdbcManager.selectBySqlFile(
    RowMap.class, "examples.entity.Employee.selectSingle")
    .getSingleResult();
]]></source>
				<p>
				RowMapはMap&lt;String, Object&gt;なクラスで、
				存在しないキーにアクセスすると
				例外が発生します。
				キーの値は、AAA_BBBのような'_'記法の値ををaaaBbbのようなキャメル記法に
				変換したものです。
				</p>
				<p>
					このルールは、convention.diconで指定されている
					<code>
						org.seasar.framework.convention.impl.PersistenceNamingConventionImpl
					</code>
					のfromColumnNameToPropertyName()の実装を変えることで、カスタマイズすることができます。
				</p>
			</subsection>
			
			<subsection name="SQLファイルを使ったページング">
				<p>
					ページングを指定する場合は、
					<code>limit(), offset()</code>
					を使います。
					<code>limit()</code>
					には、取得する行数を指定します。
					<code>offset()</code>
					には、最初に取得する行の位置を指定します。 最初の行の位置は0になります。
					ページングを指定するには、必ず<code>ordey by</code>句が必要です。
					order by句で指定するカラムは、selectリストにも含めるようにしてください。
				</p>
				<source><![CDATA[
select id, name, ... from employee order by name
]]></source>
				<source><![CDATA[
jdbcManager.selectBySqlFile(EmployeeDto.class,
    "examples.entity.Employee.selectAll")
    .limit(100)
    .offset(10)
    .getResultList();
]]></source>
			</subsection>

			<subsection name="SQLファイルを使った更新">
				<p>
					SQLファイルを使ってエンティティを更新する場合は、
					<code>updateBySqlFile()</code>
					、
					<code>execute()</code>
					を組み合わせます。 挿入、削除も
					<code>updateBySqlFile()</code>
					を使います。
				</p>
				<p>SQLファイルにパラメータがない場合は、次のようにして呼び出します。</p>
				<source><![CDATA[
int count = jdbcManager.updateBySqlFile(
    "examples.entity.Employee.update")
    .execute();
]]></source>
				<p>
					SQLファイルのパラメータが1つで値が
					<code>null</code>
					にならない場合は、
					<code>updateBySqlFile()</code>
					の2番目の引数で値を直接指定します。
				</p>
				<source><![CDATA[
int count = jdbcManager.updateBySqlFile(
    "examples.entity.Employee.update", 10)
    .execute();
]]></source>
				<p>
					上記以外の場合は、
					<code>updateBySqlFile()</code>
					の2番目の引数をJavaBeansにして、
					パラメータの名前とJavaBeansのプロパティ名を一致させます。
				</p>
				<source><![CDATA[
package examples.entity.Employee;

public class UpdateParam {
    public Integer id;
    public BigDecimal salary;
}
]]></source>
				<source><![CDATA[
update emp set salary = /*salary*/1000
where id = /*id*/1
]]></source>
				<source><![CDATA[
UpdateParam param = new UpdateParam();
param.salary = new BigDecimal(1200);
param.id = 10;
int count = jdbcManager.updateBySqlFile(
    "examples.entity.Employee.update", param)
    .execute();
]]></source>
			</subsection>

			<subsection name="SQLファイルを使ったバッチ更新">
				<p>
					SQLファイルを使ってエンティティをバッチ更新する場合は、
					<code>updateBatchBySqlFile()</code>
					、
					<code>execute()</code>
					を組み合わせます。 挿入、削除も
					<code>updateBatchBySqlFile()</code>
					を使います。
				</p>
				<p>
					SQLファイルのパラメータが1つで値が
					<code>null</code>
					にならない場合は、
					<code>updateBatchBySqlFile()</code>
					の2番目の引数で値のリストを指定します。
				</p>
				<source><![CDATA[
List<Integer> paramList = new ArrayList<Integer>();
...
int[] countArray = jdbcManager.updateBatchBySqlFile(
    "examples.entity.Employee.update", paramList)
    .execute();
]]></source>
				<p>
					上記以外の場合は、
					<code>updateBatchBySqlFile()</code>
					の2番目の引数を、 JavaBeansのリストあるいは配列(可変長引数)にして、
					パラメータの名前とJavaBeansのプロパティ名を一致させます。
				</p>
				<source><![CDATA[
package examples.entity.Employee;

public class UpdateParam {
    public Integer id;
    public BigDecimal salary;
}
]]></source>
				<source><![CDATA[
update emp set salary = /*salary*/1000
where id = /*id*/1
]]></source>
				<source><![CDATA[
List<UpdateParam> paramList = new ArrayList<UpdateParam>();
...
int[] countArray = jdbcManager.updateBatchBySqlFile(
    "examples.entity.Employee.update", paramList)
    .execute();
]]></source>
			</subsection>

			<subsection name="SQLファイルを使ったプロシージャ呼び出し">
				<p>
					SQLファイルを使ってプロシージャを呼び出す場合は、
					<code>callBySqlFile()</code>
					、
					<code>call()</code>
					を組み合わせます。
					<code>callBySqlFile()</code>
					の最初の引数は、
					<a href="#SQLファイルのパス">SQLファイルのパス</a>
					です。 最初の例は、パラメータのない場合です。
				</p>
				<source><![CDATA[
jdbcManager.callBySqlFile("examples.entity.Employee.callMyProc").call();
]]></source>
				<p>
					INのパラメータが1つだけで、そのパラメータが
					<code>null</code>
					にならない場合は、
					<code>callBySqlFile()</code>
					の2番目の引数で値を直接指定します。
				</p>
				<source><![CDATA[
jdbcManager.callBySqlFile("examples.entity.Employee.callMyProc", "hoge").call();
]]></source>
				<p>
					上記以外の場合は、
					<code>callBySqlFile()</code>
					の2番目の引数にJavaBeansを指定します。
					プロシージャを呼び出すパラメータの順番にJavaBeansのフィールドを定義します。
					<br />
					<ul>
						<li>
							<p>
								フィールド名が_OUTで終わっている場合
								<code>OUT</code>
								パラメータになります。
							</p>
						</li>
						<li>
							<p>
								フィールド名が_IN_OUTで終わっている場合
								<code>IN OUT</code>
								パラメータになります。
							</p>
						</li>
						<li>
							<p>
								フィールド名が_INで終わっている場合
								<code>IN</code>
								パラメータになります。
							</p>
						</li>
						<li>
							<p>
								フィールド名が_OUT、_IN_OUT、_INで終わっていない場合は、
								<code>IN</code>
								パラメータになります。
							</p>
						</li>
					</ul>
				</p>
				<source><![CDATA[
public class MyDto {

    public String result_OUT;
    
    public int arg1_IN_OUT;
    
    public int arg2_IN;
}
]]></source>
				<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1_IN_OUT = 1;
dto.arg2_IN = 2;
jdbcManager.callBySqlFile("examples.entity.Employee.callMyProc", dto).call();
System.out.println(dto.result_OUT);
System.out.println(dto.arg1_IN_OUT);
]]></source>
				<p>
					プロシージャが結果セットを返す場合は、対応するフィールドの型をList&lt;結果セットに対応する型&gt;にします。
				</p>
				<source><![CDATA[
public class MyDto {

    public List<EmployeeDto> result_OUT;
    
    public int arg1_IN;
}
]]></source>
				<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1_IN = 1;
jdbcManager.callBySqlFile("examples.entity.Employee.callMyProc", dto).call();
System.out.println(dto.result_OUT);
]]></source>
			<p>
			オラクルとMySQL以外は、結果セットの受け取りをパラメータで定義する必要はありません。
			JavaBeansの最初のフィールドを結果セット用に定義し、
			2番目以降をパラメータに対応したフィールドにします。
			</p>
			<source><![CDATA[
public class MyDto {

    public List<EmployeeDto> result_OUT;
    
    public int arg1_IN;
}
]]></source>
			<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1_IN = 1;
jdbcManager.callBySql("{call myproc(?)}", dto).call();
System.out.println(dto.result_OUT);
]]></source>
			</subsection>
		</section>
	</body>
</document>
