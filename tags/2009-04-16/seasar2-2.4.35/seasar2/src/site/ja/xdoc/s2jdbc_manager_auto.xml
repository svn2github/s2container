<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<title>S2JDBC - JdbcManager - SQL自動生成による操作</title>
	</properties>
	<body>
		<section name="SQL自動生成による操作">
			<ul>
				<li>
					<a href="#検索">検索</a>
					<ul>
						<li>
							<a href="#複数件検索">複数件検索</a>
						</li>
						<li>
							<a href="#1件検索">1件検索</a>
						</li>
						<li>
							<a href="#イテレーションによる検索">イテレーションによる検索</a>
						</li>
						<li>
							<a href="#検索結果の行数取得">検索結果の行数取得</a>
						</li>
						<li>
							<a href="#結合">結合</a>
							<ul>
								<li>
									<a href="#結合条件の追加">
										結合条件の追加
									</a>
								</li>
								<li>
									<a href="#結合のネスト">結合のネスト</a>
								</li>
							</ul>
						</li>
						<li>
							<a href="#検索条件">検索条件</a>
							<ul>
								<li>
									<a href="#IDとバージョンによる指定">
										IDとバージョンによる指定
									</a>
								</li>
								<li>
									<a href="#SQL文字列による指定">
										SQL文字列による指定
									</a>
								</li>
								<li>
									<a href="#SimpleWhereによる指定">
										SimpleWhereによる指定
									</a>
								</li>
								<li>
									<a href="#Mapによる指定">
										Mapによる指定
									</a>
								</li>
							</ul>
						</li>
						<li>
							<a href="#ソート順">ソート順</a>
						</li>
						<li>
							<a href="#排他制御">排他制御</a>
						</li>
						<li>
							<a href="#指定したプロパティをフェッチ対象にする">指定したプロパティをフェッチ対象にする</a>
						</li>
						<li>
							<a href="#ページング">ページング</a>
						</li>
						<li>
							<a href="#最大行数">最大行数</a>
						</li>
						<li>
							<a href="#フェッチサイズ">フェッチサイズ</a>
						</li>
						<li>
							<a href="#クエリタイムアウト">クエリタイムアウト</a>
						</li>
						<li>
							<a href="#ヒント">ヒント</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#挿入">挿入</a>
					<ul>
						<li>
							<a href="#1件挿入">1件挿入</a>
						</li>
						<li>
							<a href="#バッチ挿入">バッチ挿入</a>
						</li>
						<li>
							<a href="#nullの項目を挿入しない">
								nullの項目を挿入しない
							</a>
						</li>
						<li>
							<a href="#指定したプロパティのみを挿入対象にする">
								指定したプロパティのみを挿入対象にする
							</a>
						</li>
						<li>
							<a href="#指定したプロパティを挿入対象から除外する">
								指定したプロパティを挿入対象から除外する
							</a>
						</li>
						<li>
							<a href="#バッチ挿入のサイズを指定する">
								バッチ挿入のサイズを指定する
							</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#更新">更新</a>
					<ul>
						<li>
							<a href="#1件更新">1件更新</a>
						</li>
						<li>
							<a href="#バッチ更新">バッチ更新</a>
						</li>
						<li>
							<a href="#バージョンプロパティを通常の更新対象にする">
								バージョンプロパティを通常の更新対象にする
							</a>
						</li>
						<li>
							<a href="#nullの項目を更新しない">
								nullの項目を更新しない
							</a>
						</li>
						<li>
							<a href="#指定したプロパティのみを更新対象にする">
								指定したプロパティのみを更新対象にする
							</a>
						</li>
						<li>
							<a href="#指定したプロパティを更新対象から除外する">
								指定したプロパティを更新対象から除外する
							</a>
						</li>
						<li>
							<a href="#変更のあったプロパティのみを更新対象にする">
								変更のあったプロパティのみを更新対象にする
							</a>
						</li>
						<li>
							<a href="#更新行数をチェックしない">更新行数をチェックしない</a>
						</li>
						<li>
							<a href="#バッチ更新のサイズを指定する">
								バッチ更新のサイズを指定する
							</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#削除">削除</a>
					<ul>
						<li>
							<a href="#1件削除">1件削除</a>
						</li>
						<li>
							<a href="#バッチ削除">バッチ削除</a>
						</li>
						<li>
							<a href="#バージョンをチェックしないで削除する">
								バージョンをチェックしないで削除する
							</a>
						</li>
						<li>
							<a href="#削除行数をチェックしない">削除行数をチェックしない</a>
						</li>
						<li>
							<a href="#バッチ削除のサイズを指定する">
								バッチ削除のサイズを指定する
							</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#ストアドの呼び出し">ストアドの呼び出し</a>
					<ul>
						<li>
							<a href="#ストアドプロシージャの呼び出し">
								ストアドプロシージャの呼び出し
							</a>
						</li>
						<li>
							<a href="#ストアドファンクションの呼び出し">
								ストアドファンクションの呼び出し
							</a>
						</li>
					</ul>
				</li>
			</ul>
		</section>

		<section name="検索">
			<subsection name="複数件検索">
				<p>
					複数件を検索する場合は、
					<code>gerResultList()</code>
					を使います。
				</p>
				<source><![CDATA[
List<Employee> results = jdbcManager.from(Employee.class).getResultList();
]]></source>
				<p>
					検索するエンティティは、
					<code>from()</code>
					で指定します。
				</p>
				<p>
					デフォルトでは、結果がなかった場合は、 空の
					<code>List</code>
					が返されます。
					<code>disallowNoResult()</code>
					を呼び出すと、 結果がなかった場合は
					<code>javax.persistence.NoResultException
					</code>
					が発生します。
				</p>
				<source><![CDATA[
List<Employee> results = jdbcManager.from(Employee.class)
                                    .disallowNoResult()
                                    .getResultList();
]]></source>
			</subsection>

			<subsection name="1件検索">
				<p>
					1件検索する場合は、
					<code>getSingleResult()</code>
					を使います。
				</p>
				<source><![CDATA[
Employee result = jdbcManager.from(Employee.class).getSingleResult();
]]></source>
				<p>
					結果が複数件になる場合は、
					<code>
						javax.persistence.NonUniqueResultException
					</code>
					が発生します。
				</p>
				<source><![CDATA[
Employee result = jdbcManager.from(Employee.class)
                             .where("id = ?", id)
                             .getSingleResult();
]]></source>
				<p>
					デフォルトでは、結果がなかった場合は、
					<code>null</code>
					が返されます。
					<code>disallowNoResult()</code>
					を呼び出すと、 結果がなかった場合は
					<code>javax.persistence.NoResultException
					</code>
					が発生します。
				</p>
				<source><![CDATA[
Employee result = jdbcManager.from(Employee.class)
                             .where("id = ?", id)
                             .disallowNoResult()
                             .getSingleResult();
]]></source>
			</subsection>

			<subsection name="イテレーションによる検索">
				<p>
					検索結果が多くの行を返すため、
					<code>List</code>
					でまとめて受け取ることが困難な場合は
					<code>iterate(IterationCallback)</code>
					を使います。
				</p>
				<source><![CDATA[
int count = results = jdbcManager
    .from(Employee.class)
    .iterate(new IterationCallback<BeanMap, Integer>() {
        int count;
        public Integer iterate(BeanMap map, IterationContext context) {
            if (...) {
                ++count;
            }
            return count;
        }
    });
]]></source>
				<p>
					<code>iterate(IterationCallback)</code>
					の引数には、 次のインターフェースを実装したクラスのインスタンスを渡します。
				</p>
				<ul>
					<li>
						<code>
							org.seasar.extension.jdbc.IterationCallback&lt;ENTITY,
							RESULT&gt;
						</code>
					</li>
				</ul>
				<p>
					<code>ENTITY</code>
					は
					<code>from()</code>
					で指定したエンティティクラス、
					<code>RESULT</code>
					は
					<code>iterate(IterationCallback)</code>
					が返す結果の型を指定します。
				</p>
				<p>
					<code>from()</code>
					で指定したエンティティ1件ごとに次のメソッドがコールバックされます。
				</p>
				<ul>
					<li>
						<code>
							RESULT iterate(ENTITY entity,
							IterationContext context)
						</code>
					</li>
				</ul>
				<p>
					コールバックメソッドが最後に返した値が
					<code>iterate(IterationCallback)</code>
					の戻り値となります。
				</p>
				<p>
					コールバックメソッドの第2引数で渡される
					<code>
						org.seasar.extension.jdbc.IterationContext
					</code>
					の
					<code>exit</code>
					プロパティを
					<code>true</code>
					にすると、 問い合わせ結果のイテレーションは終了となり、 検索結果の残りは無視されます。
					その時の戻り値が
					<code>iterate(IterationCallback)</code>
					の戻り値となります。
				</p>
				<p>
					1対多関連を
					<a href="#結合">結合</a>
					する場合は、
					<code>from()</code>
					で指定したエンティティで
					<a href="#ソート順">ソート</a>
					して、結果セットが次のような順になるようにします。
				</p>
				<table border="1">
					<tr>
						<th>
							<code>from()</code>
							で指定したエンティティ
						</th>
						<th>結合したエンティティ</th>
					</tr>
					<tr>
						<td>A1</td>
						<td>B1</td>
					</tr>
					<tr>
						<td>A1</td>
						<td>B2</td>
					</tr>
					<tr>
						<td>A2</td>
						<td>B1</td>
					</tr>
					<tr>
						<td>A2</td>
						<td>B2</td>
					</tr>
				</table>
				<p>
					上記のような結果セットの場合、 コールバックメソッドはA1とA2が1回ずつ、 計2回呼び出されます。
					A1に関連づけられたB1およびB2のインスタンスと、
					A2に関連づけられたB1およびB2のインスタンスは異なります(同じ値を持つが同一ではない)。
				</p>
				<table border="1">
					<tr>
						<th>
							<code>from()</code>
							で指定したエンティティ
						</th>
						<th>結合したエンティティ</th>
					</tr>
					<tr>
						<td>A1</td>
						<td>B1</td>
					</tr>
					<tr>
						<td>A2</td>
						<td>B1</td>
					</tr>
					<tr>
						<td>A1</td>
						<td>B2</td>
					</tr>
					<tr>
						<td>A2</td>
						<td>B2</td>
					</tr>
				</table>
				<p>結果セットが上記のような順になっている場合、 コールバックメソッドは4回呼び出されてしまいます。</p>
			</subsection>

			<subsection name="検索結果の行数取得">
				<p>
					<code>SELECT COUNT(*) ～</code>
					による検索結果の行数を取得する場合は、
					<code>getCount()</code>
					を使います。
				</p>
				<source><![CDATA[
long count = jdbcManager.from(Employee.class).getCount();
]]></source>
				<div class="caution">
					<div>注意点</div>
					<p>
						<code>getCount()</code>
						が返す値は問い合わせ結果の行数であり、 同等の問い合わせを行った場合に
						<a href="#複数件検索">
							<code>getResultList()</code>
						</a>
						が返すエンティティの数と一致するとは限りません。
						<code>from()</code>
						で指定したエンティティに
						<a href="s2jdbc_entity.html#一対多関連定義">1対多関連</a>
						を
						<a href="#結合">結合</a>
						した場合、
						<code>getCount()</code>
						が返す行数は
						<code>getResultList()</code>
						が返すエンティティの数よりも多くなる場合があります。
					</p>
				</div>
			</subsection>

			<subsection name="結合">
				<p>他のエンティティを結合する場合は、次のメソッドを使用します。</p>
				<ul>
					<li>
						<code>innerJoin(CharSequence name)</code>
					</li>
					<li>
						<code>
							innerJoin(CharSequence name, boolean fetch)
						</code>
					</li>
					<li>
						<code>leftOuterJoin(CharSequence name)</code>
					</li>
					<li>
						<code>
							leftOuterJoin(CharSequence name, boolean
							fetch)
						</code>
					</li>
				</ul>
				<p>第1引数は、結合したいエンティティのプロパティ名です。</p>
				<source><![CDATA[
List<Employee> results = jdbcManager.from(Employee.class)
                                    .innerJoin("department").getResultList();
]]></source>
				<p>次のように外部結合にすることもできます。</p>
				<source><![CDATA[
List<Employee> results = jdbcManager.from(Employee.class)
                                    .leftOuterJoin("department").getResultList();
]]></source>
				<p>検索条件には含めたいけど、検索結果には含めたくない場合、 2番名の引数をfalseにします。</p>
				<source><![CDATA[
List<Employee> results = jdbcManager.from(Employee.class)
                                    .innerJoin("department", false)
                                    .where("department.name = 'RESEARCH'")
                                    .getResultList();
]]></source>
				<h4>
					<a name="結合条件の追加">結合条件の追加</a>
				</h4>
				<p>追加の結合条件を指定することもできます。</p>
				<p>追加の結合条件をSQL文字列で指定する場合は、次のメソッドを使用します。</p>
				<ul>
					<li>
						<code>
							innerJoin(CharSequence name, String condition,
							Object... params)
						</code>
					</li>
					<li>
						<code>
							innerJoin(CharSequence name, boolean fetch,
							String condition, Object... params)
						</code>
					</li>
					<li>
						<code>
							leftOuterJoin(CharSequence name, String
							condition, Object... params)
						</code>
					</li>
					<li>
						<code>
							leftOuterJoin(CharSequence name, boolean
							fetch, String condition, Object...
							params)
						</code>
					</li>
				</ul>
				<p>
					引数
					<code>condition</code>
					に指定できる条件は、SQLと同じです。 SQLとの違いは、カラム名の代わりにプロパティ名を書くことです。
					関連先のプロパティを指定する場合は、
					<code>innerJoin()/leftOuterJoin()</code>
					で指定した名前.
					プロパティ名になります。
				</p>
				<source><![CDATA[
List<Department> results = jdbcManager.from(Department.class)
                                    .leftOuterJoin("employee", "employee.salary > ?", 1000)
                                    .getResultList();
]]></source>
				<p>
					指定方法の詳細は「
					<a href="#SQL文字列による指定">SQL文字列による指定</a>
					」を参照してください。
				</p>
				<p>
					追加の結合条件を
					<code>SimpleWhere</code>
					で指定する場合は、次のメソッドを使用します。
				</p>
				<ul>
					<li>
						<code>
							innerJoin(CharSequence name, Where condition)
						</code>
					</li>
					<li>
						<code>
							innerJoin(CharSequence name, boolean fetch,
							Where condition)
						</code>
					</li>
					<li>
						<code>
							leftOuterJoin(CharSequence name, Where
							condition)
						</code>
					</li>
					<li>
						<code>
							leftOuterJoin(CharSequence name, boolean
							fetch, Where condition)
						</code>
					</li>
				</ul>
				<source><![CDATA[
List<Department> results = jdbcManager.from(Department.class)
                                    .leftOuterJoin("employee", 
                                        new SimpleWhere().gt("employee.salary", 1000))
                                    .getResultList();
]]></source>
				<p>
					指定方法の詳細は「
					<a href="#SimpleWhereによる指定">SimpleWhereによる指定</a>
					」を参照してください。
				</p>

				<h4>
					<a name="結合のネスト">結合のネスト</a>
				</h4>
				<p>
					結合は、employee.addressのようにネストすることもできます。
					ネストする場合は、必ずベースとなる結合を先に指定します。
					employee.addressの場合、employeeがベースとなる結合です。
				</p>
				<source><![CDATA[
List<Department> results = jdbcManager.from(Department.class)
                                    .leftOuterJoin("employee")
                                    .leftOuterJoin("employee.address")
                                    .getResultList();
]]></source>
				<p>結合は、多対一関連、一対多関連、一対一関連のどれでも可能で、 いくつでもネストすることが可能です。</p>
			</subsection>

			<subsection name="検索条件">
				<h4>
					<a name="IDとバージョンによる指定">IDとバージョンによる指定</a>
				</h4>
				<p>
					IDプロパティ (主キー) を指定して検索対象を指定する場合は、
					<code>id(Object...)</code>
					を使います。 引数はエンティティに定義されたIDプロパティと同じ数・同じ並びで指定します。
				</p>
				<source><![CDATA[
jdbcManager.from(Department.class)
    .id(100)
    .getSingleResult();
]]></source>
				<p>
					IDと同時にバージョンを指定することもできます。 バージョンプロパティを指定する場合は、
					<code>version(Object)</code>
					を使います。
				</p>
				<source><![CDATA[
jdbcManager.from(Department.class)
    .id(100).version(10)
    .getSingleResult();
]]></source>
				<p>IDを指定しないでバージョンだけを指定することはできません。</p>

				<h4>
					<a name="SQL文字列による指定">SQL文字列による指定</a>
				</h4>
				<p>
					より複雑な検索条件を指定する場合は、
					<code>where(String criteria, Object... params)</code>
					を使います。
					<code>where(String criteria, Object... params)</code>
					に書くことのできる条件は、SQLと同じです。
					SQLとの違いは、カラム名の代わりにプロパティ名を書くことです。
					関連先のプロパティを指定する場合は、
					<code>innerJoin()/leftOuterJoin()</code>
					で指定した名前.プロパティ名になります。
				</p>
				<source><![CDATA[
jdbcManager.from(Department.class)
    .leftOuterJoin("employeeList")
    .leftOuterJoin("employeeList.address")
    .where("employeeList.salary between ? and ? and employeeList.address.street like ?", ...)
    .getResultList();
]]></source>
				<p>
					<code>java.util.Date</code>
					・
					<code>java.util.Calendar</code>
					型のパラメータを指定する場合は、時制を指定することができます。 時制の指定は
					<code>org.seasar.extension.jdbc.parameter.Parameter</code>
					のstaticメソッドを使います。
				</p>
				<dl>
					<dt>
						<code>date(Date)</code>
						または
						<code>date(Calendar)</code>
					</dt>
					<dd>パラメータをSQL標準のDATE型 (日付のみ) として扱います。</dd>
					<dt>
						<code>time(Date)</code>
						または
						<code>time(Calendar)</code>
					</dt>
					<dd>パラメータをSQL標準のTIME型 (時刻のみ) として扱います。</dd>
					<dt>
						<code>timestamp(Date)</code>
						または
						<code>timestamp(Calendar)</code>
					</dt>
					<dd>パラメータをSQL標準のTIMESTAMP型 (日付と時刻) として扱います。</dd>
				</dl>
				<source><![CDATA[
import static org.seasar.extension.jdbc.parameter.Parameter.*;

jdbcManager.from(Employee.class)
    .where("heredate = ?", date(heredate))
    .getResultList();
]]></source>
				<p>
					<code>byte[]</code>
					・
					<code>String</code>
					型のパラメータを指定する場合は、ラージオブジェクトであることを指定することができます。
					ラージオブジェクトの指定は
					<code>
						org.seasar.extension.jdbc.parameter.Parameter
					</code>
					のstaticメソッドを使います。
				</p>
				<dl>
					<dt>
						<code>lob(String)</code>
					</dt>
					<dd>パラメータをCLOBとして扱います。</dd>
					<dt>
						<code>lob(byte[])</code>
						または
						<code>lob(Serializable)</code>
					</dt>
					<dd>パラメータをBLOBとして扱います。</dd>
				</dl>
				<source><![CDATA[
import static org.seasar.extension.jdbc.parameter.Parameter.*;

jdbcManager.from(Employee.class)
    .where("largeName = ?", lob(largeName))
    .getResultList();
]]></source>

				<h4>
					<a name="SimpleWhereによる指定">SimpleWhereによる指定</a>
				</h4>
				<p>
					検索条件の入力画面などでは、ユーザの入力があった部分をandでつないで、
					条件を組み立てるということが良く行われます。 このようなケースを簡単に処理するために、
					SimpleWhereとMapでも、検索条件を指定できるようにしています。
				</p>
				<p>
					名前、仕事タイプ、給与の上限下限を条件に検索する画面を考えてみましょう。
					べたに検索条件を組み立てるとはこんな感じになるはずです。
				</p>
				<source><![CDATA[
public String departmentName;
public String[] jobTypes = new String[0];
public BigDecimal salaryMax;
public BigDecimal salaryMin;
...
StringBuilder sb = new StringBuilder(100);
boolean found = false;
List<Object> values = new ArrayList<Object>();
if (departmentName != null) {
    sb.append("department.name = ?");
    values.add(departmentName);
    found = true;
}
if (jobTypes.length > 0) {
    if (found) {
        sb.append(" and ");
    }
    sb.append("jobType in (");
    for (JobType jt : jobTypes) {
        sb.append("?, ");
        values.add(jt);
    }
    sb.setLength(sb.length() - 2);
    sb.append(")");
    found = true;
}
if (salaryMin != null) {
    if (found) {
        sb.append(" and ");
    }
    sb.append("salary >= ?");
    values.add(salaryMin);
    found = true;
}
if (salaryMax != null) {
    if (found) {
        sb.append(" and ");
    }
    sb.append("salary <= ?");
    values.add(salaryMax);
    found = true;
}
jdbcManager.from(Employee.class).where(sb.toString(), values.toArray()).getResultList();
]]></source>
				<p>SimpleWhereを使って組み立てれば、こんなに簡単になります。</p>
				<source><![CDATA[
public String departmentName;
public String[] jobTypes = new String[0];
public BigDecimal salaryMax;
public BigDecimal salaryMin;
...
jdbcManager.from(Employee.class)
    .where(new SimpleWhere()
        .eq("department.name", departmentName)
        .in("jobType", jobTypes)
        .ge("salary", salaryMin)
        .le("salary", salaryMax))
    .getResultList();
]]></source>
				<p>SimpleWhereには次のメソッドがあります。</p>
				<table border="1">
					<tbody>
						<tr>
							<th>メソッド</th>
							<th>説明</th>
						</tr>
						<tr>
							<td>
								<code>eq(CharSequence propertyName, Object value)</code>
							</td>
							<td>
								<code>propertyName = ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>ne(CharSequence propertyName, Object value)</code>
							</td>
							<td>
								<code>propertyName &lt;&gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>lt(CharSequence propertyName, Object value)</code>
							</td>
							<td>
								<code>propertyName &lt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>le(CharSequence propertyName, Object value)</code>
							</td>
							<td>
								<code>propertyName &lt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>gt(CharSequence propertyName, Object value)</code>
							</td>
							<td>
								<code>propertyName &gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>ge(CharSequence propertyName, Object value)</code>
							</td>
							<td>
								<code>propertyName &gt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>in(CharSequence propertyName, Object... values)</code>
							</td>
							<td>
								<code>propertyName in (?, ...)</code>
								の条件を追加します。 valuesがnullの時または配列の長さが0の時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>in(CharSequence propertyName, Collection&lt;?&gt; values)</code>
							</td>
							<td>
								<code>propertyName in (?, ...)</code>
								の条件を追加します。 valuesがnullの時またはリストの長さが0の時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>notIn(CharSequence propertyName, Object... values)</code>
							</td>
							<td>
								<code>
									propertyName not in (?, ...)
								</code>
								の条件を追加します。 valuesがnullの時または配列の長さが0の時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>notIn(CharSequence propertyName, Collection&lt;?&gt; values)</code>
							</td>
							<td>
								<code>
									propertyName not in (?, ...)
								</code>
								の条件を追加します。 valuesがnullの時またはリストの長さが0の時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>like(CharSequence propertyName, String value)</code>
							</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>like(CharSequence propertyName, String value, char escape)</code>
							</td>
							<td>
								<code>
									propertyName like ? escape ?
								</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>notLike(CharSequence propertyName, String value)</code>
							</td>
							<td>
								<code>propertyName not like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>notLike(CharSequence propertyName, String value, char escape)</code>
							</td>
							<td>
								<code>
									propertyName not like ? escape ?
								</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>starts(CharSequence propertyName, String value)</code>
							</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最後に自動的に
								<code>%</code>
								が追加されます。 valueに
								<code>'%', '_'</code>
								が含まれる場合はエスケープされます。
							</td>
						</tr>
						<tr>
							<td>
								<code>notStarts(CharSequence propertyName, String value)</code>
							</td>
							<td>
								<code>propertyName not like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最後に自動的に
								<code>%</code>
								が追加されます。 valueに
								<code>'%', '_'</code>
								が含まれる場合はエスケープされます。
							</td>
						</tr>
						<tr>
							<td>
								<code>ends(CharSequence propertyName, String value)</code>
							</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初に自動的に
								<code>%</code>
								が追加されます。 valueに
								<code>'%', '_'</code>
								が含まれる場合はエスケープされます。
							</td>
						</tr>
						<tr>
							<td>
								<code>notEnds(CharSequence propertyName, String value)</code>
							</td>
							<td>
								<code>propertyName not like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初に自動的に
								<code>%</code>
								が追加されます。 valueに
								<code>'%', '_'</code>
								が含まれる場合はエスケープされます。
							</td>
						</tr>
						<tr>
							<td>
								<code>contains(CharSequence propertyName, String value)</code>
							</td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初と最後に自動的に
								<code>%</code>
								が追加されます。 valueに
								<code>'%', '_'</code>
								が含まれる場合はエスケープされます。
							</td>
						</tr>
						<tr>
							<td>
								<code>notContains(CharSequence propertyName, String value)</code>
							</td>
							<td>
								<code>propertyName not like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初と最後に自動的に
								<code>%</code>
								が追加されます。 valueに
								<code>'%', '_'</code>
								が含まれる場合はエスケープされます。
							</td>
						</tr>
						<tr>
							<td>
								<code>isNull(CharSequence propertyName, Boolean value)</code>
							</td>
							<td>
								<code>propertyName is null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>isNotNull(CharSequence propertyName, Boolean value)</code>
							</td>
							<td>
								<code>propertyName is not null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
							</td>
						</tr>
						<tr>
							<td>
								<code>excludesWhitespace()</code>
							</td>
							<td>valueが空白文字列の時は条件に追加されません。</td>
						</tr>
					</tbody>
				</table>

				<h4>
					<a name="Mapによる指定">Mapによる指定</a>
				</h4>
				<p>Mapを使うと次のようになります。</p>
				<source><![CDATA[
public String departmentName;
public String[] jobTypes = new String[0];
public BigDecimal salaryMax;
public BigDecimal salaryMin;
...
Map<String, Object> w = new HashMap<String, Object>();
w.put("department.name", departmentName);
w.put("jobType_IN", jobTypes);
w.put("salary_LE", salaryMax);
w.put("salary_GE", salaryMin);
jdbcManager.from(Employee.class).where(w).getResultList();
]]></source>
				<p>
					マップのキーにプロパティ名_サフィックスを指定します。 サフィックスがない場合は、
					<code>_EQ</code>
					が指定されたとみなされます。
				</p>
				<p>次のサフィックスを使うことができます。</p>
				<table border="1">
					<tbody>
						<tr>
							<th>サフィックス</th>
							<th>説明</th>
						</tr>
						<tr>
							<td><code>_EQ</code></td>
							<td>
								<code>propertyName = ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td><code>_NE</code></td>
							<td>
								<code>propertyName &lt;&gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td><code>_LT</code></td>
							<td>
								<code>propertyName &lt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td><code>_LE</code></td>
							<td>
								<code>propertyName &lt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td><code>_GT</code></td>
							<td>
								<code>propertyName &gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td><code>_GE</code></td>
							<td>
								<code>propertyName &gt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td><code>_IN</code></td>
							<td>
								<code>propertyName in (?, ...)</code>
								の条件を追加します。 
								値は配列または
								<code>java.util.Collection</code>
								をサポートしています。
								valueがnullの時または長さが0の時は追加されません。
							</td>
						</tr>
						<tr>
							<td><code>_NOT_IN</code></td>
							<td>
								<code>
									propertyName not in (?, ...)
								</code>
								の条件を追加します。 
								値は配列または
								<code>java.util.Collection</code>
								をサポートしています。
								valueがnullの時または長さが0の時は追加されません。
							</td>
						</tr>
						<tr>
							<td><code>_LIKE</code></td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td><code>_NOT_LIKE</code></td>
							<td>
								<code>propertyName not like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
						</tr>
						<tr>
							<td><code>_STARTS</code></td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最後に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td><code>_NOT_STARTS</code></td>
							<td>
								<code>propertyName not like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最後に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td><code>_ENDS</code></td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td><code>_NOT_ENDS</code></td>
							<td>
								<code>propertyName not like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td><code>_CONTAINS</code></td>
							<td>
								<code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初と最後に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td><code>_NOT_CONTAINS</code></td>
							<td>
								<code>propertyName not like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初と最後に自動的に
								<code>%</code>
								が追加されます。
							</td>
						</tr>
						<tr>
							<td><code>_IS_NULL</code></td>
							<td>
								<code>propertyName is null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
								値はBooleanのみをサポートしています。
							</td>
						</tr>
						<tr>
							<td><code>_IS_NOT_NULL</code></td>
							<td>
								<code>propertyName is not null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
								値はBooleanのみをサポートしています。
							</td>
						</tr>
					</tbody>
				</table>
				<p>
					マップの組み立てを手動でやる必要は、基本的にありません。
					なぜなら、
					<code>SimpleWhere</code>
					のほうが便利だからです。 マップを使う場合は、次のように
					<code>org.seasar.framework.beans.util.Beans</code>
					を使います。
				</p>
				<p>
					<code>
						createAndCopy(Class&lt;T&gt; destClass, Object
						src)
					</code>
					の第一引数には、
					<code>BeanMap.class</code>
					を指定します。
					<code>BeanMap</code>
					は
					<code>Map&lt;String, Object&gt;</code>
					なクラスで、 存在しないキーにアクセスすると 例外が発生します。
					キーの値は、
					<code>AAA_BBB</code>
					のような
					<code>'_'</code>
					記法の値をを
					<code>aaaBbb</code>
					のようなキャメル記法に変換したものです。
					第二引数にはコピー元になるオブジェクトを指定します。
				</p>
				<p>
					<code>prefix(String prefix)</code>
					の引数には、プロパティ名のプレフィックスを指定します。
					プレフィックスを指定した場合、プレフィックスを持つプロパティだけが対象になります。
					プロパティ名がマップのキーに変換されるときに、 プレフィックスは削除され、'$'は'.'に変換されます。
				</p>
				<source><![CDATA[
public String where_department$name;
public String[] where_jobType_IN = new String[0];
public BigDecimal where_salary_LE;
public BigDecimal where_salary_GE;
...
jdbcManager.from(Employee.class)
    .where(Beans.createAndCopy(BeanMap.class, this).prefix("where_").execute())
    .getResultList();
]]></source>
				<!--
					<p>マップを使った場合にはORはサポートされていません。</p>
				-->
			</subsection>

			<subsection name="ソート順">
				<p>
					ソート順を指定する場合は、
					<code>orderBy()</code>
					を使います。
					<code>orderBy()</code>
					に書くことのできる条件は、SQLと同じです。
					SQLとの違いは、カラム名の代わりにプロパティ名を書くことです。
					関連先のプロパティを指定する場合は、
					<code>innerJoin()/leftOuterJoin()</code>
					で指定した名前.プロパティ名になります。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .leftOuterJoin("department")
    .orderBy("name, department.name")
    .getResultList();
]]></source>
				<p>
					<code>orderBy(OrderByItem... orderByItems)</code>
					を使うこともできます。
					<code>OrderByItems</code>
					はソート順のキーとなるプロパティ名と昇順または降順を示すもので、
					<code>org.seasar.extension.jdbc.operation.Operations</code>
					のメソッド
					<code>asc(CharSequence propertyName)</code>
					および
					<code>desc(CharSequence propertyName)</code>
					を使って次のように指定することができます。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .leftOuterJoin("department")
    .orderBy(asc("name"), desc("department.name"))
    .getResultList();
]]></source>
			</subsection>

			<subsection name="排他制御">
				<p>SELECT時にロックを取得する場合は、</p>
				<ul>
					<li>
						<code>forUpdate()</code>
					</li>
					<li>
						<code>
							forUpdate(CharSequence... propertyNames)
						</code>
					</li>
					<li>
						<code>forUpdateNowait()</code>
					</li>
					<li>
						<code>
							forUpdateNowait(CharSequence... propertyNames)
						</code>
					</li>
					<li>
						<code>forUpdateWait(int seconds)</code>
					</li>
					<li>
						<code>
							forUpdateWait(int seconds, CharSequence... propertyNames)
						</code>
					</li>
				</ul>
				<p>
					を使います。 全てのRDBMSでこれらの操作が利用できるわけではありません。
					サポートされていないメソッドを呼び出すと
					<code>UnsupportedOperationException</code>
					がスローされます。
				</p>
				<p>
					<code>forUpdate(String...)</code>
					・
					<code>forUpdateNowait(String...)</code>
					の第1引数および
					<code>forUpdateWait(int, String...)</code>
					の第2引数には、ロック対象となるプロパティ名を指定します。
				</p>
				<p>
					<code>forUpdateWait(int)</code>
					・
					<code>forUpdateWait(int, String...)</code>
					の第1引数では、ロックを獲得できるまでの最大待機時間を秒単位で指定します。
				</p>
				<p>
					以下の例では、<code>Employee</code>と<code>Department</code>を結合していて、
					ロック対象のプロパティが明示されていないので、両テーブルのロックが取得されます。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .leftOuterJoin("department")
    .where("department.name = ?", deptName)
    .forUpdate()
    .getResultList();
]]></source>
				<p>
					以下の例でも<code>Employee</code>と<code>Department</code>を結合していますが、
					指定されたプロパティを持つ<code>Employee</code>のロックのみが取得されます。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .leftOuterJoin("department")
    .where("department.name = ?", deptName)
    .forUpdate("id")
    .getResultList();
]]></source>
				<p>排他制御とページングを組み合わせることはできません。</p>
			</subsection>

			<subsection name="指定したプロパティをフェッチ対象にする">
				<p>
					<a href="s2jdbc_entity.html#フェッチ対象外定義">フェッチ対象外定義</a>
					を指定したプロパティをフェッチ対象にするには、
					<code>eager(CharSequence... propertyNames)</code>
					を使います。
					関連先のプロパティを指定する場合は、
					<code>innerJoin()/leftOuterJoin()</code>
					で指定した名前.プロパティ名になります。
				</p>
				<source><![CDATA[
List<Employee> results = jdbcManager.from(Employee.class)
                                    .eager("largeDto")
                                    .getResultList();
]]></source>
			</subsection>

			<subsection name="ページング">
				<p>
					ページングを指定する場合は、
					<code>limit(), offset()</code>
					を使います。
					<code>limit()</code>
					には、取得する行数を指定します。
					<code>offset()</code>
					には、最初に取得する行の位置を指定します。 最初の行の位置は0になります。
					ページングを指定するには、必ず
					<a href="#ソート順">ソート順</a>
					の指定も必要です。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .orderBy("name")
    .limit(100)
    .offset(10)
    .getResultList();
]]></source>
				<p>排他制御とページングを組み合わせることはできません。</p>
				<p>
					<code>limit()</code>
					で指定する値は問い合わせ結果の行数であり、
					<a href="#複数件検索">
						<code>getResultList()</code>
					</a>
					が返すエンティティの数と一致するとは限りません。
					<code>from()</code>
					で指定したエンティティに
					<a href="s2jdbc_entity.html#一対多関連定義">1対多関連</a>
					を
					<a href="#結合">結合</a>
					した場合、
					<code>getResultList()</code>
					が返すエンティティの数は
					<code>limit()</code>
					で指定した数よりも少なくなる場合があります。
				</p>
			</subsection>

			<subsection name="最大行数">
				<p>
					最大行数を指定する場合は、
					<code>maxRows()</code>
					を使います。 最大行数を超える行は、通知なしに除外されます。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .maxRows(1000)
    .getResultList();
]]></source>
			</subsection>

			<subsection name="フェッチサイズ">
				<p>
					フェッチサイズを指定する場合は、
					<code>fetchSize()</code>
					を使います。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .fetchSize(100)
    .getResultList();
]]></source>
			</subsection>

			<subsection name="クエリタイムアウト">
				<p>
					クエリタイムアウト(秒)を指定する場合は、
					<code>queryTimeout()</code>
					を使います。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .queryTimeout(10)
    .getResultList();
]]></source>
			</subsection>

			<subsection name="ヒント">
				<p>
					コメントによるヒントを指定する場合は、
					<code>hint()</code>
					を使います。
				</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .hint("INDEX(Employee IDX1)")
    .getResultList();
]]></source>
				<p>
					ヒント中のエンティティ名(上記例では
					<code>Employee</code>
					)は別名に置換され、 Oracleでは次のようなコメントがSQLに含まれます。
				</p>
				<source><![CDATA[
/*+ INDEX(T1_ IDX1) */
]]></source>
				<p>ヒント中の関連プロパティ名も別名に置換されます。</p>
				<source><![CDATA[
jdbcManager.from(Employee.class)
    .leftOuterJoin("department")
    .hint("INDEX(department IDX2)")
    .getResultList();
]]></source>
				<p>上記の場合、 Oracleでは次のようなコメントがSQLに含まれます。</p>
				<source><![CDATA[
/*+ INDEX(T2_ IDX2) */
]]></source>
				<p>
					コメントによるヒントをサポートしていないRDBMSの場合、
					<code>hint()</code>
					は無視され、 SQLにコメントは付加されません。
				</p>
			</subsection>
		</section>

		<section name="挿入">
			<subsection name="1件挿入">
				<p>
					エンティティを挿入する場合は、
					<code>insert()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int count = jdbcManager.insert(employee).execute();
]]></source>
				<p>
					引数はエンティティで、戻り値は、更新した行数です。 挿入するときに、識別子を自動設定することができます。
					詳しくは、
					<a href="s2jdbc_entity.html#識別子定義">識別子定義</a>
					を参照してください。
				</p>
				<p>
					一意制約違反によりエンティティ挿入ができなかった場合は、
					<code>javax.persistence.EntityExistsException</code>
					が発生します。
				</p>
			</subsection>

			<subsection name="バッチ挿入">
				<p>
					複数のエンティティをバッチ挿入する場合は、
					<code>insertBatch()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager.insertBatch(employees).execute();
]]></source>
				<p>
					引数はエンティティのリストあるいは配列(可変長引数)で、戻り値は、更新した行数の配列です。
					挿入するときに、識別子を自動設定することができます。 詳しくは、
					<a href="s2jdbc_entity.html#識別子定義">識別子定義</a>
					を参照してください。
				</p>
				<p>
					一意制約違反によりエンティティを挿入ができなかった場合は、
					<code>javax.persistence.EntityExistsException</code>
					が発生します。
				</p>
			</subsection>

			<subsection name="nullの項目を挿入しない">
				<p>
					挿入の対象からnullの項目を除外する場合は、
					<code>excludesNull()</code>
					を使います。 バッチ系の挿入は、すべてのエンティティに同じSQLを適用しなければならないので、
					<code>null</code>
					を除外してバッチ挿入することはできません。
					なぜなら、すべてのエンティティの
					<code>null</code>
					の項目が同じだとは限らないからです。
				</p>
				<source><![CDATA[
int count = jdbcManager.insert(employee).excludesNull().execute();
]]></source>
			</subsection>

			<subsection name="指定したプロパティのみを挿入対象にする">
				<p>
					指定したプロパティのみを挿入対象にする場合は、
					<code>includes()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.insert(employee).includes("id", "name").execute();
]]></source>
			</subsection>

			<subsection name="指定したプロパティを挿入対象から除外する">
				<p>
					指定したプロパティを挿入対象から除外する場合は、
					<code>excludes()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.insert(employee).excludes("version").execute();
]]></source>
			</subsection>

			<subsection name="バッチ挿入のサイズを指定する">
				<p>
					バッチ挿入のサイズを設定するには
					<code>batchSize()</code>
					を使います。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager.insertBatch(employees).batchSize(50).execute();
]]></source>
			</subsection>
		</section>

		<section name="更新">
			<subsection name="1件更新">
				<p>
					エンティティを更新する場合は、
					<code>update()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int count = jdbcManager.update(employee).execute();
]]></source>
				<p>
					引数はエンティティで、戻り値は、更新した行数です。
					更新するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>
					を参照してください。
				</p>
				<div class="catucion">
					<div>注意点</div>
					<p>
						<a href="s2jdbc_entity.html#識別子定義">識別子定義</a>
						のないエンティティは、 SQL自動生成による更新は出来ません。
					</p>
				</div>
			</subsection>

			<subsection name="バッチ更新">
				<p>
					複数のエンティティをバッチ更新する場合は、
					<code>updateBatch()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager.updateBatch(employees).execute();
]]></source>
				<p>
					引数はエンティティのリストあるいは配列(可変長引数)で、戻り値は、更新した行数の配列です。
					更新するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>
					を参照してください。
				</p>
				<div class="caution">
					<div>注意点</div>
					<p>
						<a href="s2jdbc_entity.html#識別子定義">識別子定義</a>
						のないエンティティは、 SQL自動生成によるバッチ更新は出来ません。
					</p>
				</div>
			</subsection>

			<subsection name="バージョンプロパティを通常の更新対象にする">
				<p>
					バージョンプロパティを通常の更新対象に含め、バージョンチェックの対象外にする場合は、
					<code>includesVersion()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.update(employee).includesVersion().execute();
]]></source>
			</subsection>

			<subsection name="nullの項目を更新しない">
				<p>
					更新の対象からnullの項目を除外する場合は、
					<code>excludesNull()</code>
					を使います。 バッチ系の更新は、すべてのエンティティに同じSQLを適用しなければならないので、
					<code>null</code>
					を除外してバッチ更新することはできません。
					なぜなら、すべてのエンティティの
					<code>null</code>
					の項目が同じだとは限らないからです。
				</p>
				<source><![CDATA[
int count = jdbcManager.update(employee).excludesNull().execute();
]]></source>
			</subsection>

			<subsection name="指定したプロパティのみを更新対象にする">
				<p>
					指定したプロパティのみを更新対象にする場合は、
					<code>includes()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.update(employee).includes("id", "name").execute();
]]></source>
			</subsection>

			<subsection name="指定したプロパティを更新対象から除外する">
				<p>
					指定したプロパティを更新対象から除外する場合は、
					<code>excludes()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.updateBatch(employees).excludes("version").execute();
]]></source>
			</subsection>

			<subsection name="変更のあったプロパティのみを更新対象にする">
				<p>
					変更のあったプロパティのみを更新対象にする場合は、
					<code>changedFrom()</code>
					を使います。バッチ系の更新は、すべてのエンティティに同じSQLを適用しなければならないので、
					変更のあったプロパティのみをバッチ更新することはできません。
					なぜなら、変更のあったプロパティがすべてのエンティティで同じだとは限らないからです。
					最初の引数は、変更前の状態を持ったエンティティもしくはマップです。
				</p>
				<source><![CDATA[
Employee before = ...;
int count = jdbcManager.update(employee).changedFrom(before).execute();
]]></source>
				<p>
					<code>JdbcManager#update()</code>
					に渡されたエンティティと，
					<code>changedFrom()</code>
					に渡されたエンティティまたはマップに相違がない場合、SQLは実行されず、
					<code>execute()</code>
					の戻り値の更新行数として0が返されます。
				</p>
			</subsection>

			<subsection name="更新行数をチェックしない">
				<p>
					バージョンによる楽観的排他制御を行う場合、 更新できた行数が0だと
					<code>
						javax.persistence.OptimisticLockException
					</code>
					が発生します。 更新行数を正しく返さないJDBCドライバを使用する場合は、
					<code>suppresOptimisticLockException()</code>
					を呼び出すことで、更新できた行数のチェックを行わなくなります。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager
    .updateBatch(employees)
    .suppresOptimisticLockException()
    .execute();
]]></source>
			</subsection>

			<subsection name="バッチ更新のサイズを指定する">
				<p>
					バッチ更新のサイズを設定するには
					<code>batchSize()</code>
					を使います。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager.updateBatch(employees).batchSize(50).execute();
]]></source>
			</subsection>
		</section>

		<section name="削除">
			<subsection name="1件削除">
				<p>
					エンティティを削除する場合は、
					<code>delete()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int count = jdbcManager.delete(employee).execute();
]]></source>
				<p>
					引数はエンティティで、戻り値は、更新した行数です。
					削除するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>
					を参照してください。
				</p>
				<div class="caution">
					<div>注意点</div>
					<p>
						<a href="s2jdbc_entity.html#識別子定義">識別子定義</a>
						のないエンティティは、 SQL自動生成による削除は出来ません。
					</p>
				</div>
			</subsection>

			<subsection name="バッチ削除">
				<p>
					複数のエンティティをバッチ削除する場合は、
					<code>deleteBatch()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager.deleteBatch(employees).execute();
]]></source>
				<p>
					引数はエンティティのリストあるいは配列(可変長引数)で、戻り値は、更新した行数の配列です。
					削除するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>
					を参照してください。
				</p>
				<div class="caution">
					<div>注意点</div>
					<p>
						<a href="s2jdbc_entity.html#識別子定義">識別子定義</a>
						のないエンティティは、 SQL自動生成によるバッチ削除は出来ません。
					</p>
				</div>
			</subsection>

			<subsection name="バージョンをチェックしないで削除する">
				<p>
					バージョンをチェックしないで削除する場合は、
					<code>ignoreVersion()</code>
					を使います。
				</p>
				<source><![CDATA[
int count = jdbcManager.delete(employee).ignoreVersion().execute();
]]></source>
			</subsection>

			<subsection name="削除行数をチェックしない">
				<p>
					バージョンによる楽観的排他制御を行う場合、 削除できた行数が0だと
					<code>
						javax.persistence.OptimisticLockException
					</code>
					が発生します。 削除行数を正しく返さないJDBCドライバを使用する場合は、
					<code>suppresOptimisticLockException()</code>
					を呼び出すことで、更新できた行数のチェックを行わなくなります。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager
    .deleteBatch(employees)
    .suppresOptimisticLockException()
    .execute();
]]></source>
			</subsection>

			<subsection name="バッチ削除のサイズを指定する">
				<p>
					バッチ削除のサイズを設定するには
					<code>batchSize()</code>
					を使います。
				</p>
				<source><![CDATA[
int[] countArray = jdbcManager.updateDelete(employees).batchSize(50).execute();
]]></source>
			</subsection>
		</section>

		<section name="ストアドの呼び出し">
			<subsection name="ストアドプロシージャの呼び出し">
				<p>
					ストアドプロシージャを呼び出す場合は、
					<code>call()</code>
					と
					<code>execute()</code>
					を組み合わせます。
					<code>call()</code>
					の最初の引数は、 呼び出すストアドプロシージャの名前です。
				</p>
				<p>最初の例は、パラメータのない場合です。</p>
				<source><![CDATA[
jdbcManager.call("myproc").execute();
]]></source>
				<p>
					INのパラメータが1つだけで、そのパラメータが
					<code>null</code>
					にならない場合は、
					<code>call()</code>
					の2番目の引数で値を直接指定します。
				</p>
				<source><![CDATA[
jdbcManager.call("myproc", "hoge").execute();
]]></source>
				<p>
					上記以外の場合は、
					<code>call()</code>
					の2番目の引数にJavaBeansを指定します。
					ストアドプロシージャを呼び出すパラメータの順番にJavaBeansのフィールドを定義します。
				</p>
				<div class="caution">
					<div>注意点</div>
					<p>
						S2JDBCは、ソースコード上に記述したフィールドの順番と、
						コンパイルされた.classファイル内のフィールドの順番が同じになることを前提としていますが、
						これはJavaの仕様では保証されていません．
						SunのJDKやEclipseではソースコード上と.classファイル内のフィールド順は同じになっていますが、
						フィールドの順番が変わってしまう環境ではストアドの呼び出しが失敗します。
						フィールドの順番が変わってしまう環境があった場合は
						<a href="https://www.seasar.org/mailman/listinfo/seasar-user">Seasar-userメーリングリスト</a>
						までお知らせください．
					</p>
				</div>
				<ul>
					<li>
						フィールドにアノテーションが付けられていない場合、
						<code>IN</code>
						パラメータになります。
					</li>
					<li>
						フィールドに
						<code>@Out</code>
						アノテーションが付けられている場合、
						<code>OUT</code>
						パラメータになります。
					</li>
					<li>
						フィールドに
						<code>@InOut</code>
						アノテーションが付けられている場合、
						<code>INOUT</code>
						パラメータになります。
					</li>
					<li>
						フィールドに
						<code>@ResultSet</code>
						アノテーションが付けられている場合、 パラメータ以外で戻される結果セットになります。
						ただし、 OracleやPostgreSQLのように、
						パラメータ以外で結果セットを返すことが出来ないRDBMSの場合は、
						<code>OUT</code>
						パラメータとして扱われます。
					</li>
					<li>
						フィールドに
						<code>@Lob</code>
						が付けられている場合、 そのパラメータはLOBとして扱われます。
						<code>@Lob</code>
						アノテーションは他のアノテーションと組み合わせて使用することが出来ます。
					</li>
				</ul>
				<source><![CDATA[
public class MyDto {
    public String arg1; // 第1引数 (IN)

    @Out
    public String arg2; // 第2引数 (OUT)

    @InOut
    public int arg3;    // 第3引数 (INOUT)

    @ResultSet
    public List<String> result; // 結果セット
}
]]></source>
				<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1 = "hoge";
dto.arg3 = 2;
jdbcManager.call("myproc", dto).execute();
System.out.println(dto.arg2);
System.out.println(dto.arg3);
System.out.println(dto.result);
]]></source>
				<p>
					ストアドプロシージャが複数のカラムを持つ結果セットを返す場合は、
					対応するフィールドの型を
					<code>List&lt;結果セットの行に対応するJavaBeansの型&gt;</code>
					にします。
				</p>
				<source><![CDATA[
public class MyDto {
    public int arg1; // 第1引数 (IN)

    @ResultSet
    public List<EmployeeDto> result; // 結果セット
}
]]></source>
				<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1 = 1;
jdbcManager.call("myproc", dto).execute();
System.out.println(dto.result);
]]></source>
				<p>
					オラクルとPostgreSQLの場合は、結果セットをパラメータで受け取る必要があります。
					これらのRDBMSでは、
					<code>@ResultSet</code>
					アノテーションが付けられたパラメータは
					<code>OUT</code>
					パラメータとして扱われます。
				</p>
				<source><![CDATA[
public class MyDto {
    public int arg1; // 第1引数 (IN)

    @ResultSet
    public List<EmployeeDto> result; // 第2引数 (OUT)
}
]]></source>
				<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1 = 1;
jdbcManager.call("myproc", dto).execute();
System.out.println(dto.result);
]]></source>
			</subsection>

			<subsection name="ストアドファンクションの呼び出し">
				<p>
					ストアドファンクションを呼び出す場合は、
					<code>call()</code>
					と、
					<code>getSingleResult()</code>
					または
					<code>getResultList()</code>
					を組み合わせます。
					<code>call()</code>
					の1番目の引数でストアドファンクションの戻り値の型を指定します。
					2番目の引数でストアドファンクションの名前を指定します。
				</p>
				<source><![CDATA[
String result = jdbcManager.call(String.class, "myfunc")
                           .getSingleResult();
]]></source>
				<p>
					OracleやPostgreSQLのように、
					ストアドファンクションの戻り値で結果セットを返すことが出来る場合は
					<code>getResultList()</code>
					で結果の
					<code>List</code>
					を受け取ります。
					<code>call()</code>
					の1番目の引数で
					<code>List</code>
					の要素の型を指定します。
				</p>
				<source><![CDATA[
List<String> result = jdbcManager.call(String.class, "myfunc")
                                 .getResultList();
]]></source>
				<p>
					結果セットの行が複数のカラムを持つ場合は
					<code>List</code>
					の要素をJavaBeansにします。
				</p>
				<source><![CDATA[
List<MyDto> result = jdbcManager.call(MyDto.class, "myfunc")
                                .getResultList();
]]></source>
				<p>
					INのパラメータが1つだけで、そのパラメータが
					<code>null</code>
					にならない場合は、
					<code>call()</code>
					の3番目の引数で値を直接指定します。
				</p>
				<source><![CDATA[
String result = jdbcManager.call(String.class, "myfunc", "hoge")
                           .getSingleResult();
]]></source>
				<p>
					上記以外の場合は、
					<code>call()</code>
					の3番目の引数にJavaBeansを指定します。
					ストアドファンクションを呼び出すパラメータの順番にJavaBeansのフィールドを定義します。
				</p>
				<div class="caution">
					<div>注意点</div>
					<p>
						S2JDBCは、ソースコード上に記述したフィールドの順番と、
						コンパイルされた.classファイル内のフィールドの順番が同じになることを前提としていますが、
						これはJavaの仕様では保証されていません．
						SunのJDKやEclipseではソースコード上と.classファイル内のフィールド順は同じになっていますが、
						フィールドの順番が変わってしまう環境ではストアドの呼び出しが失敗します。
						フィールドの順番が変わってしまう環境があった場合は
						<a href="https://www.seasar.org/mailman/listinfo/seasar-user">Seasar-userメーリングリスト</a>
						までお知らせください．
					</p>
				</div>
				<ul>
					<li>
						<p>
							フィールドにアノテーションが付けられていない場合、
							<code>IN</code>
							パラメータになります。
						</p>
					</li>
					<li>
						<p>
							フィールドに
							<code>@Out</code>
							アノテーションが付けられている場合、
							<code>OUT</code>
							パラメータになります。
						</p>
					</li>
					<li>
						<p>
							フィールドに
							<code>@InOut</code>
							アノテーションが付けられている場合、
							<code>INOUT</code>
							パラメータになります。
						</p>
					</li>
					<li>
						<p>
							フィールドに
							<code>@ResultSet</code>
							アノテーションが付けられている場合、 パラメータ以外で戻される結果セットになります。
							ただし、 OracleやPostgreSQLのように、
							パラメータ以外で結果セットを返すことが出来ないRDBMSの場合は、
							<code>OUT</code>
							パラメータとして扱われます。
						</p>
					</li>
					<li>
						<p>
							フィールドに
							<code>@Lob</code>
							が付けられている場合、 そのパラメータはLOBとして扱われます。
							<code>@Lob</code>
							アノテーションは他のアノテーションと組み合わせて使用することが出来ます。
						</p>
					</li>
				</ul>
				<source><![CDATA[
public class MyDto {
    public String arg1; // 第1引数 (IN)

    @Out
    public String arg2; // 第2引数 (OUT)

    @InOut
    public int arg3;    // 第3引数 (INOUT)

    @ResultSet
    public List<String> result; // 結果セット
}
]]></source>
				<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1 = "hoge";
dto.arg3 = 2;
String result = jdbcManager.call(String.class, "myproc", dto)
                           .getSingleResult();
System.out.println(result);
System.out.println(dto.arg1);
System.out.println(dto.arg3);
System.out.println(dto.result);
]]></source>
				<p>
					ストアドファンクションが複数のカラムを持つ結果セットを返す場合は、
					対応するフィールドの型を
					<code>List&lt;結果セットの行に対応するJavaBeansの型&gt;</code>
					にします。
				</p>
				<source><![CDATA[
public class MyDto {
    public int arg1; // 第1引数 (IN)

    @ResultSet
    public List<EmployeeDto> result; // 結果セット
}
]]></source>
				<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1 = 1;
String result = jdbcManager.call(String.class, "myfunc", dto)
                           .getSingleResult();
System.out.println(result);
System.out.println(dto.result);
]]></source>
				<p>
					オラクルとPostgreSQLの場合は、戻り値以外の結果セットをパラメータで受け取る必要があります。
					これらのRDBMSでは、
					<code>@ResultSet</code>
					アノテーションが付けられたパラメータは
					<code>OUT</code>
					パラメータとして扱われます。
				</p>
				<source><![CDATA[
public class MyDto {
    public int arg1; // 第1引数 (IN)

    @ResultSet
    public List<EmployeeDto> result; // 第2引数 (OUT)
}
]]></source>
				<source><![CDATA[
MyDto dto = new MyDto();
dto.arg1 = 1;
String result = jdbcManager.call(String.class, "myfunc", dto)
                           .getSingleResult();
System.out.println(result);
System.out.println(dto.result);
]]></source>
			</subsection>
		</section>
	</body>
</document>
