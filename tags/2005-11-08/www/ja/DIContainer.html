<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- don't edit start -->
<head>
<title>Seasar - DI Container with AOP - </title>
<meta http-equiv="Content-Type" content="text/html; charset=MS932C">
<meta http-equiv="Content-Style-Type" content="text/css">
<link href="seasar_b.css" type="text/css" rel="stylesheet" media="screen">
<link href="seasar_p.css" type="text/css" rel="stylesheet" media="print">
<script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script>
</head><body onload="preload('ja')"><table width="100%" border="0" cellspacing="0" cellpadding="0" align="left"><tr>
<td align="left" valign="top" width="780"><table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr><td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt=""></td></tr>
<tr><td width="235"><img height="117" width="235" src="images/top02_b.gif" alt="Seasar"></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP"></td>
<td colspan="3"><img height="117" width="256" src="images/spacer.gif" alt=""></td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td><a href="http://www.seasar.org/index.html"><img src="images/menu01_b_ja.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)"></a></td>
<td><a href="http://www.seasar.org/projects.html"><img src="images/menu02_b_ja.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)"></a></td>
<td><a href="http://www.seasar.org/products.html"><img src="images/menu03_b_ja.gif" height="30" width="110" border="0" alt="" id="menu03" onmouseover="swap(3)" onmouseout="restore(3)"></a></td>
<td><a href="http://www.seasar.org/resources.html"><img src="images/menu04_b_ja.gif" height="30" width="113" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)"></a></td>
<td><img src="images/menu05_b_ja.gif" height="30" width="109" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)"></td>
<td width="34"><img height="30" width="34" src="images/menu06.gif" alt=""></td></tr><tr>
<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt=""></td></tr></table>
<table  width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr align="left" valign="top"><td width="18"><img height="14" width="18" src="images/spacer.gif" alt=""></td><td width="744" class="main">
<!-- don't edit end -->
<!-- document start -->
            <ul>
              <li><a href="#Quickstart">クイックスタート</a>
             　<ul>
                <li><a href="#FirstStep">最初の一歩</a>
                <li><a href="#NextStep">次の一歩</a>
　　　　　　　　</ul>
              </li>

              <li><a href="#S2ContainerReference">S2Containerリファレンス</a>
                <ul>
                  <li><a href="#CreateFile">作成すべきファイル</a></li>
                  <li><a href="#S2ContainerDefinition">S2Containerの定義</a></li>
                  <li><a href="#S2ContainerCreation">S2Containerの生成</a>
<ul>
<li><a href="#SingletonS2ContainerFactory">SingletonS2ContainerFactoryを使用する</a>
<li><a href="#S2ContainerFactory">S2ContainerFactoryを使用する</a>
</ul>
</li>
                  <li><a href="#getComponent">コンポーネントの取得</a></li>
                  <li><a href="#DIType">Dependency Injectionのタイプ</a>
                    <ul>
                      <li type="circle"><a href="#ConstructorInjection">コンストラクタ・インジェクション</a></li>
                      <li type="circle"><a href="#SetterInjection">セッター・インジェクション</a></li>
                      <li type="circle"><a href="#MethodInjection">メソッド・インジェクション</a></li>
                    </ul>
                  </li>
                  <li><a href="#Include">S2Container定義の分割とインクルード</a></li>
                  <li><a href="#Namespace">名前空間</a></li>
                  <li><a href="#InstanceMode">インスタンス管理</a></li>
                  <li><a href="#Lifecycle">ライフサイクル</a></li>
                  <li><a href="#AutoBindingMode">自動バインディング</a></li>
                  <li><a href="#UseS2Container">コンポーネントでS2Containerを利用する</a></li>
                  <li><a href="#S2ContainerServlet">S2ContainerServlet</a></li>
                  <li><a href="#app.dicon">app.diconの役割</a></li>
                  <li><a href="#Aop">AOPの適用</a></li>
                  <li><a href="#Meta">メタデータ</a></li>
                  <li><a href="#Request">Requestの自動バインディング</a></li>
                  <li><a href="#ComponentAutoRegister">コンポーネントの自動登録</a></li>
                  <li><a href="#AspectAutoRegister">アスペクトの自動登録</a></li>
                  <li><a href="#Hotswap">Hotswap</a></li>
                </ul>
              </li>
              <li><a href="#DefReference">S2Containerタグリファレンス</a>
                <ul>
                  <li><a href="#DOCTYPE">DOCTYPE</a></li>
                  <li><a href="#componentsTag">componentsタグ</a></li>
                  <li><a href="#includeTag">includeタグ</a></li>
                  <li><a href="#componentTag">componentタグ</a></li>
                  <li><a href="#argTag">argタグ</a></li>
                  <li><a href="#propertyTag">propertyタグ</a></li>
                  <li><a href="#metaTag">metaタグ</a></li>
                  <li><a href="#initMethodTag">initMethodタグ</a></li>
                  <li><a href="#destroyMethodTag">destroyMethodタグ</a></li>
                  <li><a href="#aspectTag">aspectタグ</a></li>
                  <li><a href="#descriptionTag">descriptionタグ</a></li>
                  <li><a href="#ognlExpr">OGNL式</a></li>
                </ul>
              </li>
              <li><a href="#AnnotationReference">S2Containerアノテーションリファレンス</a>
                <ul>
                  <li><a href="#ComponentAnnotation">Componentアノテーション</a></li>
                  <li><a href="#BindingAnnotation">Bindingアノテーション</a></li>
                  <li><a href="#AspectAnnotation">Aspectアノテーション</a></li>
                </ul>
              </li>
              <li><a href="DIContainerExercise.html">DIContainerエクササイズ</a></li>
            </ul>


<h2><a name="QuickStart">クイックスタート</a></h2>
            <p>S2Containerは、Dependency Injection（以降DIと略します）をおこなう軽量コンテナです。DIとは、インターフェースと実装を分離して、お互いがインターフェースのみで会話するようにしようという考え方です。</p>

<h3><a name="FirstStep">最初の一歩</a></h3>
<p>早速試してみましょう。登場自分物は次のようになります。</p>
<ul>
<li>あいさつクラス
<ul>
<li>あいさつ用の文字列を返す。</li>
</ul>
</li>

<li>あいさつクライアントクラス
<ul>
<li>あいさつクラスから取得したあいさつ（文字列）をコンソールに出力する。</li>
</ul>
</li>

<li>あいさつメインクラス
<ul>
<li>起動用のクラス。あいさつクラスとあいさつクライアントクラスの組み立ても行う｡
</li>
</ul>
</li>

</ul>
<h5>Greeting.java</h5>
<p>あいさつのためのインターフェースです。</p>
<pre>
package examples.di;

public interface Greeting {

    String greet();
}
</pre>

<h5>GreetingImpl.java</h5>
<p>あいさつの実装です。</p>
<pre>
package examples.di.impl;

import examples.di.Greeting;

public class GreetingImpl implements Greeting {

    public String greet() {
        return "Hello World!";
    }
}
</pre>

<h5>GreetingClient.java</h5>
<p>あいさつを利用するクライアントのインターフェースです。</p>
<pre>
package examples.di;

public interface GreetingClient {

    void execute();
}
</pre>

<h5>GreetingClientImpl.java</h5>
<p>あいさつを利用するクライアントの実装です。GreetingImpl（実装）を直接利用するのではなく､Greeting（インターフェース）を通じて機能を利用するようにします。</p>
<pre>
package examples.di.impl;

import examples.di.Greeting;
import examples.di.GreetingClient;

public class GreetingClientImpl implements GreetingClient {

    private Greeting greeting;

    public void setGreeting(Greeting greeting) {
        this.greeting = greeting;
    }

    public void execute() {
        System.out.println(greeting.greet());
    }
}
</pre>

<p>機能を提供する側と利用する側の準備ができました。実行してみましょう。</p>
<h5>GreetingMain.java</h5>
<pre>
package examples.di.main;

import examples.di.Greeting;
import examples.di.impl.GreetingClientImpl;
import examples.di.impl.GreetingImpl;

public class GreetingMain {

    public static void main(String[] args) {
        Greeting greeting = new GreetingImpl();
        GreetingClientImpl greetingClient = new GreetingClientImpl();
        greetingClient.setGreeting(greeting);
        greetingClient.execute();
    }
}
</pre>
<p>実行結果は下記のようになります。</p>
<pre>
Hello World!
</pre>

<p>このように機能の利用者(GreetingClientImpl)は､インターフェース(Greeting)経由で機能を利用するようにし､具体的な実装オブジェクトは、
実行時に第三者(この場合はGreetingMain)が提供するというのが、DIの基本的な考え方になります。</p>
<p>でも、GeetingMainのように設定内容をソースに直接書いてしまうと、設定に変更が起きるたびに
ソースコードを修正する必要が出てきます。それを避けるために､登場するのがDIContainerです。
設定内容を外出しの設定ファイルにして、DIContainerがその設定ファイルを読み込んでオブジェクトの組み立てを行うのです。</p>
<p>それでは、先程の設定内容を設定ファイルに書き出してみましょう。S2Containerでは、拡張子は".dicon"になります。</p>

<h5>GreetingMain2.dicon</h5>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE components PUBLIC<br>    &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;<br>    &quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;<br>&lt;components&gt;<br>    &lt;component name=&quot;greeting&quot;<br>        class=&quot;examples.di.impl.GreetingImpl&quot;/&gt;<br>    &lt;component name=&quot;greetingClient&quot;<br>        class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>        &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;

</pre>

<p>詳しくは、<a href="#DefReference">S2Containerタグリファレンス</a>を参照してください。まず、ポイントを説明します。</p>

<pre>&lt;component name=&quot;greeting&quot;<br>    class=&quot;examples.di.impl.GreetingImpl&quot;/&gt;
</pre>
<p>上記のようにコンポーネントを定義しています。これは、下記のJavaのコードに相当します。</p>

<pre>
Greeting greeting = new GreetingImpl();
</pre>

<p>conponentタグのname属性でコンポーネント名を指定し､class属性でクラス名を指定します。次は､greetingClientの設定です。</p>

<pre>&lt;component name=&quot;greetingClient&quot;<br>    class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>    &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>&lt;/component&gt;
</pre>

<p>propertyタグのname属性でプロパティ名を指定し､ボディでコンポーネント名を指定します。これは、下記のJavaのコードに相当します。コンポーネント名は、「&quot;」で囲まないことに注意してください。「&quot;」で囲むと文字列とみなされてしまいます。</p>

<pre>GreetingClientImpl greetingClient = new GreetingClientImpl();
greetingClient.setGreeting(greeting);
</pre>

<p>S2Containerを利用する起動クラスは次のようになります。</p>
<h5>GreetingMain2.java</h5>
<pre>
package examples.di.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.di.GreetingClient;

public class GreetingMain2 {

    private static final String PATH =
        "examples/di/dicon/GreetingMain2.dicon";

    public static void main(String[] args) {
        S2Container container =
            S2ContainerFactory.create(PATH);
        GreetingClient greetingClient = (GreetingClient)
            container.getComponent("greetingClient");
        greetingClient.execute();
    }
}</pre>

<p>S2Containerは、S2ContainerFactory#create(String path)を使って作成します。詳しくは､
<a href="#S2ContainerCreation">S2Containerの作成</a>を参照してください。</p>
<p>コンポーネント(greetingClient)は､S2Container#getComponent(String componentName)を使って取得します。
詳しくは､<a href="#getComponent">コンポーネントの取得</a>を参照してください。</p>
<p>実行結果は先程と同様に下記のようになります。</p>
<pre>
Hello World!
</pre>

<p>DIとよく一緒に用いられるのがAOPです。AOPとは、ログ出力だとか複数のクラスに分散するロジックを
モジュール化する技術です。それでは、既に作成済みの
GreetingImpl、GreetingClinetImplのソースを修正することなく､ログ（トレース）を出力させて見ましょう。
AOPを適用した設定ファイルは､次のようになります。
</p>

<h5>GreetingMain3.dicon</h5>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE components PUBLIC<br>    &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;<br>    &quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;<br>&lt;components&gt;<br>    &lt;include path=&quot;aop.dicon&quot;/&gt;<br>    &lt;component name=&quot;greeting&quot;<br>        class=&quot;examples.di.impl.GreetingImpl&quot;&gt;<br>        &lt;aspect&gt;aop.traceInterceptor&lt;/aspect&gt;<br>    &lt;/component&gt;<br>    &lt;component name=&quot;greetingClient&quot;<br>        class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>        &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>        &lt;aspect&gt;aop.traceInterceptor&lt;/aspect&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;
</pre>

<p>Seasar2では、良く使われるAOPのモジュールがaop.diconの中にあらかじめ定義されています。
次のようにして、includeタグを使います。
詳しくは､<a href="#Include">S2Container定義の分割とインクルード</a>を参照してください。</p>
<pre>&lt;include path=&quot;aop.dicon&quot;/&gt;
</pre>

<p>コンポーネントにAOPを適用するには､<a href="#componentTag">componentタグ</a>の子タグの
<a href="#aspectTag">aspectタグ</a>のボディにAOPのモジュール名を指定します。aop.traceInterceptorがAOPのモジュール名になります。</p>
<pre>&lt;aspect&gt;aop.traceInterceptor&lt;/aspect&gt;
</pre>

<p>AOPの設定は以上です。それではGreetingMain3を実行してみます。GreetingMain2との違いは､設定ファイルのパスだけです。</p>

<h5>GreetingMain3.java</h5>
<pre>
package examples.di.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.di.GreetingClient;

public class GreetingMain3 {

    private static final String PATH =
        "examples/di/dicon/GreetingMain3.dicon";

    public static void main(String[] args) {
        S2Container container =
            S2ContainerFactory.create(PATH);
        GreetingClient greetingClient = (GreetingClient)
            container.getComponent("greetingClient");
        greetingClient.execute();
    }
}
</pre>

<p>実行結果は、下記のようになります。元のソースコードを修正していないのに、ログが出力されていることが分かります。</p>
<pre>
DEBUG 2005-10-11 21:01:49,655 [main] BEGIN examples.di.impl.GreetingClientImpl#execute()
DEBUG 2005-10-11 21:01:49,665 [main] BEGIN examples.di.impl.GreetingImpl#greet()
DEBUG 2005-10-11 21:01:49,665 [main] END examples.di.impl.GreetingImpl#greet() : Hello World!
Hello World!
DEBUG 2005-10-11 21:01:49,675 [main] END examples.di.impl.GreetingClientImpl#execute() : null
</pre>

<p>これで、S2Containerの基本的な使い方をマスターすることができました。</p>

<h3><a name="NextStep">次の一歩</a></h3>
<p>でも、なんだか設定ファイルを書くのって面倒ですよね。
S2Containerでは、できるだけ設定ファイルの記述量を減らすために、次のコンセプトが実現されています。</p>
<ul>
<li><a name="CoC">Convention over Configuration</a></li>
</ul>

<p>これは適切な規約を決め､その規約を守っていれば､設定なしでも動くようにするというものです。
例えば､先程の設定ファイルで、下記のように明示的にプロパティを指定している部分がありました。</p>

<pre>&lt;component name=&quot;greetingClient&quot;<br>    class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>    &lt;property name=&quot;greeting&quot;&gt;greeting&lt;/property&gt;<br>&lt;/component&gt;
</pre>

<p>S2Containerには、プロパティの型がインターフェースの場合､
プロパティの型を実装したのコンポーネントがコンテナに登録されていれば、
特に設定をしなくても自動的にDIするという機能があります。
これは、「プロパティの型をインターフェースで定義する」というDIで<b>推奨されている規約</b>を守れば､
S2Containerが自動的に処理してくれるということです。</p>
<p>規約というとめんどくさいと思われがちですが､「推奨されていて、かつ守ると開発が楽になる」なら、
規約に準拠しようというモチベーションが生まれます。そこがポイントなのです。</p>

<p>上記の設定は､次のように簡略化することができます。</p>
<pre>&lt;component name=&quot;greetingClient&quot;<br>    class=&quot;examples.di.impl.GreetingClientImpl&quot;&gt;<br>&lt;/component&gt;
</pre>

<p>実は､先程のAOPの例でも「Convention over Configuration」が適用されています。
AOPでは通常､AOPのモジュールをどこ（例えばどのメソッド）に適用するのかということを
pointcutで指定するのですが､<a href="aop.html">S2AOP</a>の場合､
「インターフェースを使う」という<b>推奨されている規約</b>が守られていれば､
pointcutを指定しなくても､自動的にインターフェースで定義されているすべてのメソッドに適用するという機能が用意されています。
そのため、先程の例では、pointcutを指定する必要が無かったのです。</p>
<p>「Convention over Configuration」によって、DIやAOPの設定は､簡略化できますが､
扱うコンポーネントの数が増えると、コンポーネントの登録もかなり大変な作業になってきます。
このコンポーネントの登録も自動化してしまうのが<a href="#ComponentAutoRegister">コンポーネントの自動登録</a>機能です。
先程のGreetingImpl、GreetingClientImplの登録を自動化する設定は次のようになります。</p>

<pre>&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister&quot;&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;/&gt;<br>&lt;/component&gt;</pre>

<p>FileSystemComponentAutoRegisterコンポーネントは、
addClassPatternメソッドで指定されたクラスをファイルシステムから探して､
S2Containerに自動登録します。initMethodタグについては､<a href="#MethodInjection">メソッド・インジェクション</a>を参照してください。</p>
<p>addClassPatternメソッドの最初の引数は､自動登録したいコンポーネントのパッケージ名です。
子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</p>

<p>コンポーネントの自動登録によって､後からコンポーネントを追加しても､設定を追加する必要がなくなるので､
手間を大幅に削減できるようになります。</p>

<p>コンポーネントの登録が自動化できるようになると、次は､アスペクトの登録を自動化したくなることでしょう。
先程のGreetingImpl、GreetingClientImpへのアスペクトの登録を自動化する設定は次のようになります。</p>

<pre>&lt;include path=&quot;aop.dicon&quot;/&gt;
...
&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.AspectAutoRegister&quot;&gt;<br>    &lt;property name=&quot;interceptor&quot;&gt;aop.traceInterceptor&lt;/property&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;/&gt;<br>&lt;/component&gt;
</pre>

<p>interceptorプロパティでAOPのモジュール名を指定します。addClassPatternメソッドは、コンポーネントの自動登録と同様なので､
特に説明は必要ないでしょう。
コンポーネントの自動登録とアスペクトの自動登録を組み合わせた例は次のようになります。</p>

<h5>GreetingMain4.dicon</h5>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot; <br>    &quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;<br>    &lt;include path=&quot;aop.dicon&quot;/&gt;

    &lt;component<br>      class=&quot;org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister&quot;&gt;<br>        &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>            &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>            &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>        &lt;/initMethod&gt;<br>        &lt;initMethod name=&quot;registAll&quot;/&gt;<br>    &lt;/component&gt;

    &lt;component<br>      class=&quot;org.seasar.framework.container.autoregister.AspectAutoRegister&quot;&gt;<br>        &lt;property name=&quot;interceptor&quot;&gt;aop.traceInterceptor&lt;/property&gt;<br>        &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>            &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>            &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>        &lt;/initMethod&gt;<br>        &lt;initMethod name=&quot;registAll&quot;/&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;
</pre>

<p>それではGreetingMain4を実行してみます。
自動登録を使う場合は､S2Container#init()とS2Container#destroy()を呼び出す必要があります。</p>

<h5>GreetingMain4.java</h5>
<pre>
package examples.di.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.di.GreetingClient;

public class GreetingMain4 {

    private static final String PATH =
        "examples/di/dicon/GreetingMain4.dicon";

    public static void main(String[] args) {
        S2Container container =
            S2ContainerFactory.create(PATH);
        container.init();
        try {
            GreetingClient greetingClient = (GreetingClient)
                container.getComponent("greetingClient");
            greetingClient.execute();
        } finally {
            container.destroy();
        }
    }
}
</pre>

<p>実行結果は、GreetingMain3と同様に下記のようになります。</p>
<pre>
DEBUG 2005-10-12 16:00:08,093 [main] BEGIN examples.di.impl.GreetingClientImpl#execute()
DEBUG 2005-10-12 16:00:08,103 [main] BEGIN examples.di.impl.GreetingImpl#greet()
DEBUG 2005-10-12 16:00:08,103 [main] END examples.di.impl.GreetingImpl#greet() : Hello World!
Hello World!
DEBUG 2005-10-12 16:00:08,103 [main] END examples.di.impl.GreetingClientImpl#execute() : null
</pre>

<p>たいていの場合､自動登録と自動バインディングの仕組みでうまくいくでしょう。
自動登録したくないコンポーネントがある場合には､自動登録コンポーネントに用意されているaddIgnoreClassPatternメソッドで、
自動登録の対象外にすることができます。</p>
<p>自動バインディングしたくないプロパティがある場合は､<a href="#BindingAnnotation">Bindingアノテーション</a>を使い､
設定ファイルを使わずに、細かい調整をすることもできます。</p>
<p>これで、S2Containerの高度な使い方をマスターすることができました。後は､必要に応じてマニュアルを参照すると良いでしょう。</p>


<h2><a name="S2ContainerReference">S2Containerリファレンス</a></h2>

<h3><a name="CreateFile"><b>作成すべきファイル</b></a></h3>
<p>S2Containerを使用するためには、定義ファイルを作成する必要があります。
定義ファイルは、コンポーネントを組み立てるための設計書のようなものです。
形式はXMLで、拡張子は、diconです。</p>

            <h3><a name="S2ContainerDefinition"><b>S2Containerの定義</b></a></h3>
            <p>S2Containerの定義は、次のようになります。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
            ...
    &lt;/component&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
            ...
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <p>DOCTYPEは省略できません。diconファイルを作成する場合は、上記のサンプルをコピー＆ペーストしてください。ルートは<a href="#componentsTag">componentsタグ</a>です。コンポーネントごとに、<a href="#componentTag">componentタグ</a>を定義していきます。componentタグのclass属性でコンポーネントのクラスの完全限定名を指定します。name属性には、コンポーネント名を指定します。詳細は、<a href="#DefReference">S2Container定義タグリファレンス</a>を参照してください。</p>


<pre>
&lt;components&gt;
    &lt;component name=&quot;hoge&quot; class=&quot;examples.dicon.HogeImpl&quot;/&gt;
&lt;/components&gt;
</pre>


            <h3><a name="S2ContainerCreation">S2Containerの生成</a></h3>
<p>S2Containerを生成する方法は二通りあります。</p>
<ul>
<li>SingletonS2ContainerFactoryを使用する。
<li>S2ContainerFactoryを使用する。
</ul>
<h4><a name="SingletonS2ContainerFactory">SingletonS2ContainerFactoryを使用する</a></h4>
<p>SingletonS2ContainerFactoryを使用する場合は、次のメソッドを使用します。</p>
            <p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#init()</p>
<p>
定義ファイルはCLASSPATHで指定されているディレクトリにあるapp.diconが使われます。 </p>
<p>作成したS2Containerは、どこからでも次のメソッドで取得することができます。</p>
<p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#getContainer()</p>
<pre>SingletonS2ContainerFactory.init();
...
S2Container container = SingletonS2ContainerFactory.getContainer();</pre>
<p>定義ファイルのパスを指定する場合はinit()を呼び出す前に次のメソッドを使用します。</p>
<p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#setConfigPath(String
Path)</p>
<p>引数pathはCLASSPATHで指定されているディレクトリをルートとする定義ファイルの絶対パスです。例えば、WEB-INF/classes/aaa.dicon
の場合は aaa.dicon に、WEB-INF/classes/aaa/bbb/ccc.dicon の場合は aaa/bbb/ccc.dicon
になります。セパレータは、WindowsでもUnixでも/です。</p>
<pre>private static final String PATH = &quot;aaa/bbb/ccc.dicon&quot;;
...
SingletonS2ContainerFactory.setConfigPath(PATH);
SingletonS2ContainerFactory.init();
...
S2Container container = SingletonS2ContainerFactory.getContainer();</pre>
<h4><a name="S2ContainerFactory">S2ContainerFactoryを使用する</a></h4>
<p>S2ContainerFactoryを使用する場合は、次のメソッドを使用します。</p>
<p>- org.seasar.framework.container.factory.S2ContainerFactory#create(String path)</p>
<p>S2Containerを生成した後に次のメソッドを呼び出します。</p>
<p>- org.seasar.framework.container.S2Container#init()</p>
<pre>private static final String PATH = &quot;aaa/bbb/ccc.dicon&quot;;
...
S2Container container = S2ContainerFactory.create(PATH);
container.init();</pre>
<p>この方法で取得したコンテナのインスタンスは、アプリケーションで管理する必要があります。</p>
<h3><a name="getComponent">コンポーネントの取得</a></h3>
            <p>S2Containerからコンポーネントを取り出すには、次のメソッドを使用します。</p>
            <p>- org.seasar.framework.container.S2Container#getComponent(Object componentKey)</p>
            引数には、コンポーネントのクラスもしくはコンポーネント名を指定できます。詳しくは、<a href="#componentTag">componentタグ</a>を参照してください。コンポーネントのクラスを指定する場合、コンポーネント instanceof クラスがtrueを返すクラスなら指定することができます。しかし、S2Containerの中に指定したクラスを実装しているコンポーネントが複数ある場合、S2Containerは、どのコンポーネントを返せばよいのか判断できないため、TooManyRegistrationRuntimeExceptionが発生します。実装コンポーネントがユニークに決まるクラスを指定してください。コンポーネント名で取得することもできます。その場合も、同一の名前をもつコンポーネントが複数登録されている場合、TooManyRegistrationRuntimeExceptionが発生します。コンポーネント名指定の場合、スペルミスをする可能性もあるので、できるだけクラス指定のほうが良いでしょう。<br/><br/>

            <p>例） クラスを指定してコンポーネントを取得する場合</p>
<pre>
S2Container container = S2ContainerFactory.create(PATH);
Hoge hoge = (Hoge) container.getComponent(Hoge.class);
</pre>

            <p>例） コンポーネント名を指定してコンポーネントを取得する場合</p>
<pre>
S2Container container = S2ContainerFactory.create(PATH);
Hoge hoge = (Hoge) container.getComponent("hoge");
</pre>

            <h3><a name="DIType">Dependency Injectionのタイプ</a></h3>
            <p>Dependency Injectionには、コンポーネントの構成に必要な値をコンストラクタで設定する(Constructor Injection)のか、セッター・メソッドで設定する(Setter Injection)のか、初期化メソッドで設定する(Method Injection)のかで、タイプが分かれます。Method InjectionはS2Containerのオリジナルです。S2Containerはすべてのタイプとそのハイブリッド型もサポートします。</p>

            <h3><a name="ConstructorInjection"><b>コンストラクタ・インジェクション</b></a></h3>
            <p>コンストラクタ・インジェクションとは、任意のコンストラクタの引数にDIを行います。<br/>
S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントは、componentタグで組み立てます。class属性でクラス名を指定します。<br/>name属性でコンポーネントに名前を付けることもできます。</li>
            <li><b>コンストラクタの引数の指定</b><br/>コンポーネントのコンストラクタの引数は、componentタグの子タグであるargタグを使って指定します。<br/>文字列の場合は、ダブルコーテーション(")で囲みます。</li>
         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;arg&gt;...&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h3><a name="SetterInjection"><b>セッター･インジェクション</b></a></h3>
            <p>セッター･インジェクションとは、任意のプロパティにセッターメソッドを使用してDIを行います。<br/>
S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントの指定は、コンストラクタ・インジェクションと同様です。<br/>name属性でコンポーネントに名前を付けることもできます。</li>
            <li><b>プロパティの指定</b><br/>コンポーネントのプロパティは、componentタグの子タグであるpropertyタグを使って指定します。<br/>name属性でプロパティ名を指定します。</li>
         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;property name=&quot;...&quot;&gt;...&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h3><a name="MethodInjection"><b>メソッド・インジェクション</b></a></h3>
<p>メソッド・インジェクションとは、任意のメソッドを呼び出して、DIを行います。<br/>
S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントの指定は、コンストラクタ・インジェクションと同様です。<br/>name属性でコンポーネントに名前を付けることもできます。</li>
            <li><b>初期化メソッドの指定</b><br/>initMethodタグを使って、コンポーネントの任意のメソッドを呼び出します。name属性で、メソッド名を指定します。引数は、argタグを子タグに使います。name属性を省略して、ボディで、<a href="#ognlExpr">OGNL式</a>を使うこともできます。その際、コンポーネント自身は#selfで表します。</li>
         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;initMethod&gt;...&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h3><a name="Include">S2Container定義の分割とインクルード</a></h3>
<p>すべてのコンポーネントを1つのファイルに記述すると、直ぐに肥大化してしまい管理が難しくなります。そのため、コンポーネントの定義を複数に分割する機能と分割された定義をインクルードして1つにまとめる機能がS2Containerにあります。S2Container定義ファイルのインクルードは次のようにして行います。</p>

<pre>&lt;components&gt;
    &lt;include path=&quot;bar.dicon&quot;/&gt;
&lt;/components&gt;
</pre>

            <p><a href="#includeTag">includeタグ</a>のpath属性で取り込みたいS2Container定義ファイルのパスを指定します。詳しくは、<a href="#includeTag">includeタグ</a>を参照してください。<br/>コンポーネントの検索順は、先ず自分自身に登録されているコンポーネントを探して、見つからない場合は、includeされている順に子供のS2Containerに登録されているコンポーネントを検索し、最初に見つかったコンポーネントが返されます。<br/>次のような場合は、Foo(自身のコンポーネント)→aaa(子供のS2Container)→bbb(子供のS2Container)の順に検索します。</p>

<pre>
&lt;components&gt;
    &lt;include path=&quot;aaa.dicon&quot;/&gt;
    &lt;include path=&quot;bbb.dicon&quot;/&gt;
    &lt;component class=&quot;example.container.Foo&quot; /&gt;
&lt;/components&gt;
</pre>

            <p>自動で<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>や<a href="#SetterInjection">セッター・インジェクション</a>を行う場合、S2Containerはインクルード先のコンポーネントを自動インジェクションすることができます。自動でDependency Injectionを行う場合の条件は<a href="#AutoBindingMode">自動バインディング</a>を参照してください。<br/>次のようにセッター･インジェクションでプロパティに指定するコンポーネントがインクルード先のaaa.diconとbbb.diconに登録されている場合、各HelloClientでは、どちらのコンポーネントが使用されるかをみてましょう。</p>

            <h5>root.dicon</h5>
<pre>
&lt;components&gt;
    &lt;include path=&quot;examples/dicon/include/aaa.dicon&quot;/&gt;
    &lt;include path=&quot;examples/dicon/include/bbb.dicon&quot;/&gt;
    &lt;component name=&quot;root&quot; class=&quot;examples.dicon.include.RootHelloClient&quot;/&gt;
&lt;/components&gt;
</pre>

            <h5>aaa.dicon</h5>
<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.include.HelloImpl&quot;&gt;
        &lt;property name=&quot;Message&quot;&gt;&quot;Hello Aaa!&quot;&lt;/property&gt;
    &lt;/component&gt;

    &lt;component name=&quot;aaa&quot; class=&quot;examples.dicon.include.AaaHelloClient&quot;/&gt;
&lt;/components&gt;
</pre>

            <h5>bbb.dicon</h5>
<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.include.HelloImpl&quot;&gt;
        &lt;property name=&quot;Message&quot;&gt;&quot;Hello Bbb!&quot;&lt;/property&gt;
    &lt;/component&gt;

    &lt;component name=&quot;bbb&quot; class=&quot;examples.dicon.include.BbbHelloClient&quot;/&gt;
&lt;/components&gt;
</pre>

            <p>各コンポーネントの内容は、次のようになります。</p>

<pre>
package examples.dicon.include;

public interface HelloClient {
    public void showMessage();
}
</pre>

<pre>
package examples.dicon.include;

public class RootHelloClient implements HelloClient {

    private Hello hello_;

    public void setHello(Hello hello) {
        hello_ = hello;
    }

    public Hello getHello() {
        return hello_;
    }

    public void showMessage() {
        System.out.println(getHello().getMessage());
    }
}
</pre>

            <p>AaaHelloClientとBbbHelloClientはRootHelloClient同様の実装です。</p>

<pre>
package examples.dicon.include;

public interface Hello {
    public void setMessage(String helloMessage);
    public String getMessage();
}
</pre>

<pre>
package examples.dicon.include;

public class HelloImpl implements Hello {
    private String helloMessage_;

    public void setMessage(String helloMessage) {
        helloMessage_ = helloMessage;
    }

    public String getMessage() {
        return helloMessage_;
    }
}
</pre>

           <p>HelloImplはMessageプロパティを定義しているだけです。各HelloClientのshowMessage()を呼び出した場合の実行結果は次のようになります。</p>

           <h5>RootHelloClientの実行結果</h5>
<pre>
Hello Aaa!
</pre>
           <p>まず、S2Containerはroot.diconにHelloImplが登録されているかを検索します。root.diconにはないので、次にインクルード先のaaa.diconを検索します。aaa.diconにはHelloImplが登録されているので、そのコンポーネントを使用します。</p>

           <h5>AaaHelloClientの実行結果</h5>
<pre>
Hello Aaa!
</pre>

           <p>AaaHelloClientは、aaa.diconに登録されているコンポーネントを使用します。自動でインジェクションを行う場合、子供のS2Containerは親のS2Containerのコンポーネントを使用することはできません。例えば、root.diconにHelloImplを登録していてもAaaHelloClientには自動インジェクションされないということです。</p>

           <h5>BbbHelloClientの実行結果</h5>
<pre>
Hello Bbb!
</pre>

           <p>AaaHelloClientと同様にBbbHelloClientもbbb.diconに登録されているコンポーネントを使用します。</p>

            <h3><a name="Namespace">名前空間</a></h3>
            <p>コンポーネントの定義を分割した場合に、複数のコンポーネント定義間で名前が衝突しないように、<a href="#componentsTag">componentsタグ</a>のnamespace属性で名前空間を指定することができます。</p>
            <h5>foo.dicon</h5>
<pre>
&lt;components namespace=&quot;foo&quot;&gt;
    &lt;component name=&quot;aaa&quot; .../&gt;
    &lt;component name=&quot;bbb&quot; ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>bar.dicon</h5>

<pre>
&lt;components namespace=&quot;bar&quot;&gt;
    &lt;include path=&quot;foo.dicon&quot;/&gt;
    &lt;component name=&quot;aaa&quot; .../&gt;
    &lt;component name=&quot;bbb&quot; ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
    &lt;component name=&quot;ccc&quot; ...&gt;
        &lt;arg&gt;foo.aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>app.dicon</h5>

<pre>
&lt;components&gt;
    &lt;include path=&quot;bar.dicon&quot;/&gt;
&lt;/components&gt;
</pre>

            <p>同一のコンポーネント定義内では、名前空間なしで参照できます。他のS2Container定義のコンポーネントを参照する場合は、名前空間.をコンポーネント名の頭につけます。foo.aaaとbar.aaaは同じ名前がついていますが、名前空間が異なっているので、違うコンポーネントとして認識されます。慣習として、定義ファイルの名前は、名前空間.diconにすることを推奨します。</p>


<h3><a name="InstanceMode">インスタンス管理</a></h3>
            <p>S2Containerで、コンポーネントのインスタンスをどのように管理するのかを指定するのが、<a href="#componentTag">componentタグ</a>のinstance属性です。デフォルトはsingletonで、これは、S2Container.getComponent()によって返されるコンポーネントは常に同じだという意味です。S2Container.getComponent()を呼び出すたびに、新たに作成されたコンポーネントを返して欲しい場合は、instance属性にprototypeを指定します。リクエスト(HttpServletRequest)ごとにコンポーネントを管理したい場合は、instance属性にrequestを指定します。セッション(HttpSession)ごとにコンポーネントを管理したい場合は、instance属性にsessionを指定します。</p>
            <p>プレゼンテーションのフレームワークと組み合わせるときに、プレゼンテーションフレームワークが作成したインスタンスに対して、S2Containerで管理されているコンポーネントをセットしたい場合があります。そのようなS2Container外のコンポーネントに対して<a href="http://www.kakutani.com/trans/fowler/injection.html">Dependency Injection</a>したいときには、次のメソッドを使用します。<br/><br/>- org.seasar.framework.container.S2Container#injectDependency(Object outerComponent)<br/>- org.seasar.framework.container.S2Container#injectDependency(Object outerComponent, Class componentClass)<br/>- org.seasar.framework.container.S2Container#injectDependency(Object outerComponent, String componentName)</p>
            第一引数には、外部のコンポーネントを指定します。第二引数には、外部コンポーネントのクラス、またはコンポーネント名を指定します。<br/>そのとき、S2Container定義では、instance属性にouterを指定します。

<table width="744" border="1">
  <tr bgcolor="#d1f3f4" align="center">
    <th width="104" scope="col">instance属性</th>
    <th width="624" scope="col">説明</th>
  </tr>
  <tr>
    <td>singleton(default)</td>
    <td>S2Container.getComponent()を何度呼び出しても同じインスタンスが返されます。</td>
  </tr>
  <tr>
    <td>prototype</td>
    <td>S2Container.getComponent()を呼び出すたびに新たなインスタンスが返されます。</td>
  </tr>
  <tr>
<td>request</td>
<td>リクエスト毎に1つのインスタンスが作成されます。name属性に指定した名前で、コンポーネントがリクエストに格納されます。requestを使う場合は、<a href="#request">S2ContainerFilter</a>を設定する必要があります。</td>
</tr>
<tr>
<td>session</td>
<td>セッション毎に1つのインスタンスが作成されます。name属性に指定した名前で、コンポーネントがセッションに格納されます。sessionを使う場合は、<a href="#request">S2ContainerFilter</a>を設定する必要があります。</td>
</tr>
<tr>
  <td>outer</td>
  <td>コンポーネントのインスタンスは、S2Container外で作成し、Dependency Injectionだけを行います。<a href="#Aop">アスペクト</a>、<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>は適用できません。</td>
</tr>
</table>

            <h3><a name="Lifecycle">ライフサイクル</a></h3>
            <p>initMethodやdestroyMethodでコンポーネントのライフサイクルもコンテナで管理することができます。S2Containerの開始時(S2Container.init())に<a href="#initMethodTag">initMethodタグ</a>で指定したメソッドが呼び出され、S2Containerの終了時(S2Container.destroy())に<a href="#destroyMethodTag">destroyMethodタグ</a>で指定したメソッドが呼び出されるようになります。initMethodはコンポーネントがコンテナに登録した順番に実行され、destroyMethodはその逆順に呼び出されることになります。instance属性がsingleton以外の場合、destroyMethodを指定しても無視されます。java.util.HashMap#put()メソッドに初期化(aaaに111を設定)・終了処理(aaaにnullを設定)を設定する場合は、次のようになります。</p>
<pre>
&lt;components namespace=&quot;bar&quot;&gt;
    &lt;component name=&quot;map&quot; class=&quot;java.util.HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;destroyMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;null&lt;/arg&gt;
        &lt;/destroyMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            <h3><a name="AutoBindingMode">自動バインディング</a></h3>
            <p>コンポーネント間の依存関係は、型がインターフェースの場合、コンテナによって自動的に解決されます。これがS2Containerのデフォルトですが、<a href="#componentTag">componentタグ</a>のautoBinding属性を指定することで細かく制御することもできます。</p>

<table width="744" border="1">
<tr bgcolor="#d1f3f4" align="center">
<th width="104" scope="col">autoBinding</th>
<th width="624" scope="col">説明</th>
</tr>
<tr>
<td>auto(default)</td>
<td>
コンストラクタの自動バインディング､プロパティの自動バインディングが適用されます。
</td>
</tr>
<tr>
<td>constructor</td>
<td>コンストラクタの自動バインディングが適用されます。</td>
</tr>
<tr>
<td>property</td>
<td>プロパティの自動バインディングが適用されます。</td>
</tr>
<tr>
<td>none</td>
<td>コンストラクタ、プロパティの手動バインディングのみ。</td>
</tr>
</table>

<br />
<p>コンストラクタの自動バインディングのルールは次のようになります。</p>
<ul>
<li>コンストラクタの引数が明示的に指定されている場合は、それに従い、自動バインディングは適用されません。</li>
<li>上記に該当しない場合、引数のないデフォルトコンストラクタが定義されているなら、そのコンストラクタを使い、自動バインディングは適用されません。</li>
<li>上記に該当しない場合、コンストラクタの引数の数が1以上で、
引数の型がすべてインターフェースのコンストラクタで最も引数の数が多いコンストラクタを使います。そして、
引数の型を実装したコンポーネントをコンテナから取得して適用します。</li>
<li>上記に該当しない場合､自動バインディングは適用されません。</li>
</ul>

<p>プロパティの自動バインディングのルールは次のようになります。</p>
<ul>
<li>プロパティが明示的に指定されている場合は、それに従い、自動バインディングは適用されません。</li>
<li>上記に該当しない場合､プロパティ名と同一のコンポーネントがコンテナに登録されてプロパティに代入可能なら、
そのコンポーネントが適用されます。</li>
<li>上記に該当しない場合､プロパティの型がインターフェースでプロパティの型を実装したコンポーネントがコンテナに登録されていれば、
そのコンポーネントが適用されます。</li>
<li>上記に該当しない場合､自動バインディングは適用されません。</li>
</ul>
<p>propertyタグのbindingType属性で、プロパティごとに細かく制御することもできます。</p>
<table width="744" border="1">
<tr bgcolor="#d1f3f4" align="center">
<th width="104" scope="col">bindingType</th>
<th width="624" scope="col">説明</th>
</tr>
<tr>
<td>must</td>
<td>自動バインディングが適用されない場合､例外が発生します。
</td>
</tr>
<tr>
<td>should(default)</td>
<td>自動バインディングが適用されない場合､警告を通知します。</td>
</tr>
<tr>
<td>may</td>
<td>自動バインディングが適用されない場合､何もおきません。</td>
</tr>
<tr>
<td>none</td>
<td>autoBinding属性が、auto、propertyの場合でも､自動バインディングは適用されません。</td>
</tr>
</table>
<br/>

            <h3><a name="UseS2Container">コンポーネントでS2Containerを利用する</a></h3>
            <p>コンポーネントはS2Containerに依存しないことが望ましいのですが、コンポーネントによっては、S2Containerのメソッドを呼び出したい場合もあるでしょう。S2Container自身もcontainerという名前で、登録されているので、arg,propertyタグのボディでcontainerを指定することで、コンテナのインスタンスを取得できます。また、S2Container型のsetterメソッドを定義しておいて自動バインディングで設定することもできます。arg,propertyタグでcontainerを指定する場合は、次のようになります。</p>

<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.BarImpl&quot;&gt;
        &lt;arg&gt;container&lt;/arg&gt;
    &lt;/component&gt;

    &lt;component class=&quot;examples.dicon.FooImpl&quot;&gt;
        &lt;property name=&quot;foo&quot;&gt;container&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            <h3><a name="S2ContainerServlet">S2ContainerServlet</a></h3>
            <p>これまでは、Javaアプリケーションで、明示的にS2Containerを作成していましたが、Webアプリケーションの場合、誰がS2Containerを作成するのでしょうか。その目的のために次のクラスが用意されています。</p>
            <p>- org.seasar.framework.container.servlet#S2ContainerServlet</p>
            S2ContainerServletを使うためには、web.xmlに次の項目を記述します。<br/>src/org/seasar/framework/container/servlet/web.xmlに記述例もあります。

<pre>
&lt;servlet&gt;
    &lt;servlet-name&gt;s2servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.seasar.framework.container.servlet.S2ContainerServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;configPath&lt;/param-name&gt;
        &lt;param-value&gt;app.dicon&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;debug&lt;/param-name&gt;
        &lt;param-value&gt;false&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;s2servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/s2servlet&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre>

            <p>configPathでメインとなるS2Container定義のパスを指定します。定義ファイルはWEB-INF/classesにおきます。S2ContainerServletは、他のサーブレットよりもはやく起動されるようにload-on-startupタグを調整してください。S2ContainerServletが起動した後は、次のメソッドでS2Containerのインスタンスを取得することができます。</p>
            <p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#getContainer()</p>
            <p>また、S2Containerのライフサイクルは、S2ContainerServletと連動します。debugパラメータをtrueにすると、次のようにして、稼動中にS2Containerを再起動できます。xxxはWebアプリケーションのコンテキスト名です。</p>
            <pre>http://localhost:8080/xxx/s2servlet?command=restart
            </pre>
            <p>S2ContainerServletを使っている場合、ServletContextをservletContextという名前のコンポーネントとしてアクセスできるようになります。</p>

            <h3><a name="app.dicon">app.diconの役割</a></h3>
            <p>すべてのS2Container定義のルートになる定義ファイルは、慣例でapp.diconという名前にします。app.diconにはコンポーネントの定義はしないようにしてください。通常はWEB-INF/classesにおくと良いでしょう。</p>

<pre>
&lt;components&gt;
    &lt;include path=&quot;examples/foo.dicon&quot;/&gt;
    &lt;include path=&quot;examples/bar.dicon&quot;/&gt;
          ...
&lt;/components&gt;
</pre>

<h3><a name="Aop">AOPの適用</a></h3>
<p>コンポーネントに<a href="aop.html">AOP</a>を適用することもできます。例えば、ArrayListに<a href="aop.html#TraceInterceptor">TraceInterceptor</a>を適用したい場合次のようにします。</p>

<pre>
&lt;components&gt;
    &lt;component name=&quot;traceInterceptor&quot;
               class=&quot;org.seasar.framework.aop.interceptors.TraceInterceptor&quot;/&gt;
    &lt;component class=&quot;java.util.ArrayList&quot;&gt;
        &lt;aspect&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;
    &lt;component class=&quot;java.util.Date&quot;&gt;
        &lt;arg&gt;0&lt;/arg&gt;
        &lt;aspect pointcut=&quot;getTime, hashCode&quot;&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<p>aspectタグのボディで<a href="aop.html#Advice">Interceptor</a>の名前を指定します。pointcut属性にカンマ区切りで対象となるメソッド名を指定することができます。pointcut属性を指定しない場合は、コンポーネントが実装しているインターフェースのすべてのメソッドが対象になります。メソッド名には正規表現(JDK1.4のregex)も使えます。この定義を使うサンプルは次のようになります。</p>

<pre>
private static final String PATH =
    &quot;examples/dicon/Aop.dicon&quot;;
S2Container container = S2ContainerFactory.create(PATH);
List list = (List) container.getComponent(List.class);
list.size();
Date date = (Date) container.getComponent(Date.class);
date.getTime();
date.hashCode();
date.toString();
</pre>

            <p>実行結果は次のようになります。</p>

<pre>
BEGIN java.util.ArrayList#size()
END java.util.ArrayList#size() : 0
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
BEGIN java.util.Date#hashCode()
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
END java.util.Date#hashCode() : 0
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
</pre>


<h3><a name="Meta">メタデータ</a></h3>

<p>components、component、arg、propertyタグにメタデータ<a href="aop.html"></a>を指定することもできます。metaタグはメタデータを指定したいタグの子タグに指定します。例えば、componentsタグにメタデータを指定したい場合次のようにします。</p>

<pre>&lt;components&gt;
    &lt;meta name=&quot;aaa&quot;&gt;111&lt;/meta&gt;
&lt;/components&gt;
</pre>
<p>components、component、arg、propertyタグに指定したメタデータの情報は、S2Container、ComponentDef、ArgDef、PropertyDefで定義されている次のメソッドで取得することが出来ます。</p>
<ul>
<li>public int getMetaDefSize()</li>
<li>public MetaDef getMetaDef(int index)</li>
<li>public MetaDef getMetaDef(String name)</li>
<li>public MetaDef[] getMetaDefs(String name)</li>
</ul>


<h3><a name="request">リクエストの自動バインディング</a></h3>
<p>コンポーネントに対して、HttpServletRequestを自動的にバインディングすることが出来ます。そのためには、コンポーネントに、setRequest(HttpServletRequest request)のメソッドを定義します。そうすると、S2Containerが自動的にリクエストを設定します。また、次のようにFilterをweb.xmlに定義する必要があります。</p>
<pre>&lt;web-app&gt;
<br>    &lt;filter&gt;<br>        &lt;filter-name&gt;s2filter&lt;/filter-name&gt;<br>        &lt;filter-class&gt;org.seasar.framework.container.filter.S2ContainerFilter&lt;/filter-class&gt;<br>    &lt;/filter&gt;<br>    <br>    &lt;filter-mapping&gt;<br>        &lt;filter-name&gt;s2filter&lt;/filter-name&gt;<br>        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;<br>    &lt;/filter-mapping&gt;<br>&lt;/web-app&gt;
</pre>
<p>同様にHttpServletResponse、HttpSessionもsetterメソッドを定義するだけで、自動バインディングすることが出来ます。また、S2ContainerFilterを使うと、HttpServletRequest、HttpServletResponse、HttpSessionをそれぞれrequest、response、sessionという名前のコンポーネントとしてアクセスできるようになります。</p>

<h3><a name="ComponentAutoRegister">コンポーネントの自動登録</a></h3>
<p><a href="#AutoBindingMode">自動バインディング</a>により、DIの設定はほぼ自動化できます。
<a href="#AnnotationReference">アノテーション</a>を使って細かく制御することも可能です。
さらに、コンポーネントの登録も自動化してしまおうというのが、コンポーネントの自動登録機能です。
コンポーネントの自動登録には､ファイルシステム上のclassファイルを検索するFileSystemComponentAutoRegisterコンポーネントやjarファイルの中を検索するJarComponentAutoRegisterを利用します。
開発環境ではファイルシステム、本番環境ではJarファイルを使用する場合には、ComponentAutoRegisterを利用します。
</p>
<h5><a name="FileSystemComponentAutoRegister">org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister</a></h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>自動登録されるコンポーネントに適用するInstanceDefを指定します。XMLで指定する場合､<br>
<code>@org.seasar.framework.container.deployer.InstanceDefFactory@REQUEST</code><br>
のように指定します。</td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>クラス名からコンポーネント名を自動的に決定するコンポーネント。org.seasar.framework.container.autoregister.AutoNamingインターフェースを実装している必要があります。デフォルトは､org.seasar.framework.container.autoregister.DefaultAutoNamingクラスのインスタンスになります。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<h5><a name="JarComponentAutoRegister">org.seasar.framework.container.autoregister.JarComponentAutoRegister</a></h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>jarFileNames</code></td>
<td>対象のjarファイル名を指定します。正規表現も使えます。ただし､拡張子は含まれません。複数指定する場合は､「,」で区切ります。例えば､myapp.*, yourapp.*のようになります。</td>
</tr>
<tr>
<td><code>referenceClass</code></td>
<td>このプロパティで指定されたクラスが存在するjarファイルの親ディレクトリをベースのディレクトリ(例えば、WEB-INF/lib)とみなします。デフォルトは、org.aopalliance.intercept.MethodInterceptor.classになります。</td>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>自動登録されるコンポーネントに適用するInstanceDefを指定します。XMLで指定する場合､<br>
<code>@org.seasar.framework.container.deployer.InstanceDefFactory@REQUEST</code><br>
のように指定します。</td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>クラス名からコンポーネント名を自動的に決定するコンポーネント。org.seasar.framework.container.autoregister.AutoNamingインターフェースを実装している必要があります。デフォルトは､org.seasar.framework.container.autoregister.DefaultAutoNamingクラスのインスタンスになります。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<h5><a name="aComponentAutoRegister">org.seasar.framework.container.autoregister.ComponentAutoRegister</a></h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>instanceDef</code></td>
<td>自動登録されるコンポーネントに適用するInstanceDefを指定します。XMLで指定する場合､@org.seasar.framework.container.deployer.InstanceDefFactory@REQUESTのように指定します。</td>
</tr>
<tr>
<td><code>autoNaming</code></td>
<td>クラス名からコンポーネント名を自動的に決定するコンポーネント。org.seasar.framework.container.autoregister.AutoNamingインターフェースを実装している必要があります。デフォルトは､org.seasar.framework.container.autoregister.DefaultAutoNamingクラスのインスタンスになります。</td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addReferenceClass</code></td>
<td>このプロパティで指定されたクラスが存在するディレクトリまたはJarファイルを基点としてクラスを検索します。</td>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<br />
<p>コンポーネントの名前はAutoNamingにより制御します．クラス名をコンポーネント名とするDefaultAutoNamingと、パッケージで修飾された名前をコンポーネント名とするAualifiedAutoNamingがあります．</p>
<h5>org.seasar.framework.container.autoregister.DefaultAutoNaming</h5>
<p>クラスの完全修飾名からパッケージ部分を除き、最後がImplまたはBeanで終わっていたら削除し､
先頭を小文字にした名前をコンポーネントの名前に設定します。
例えば､aaa.HogeImplクラスの場合､コンポーネント名は､hogeになります。</p>
<table border="1">

<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>decapitalize</code></td>
<td>コンポーネント名の先頭を小文字にする場合はtrueを指定します。デフォルトはtrueです。</td>
</tr>

</table>
<br>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>setCustomizedName</code></td>
<td>デフォルトのルールに従わないクラスを登録します。最初の引数は､クラスの完全修飾名です。
2番目の引数は､コンポーネント名です。</td>
</tr>
<tr>
<td><code>addIgnoreClassSuffix</code></td>
<td>クラス名の末尾から削除する部分を指定します。デフォルトでImplおよびBeanが登録されています。</td>
</tr>
<tr>
<td><code>addReplaceRule</code></td>
<td>正規表現による置換ルールを追加します。最初の引数は正規表現です。2番目の引数は置換文字列です。</td>
</tr>
<tr>
<td><code>clearReplaceRule</code></td>
<td>setCustomizedName、addIgnoreClassSuffix、addReplaceRuleで登録した変換規則をクリアします。デフォルトで登録されているImplおよびBeanもクリアされます。</td>
</tr>
</table>
<h5>org.seasar.framework.container.autoregister.QualifiedAutoNaming</h5>
<p>パッケージ名またはその一部で修飾されたクラス名をコンポーネントの名前に設定します。
クラスの完全修飾名から最後がImplまたはBeanで終わっていたら削除し､
先頭を小文字、ピリオドの直後を大文字にした名前をコンポーネントの名前に設定します。<br>
パッケージの先頭部分から不要な部分を削除することができます。<br>
例えば､aaa.bbb.ccc.ddd.HogeImplクラスの場合で､先頭のaaa.bbbを削除するように指定した場合のコンポーネント名は､cccDddHogeになります。</p>
<table border="1">


<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>decapitalize</code></td>
<td>コンポーネント名の先頭を小文字にする場合はtrueを指定します。デフォルトはtrueです。</td>
</tr>


</table>
<br>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>setCustomizedName</code></td>
<td>デフォルトのルールに従わないクラスを登録します。最初の引数は､クラスの完全修飾名です。
2番目の引数は､コンポーネント名です。</td>
</tr>
<tr>
<td><code>addIgnorePackagePrefix</code></td>
<td>パッケージ名の先頭から削除する部分を指定します。</td>
</tr>
<tr>
<td><code>addIgnoreClassSuffix</code></td>
<td>クラス名の末尾から削除する部分を指定します。デフォルトでImplおよびBeanが登録されています。</td>
</tr>
<tr>
<td><code>addReplaceRule</code></td>
<td>正規表現による置換ルールを追加します。最初の引数は正規表現です。2番目の引数は置換文字列です。</td>
</tr>
<tr>
<td><code>clearReplaceRule</code></td>
<td>setCustomizedName、addIgnorePackagePrefix、addIgnoreClassSuffix、addReplaceRuleで登録した変換規則をクリアします。デフォルトで登録されているImplおよびBeanもクリアされます。</td>
</tr>
</table>
<br />
<h5>例</h5>
<pre>&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.FileSystemComponentAutoRegister&quot;&gt;<br>    &lt;property name=&quot;autoNaming&quot;&gt;<br>        &lt;component class=&quot;org.seasar.framework.container.autoregister.DefaultAutoNaming&quot;&gt;
            &lt;initMethod name=&quot;setCustomizedName&quot;&gt;<br>                &lt;arg&gt;&quot;examples.di.impl.HogeImpl&quot;&lt;/arg&gt;<br>                &lt;arg&gt;&quot;hoge2&quot;&lt;/arg&gt;<br>            &lt;/initMethod&gt;
        &lt;/component&gt;<br>    &lt;/property&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;/&gt;<br>&lt;/component&gt;</pre>

<pre>&lt;component class=&quot;org.seasar.framework.container.autoregister.JarComponentAutoRegister&quot;&gt;<br>    &lt;property name=&quot;referenceClass&quot;&gt;<br>        @junit.framework.TestSuite@class<br>    &lt;/property&gt;<br>    &lt;property name=&quot;jarFileNames&quot;&gt;&quot;junit.*&quot;&lt;/property&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;junit.framework&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;TestSuite&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;&gt;&lt;/initMethod&gt;<br>&lt;/component&gt;

</pre>

<pre>&lt;component class=&quot;org.seasar.framework.container.autoregister.ComponentAutoRegister&quot;&gt;<br>    &lt;property name=&quot;referenceClass&quot;&gt;<br>        @aaa.bbb.ccc.ddd.HogeImpl@class<br>    &lt;/property&gt;<br><br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;aaa.bbb&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;&gt;&lt;/initMethod&gt;<br>&lt;/component&gt;

</pre>

<h3><a name="AspectAutoRegister">アスペクトの自動登録</a></h3>
<p><a href="#ComponentAutoRegister">コンポーネントの自動登録</a>により、コンポーネントの登録は自動化できます。
さらに、アスペクトの登録も自動化してしまおうというのが、アスペクトの自動登録機能です。
コンポーネントの自動登録と組み合わせる場合は､
コンポーネントの自動登録の設定よりも後に、アスペクトの自動登録の設定を記述する必要があります。</p>
<h5>org.seasar.framework.container.autoregister.AspectAutoRegister</h5>
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>プロパティ</th>
<th>説明</th>
</tr>
<tr>
<td><code>interceptor</code></td>
<td>インターセプタを指定します。複数のインターセプタを指定したい場合は､<a href="aop.html#InterceptorChain">InterceptorChain</a>を使ってください。</td>
</tr>
<tr>
<td><code>pointcut</code></td>
<td> インターセプタを適用するメソッドをカンマ区切りで指定します。pointcutを指定しない場合は、コンポーネントが実装しているインターフェースのすべてのメソッドが対象になります。メソッド名には正規表現(JDK1.4のregex)も使えます。 </td>
</tr>
</table>
<br />
<table border="1">
<tr bgcolor="#d1f3f4" align="center">
<th>メソッド</th>
<th>説明</th>
</tr>
<tr>
<td><code>addClassPattern</code></td>
<td>自動登録したいクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
<tr>
<td><code>addIgnoreClassPattern</code></td>
<td>自動登録したくないクラスパターンを登録します。最初の引数は､コンポーネントのパッケージ名です。子供のパッケージも再帰的に検索します。2番目の引数は､クラス名です。正規表現が使えます。「,」区切りで複数記述することもできます。</td>
</tr>
</table>
<br />
<h5>例</h5>
<pre>&lt;include path=&quot;aop.dicon&quot;/&gt;
...
&lt;component<br>  class=&quot;org.seasar.framework.container.autoregister.AspectAutoRegister&quot;&gt;<br>    &lt;property name=&quot;interceptor&quot;&gt;aop.traceInterceptor&lt;/property&gt;<br>    &lt;initMethod name=&quot;addClassPattern&quot;&gt;<br>        &lt;arg&gt;&quot;examples.di.impl&quot;&lt;/arg&gt;<br>        &lt;arg&gt;&quot;.*Impl&quot;&lt;/arg&gt;<br>    &lt;/initMethod&gt;<br>    &lt;initMethod name=&quot;registAll&quot;/&gt;<br>&lt;/component&gt;
</pre>

<h3><a name="Hotswap">Hotswap</a></h3>
<p>従来、ソースコードを書き換えてコンパイルした場合､コンパイル後の機能を試すためには､
アプリケーション(正確にはClassLoader)を再起動する必要がありました。
アプリケーションサーバ上で､アプリケーションを再起動するのは､非常に時間がかかるものです。
「かったるい」と思っていた方も多くいることでしょう。</p>
<p>Seasar2では、アプリケーションを稼動させたまま､クラスファイルを置き換えて、
即座に試すことのできる<b>Hotswap</b>機能を実現しています。
これであの「イライラ」からも解放されます。余分な待ち時間が無いので生産性を向上させることもできます。それでは、試してみましょう。</p>
<h4>Greeting.java</h4>
<pre>
package examples.hotswap;

public interface Greeting {

    String greet();
}
</pre>
<h4>GreetingImpl.java</h4>
<pre>
package examples.hotswap.impl;

import examples.hotswap.Greeting;

public class GreetingImpl implements Greeting {

    public String greet() {
        return "Hello";
    }
}
</pre>
<h4>hotswap.dicon</h4>
<pre>&lt;components&gt;<br>    &lt;component class=&quot;examples.hotswap.impl.GreetingImpl&quot;/&gt;<br>&lt;/components&gt;
</pre>
<p>ここまでは､特に変わったところはありません。ポイントはこれからです。
s2container.diconを使って、hotswapモードに切り替えます。</p>
<h4>s2container.dicon</h4>
<pre>&lt;components&gt;<br>    &lt;component<br>      class=&quot;org.seasar.framework.container.factory.S2ContainerFactory$DefaultProvider&quot;&gt;<br>        &lt;property name=&quot;hotswapMode&quot;&gt;true&lt;/property&gt;<br>    &lt;/component&gt;<br>&lt;/components&gt;<br></pre>
<p>s2container.diconはクラスパスの通っているルートのディレクトリに置いておけば､自動で認識されます。
S2ContainerFactory#configure()を使って明示的に指定することもできます。</p>
<h4>GreetingMain.dicon</h4>
<pre>
package examples.hotswap.main;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

import examples.hotswap.Greeting;

public class GreetingMain {

    private static final String CONFIGURE_PATH =
        "examples/hotswap/dicon/s2container.dicon";

    private static final String PATH =
        "examples/hotswap/dicon/hotswap.dicon";

    public static void main(String[] args) throws Exception {
        S2ContainerFactory.configure(CONFIGURE_PATH);
        S2Container container = S2ContainerFactory.create(PATH);
        System.out.println("hotswapMode:" + container.isHotswapMode());
        container.init();
        try {
            Greeting greeting = (Greeting) container
                    .getComponent(Greeting.class);
            System.out.println(greeting.greet());
            System.out.println("Let's modify GreetingImpl, then press ENTER.");
            System.in.read();
            System.out.println("after modify");
            System.out.println(greeting.greet());
        } finally {
            container.destroy();
        }
    }
}
</pre>
<p>hotswapを使うためには､S2Container#init()を呼び出す必要があります。
実行すると"Hello"と表示された後に､プログラムが停止するので､
GreetingImpl#greet()が"Hello2"を返すように修正してコンパイルします。
その後､コンソールにフォーカスを当ててENTERキーを押してください。
同じインスタンスなのにかかわらず、classファイルが入れ替わっていることがわかります。
これは、<a href="#InstanceMode">インスタンスモード</a>がsingletonの場合の例ですが､
<a href="#InstanceMode">インスタンスモード</a>がprototypeの場合は､S2Container#getComponent()のタイミングでクラスが入れ替わります。</p>
<h4>実行結果</h4>
<pre>
hotswapMode:true
Hello
Let's modify GreetingImpl, then press ENTER.

after modify
Hello2
</pre>
<p>hotswapを使うためには､コンポーネントがインターフェースを提供し､
コンポーネントの利用者側は､インターフェース経由でコンポーネントを利用する必要があります。
<a href="#InstanceMode">インスタンスモード</a>がrequest、sessionの場合は､
そのコンポーネントが他のコンポーネントから参照されていない場合には､
インターフェースなしでもhotswapを利用することができます。
</p>

<h2><a name="DefReference">S2Containerタグリファレンス</a></h2>

<h3><a name="DOCTYPE">DOCTYPE</a></h3>
<p>DOCTYPEは、XML宣言の次に指定します。下記のように指定してください。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;hello&quot; class=&quot;examples.dicon.HelloConstructorInjection&quot;&gt;
        &lt;arg&gt;&quot;Hello World!&quot;&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h3><a name="componentsTag">componentsタグ(必須)</a></h3>
            <p>ルートのタグになります。</p>
            <h4><a name="namespaceAttr">namespace属性(任意)</a></h4>
            <p><a href="#Namespace">名前空間</a>を指定することができます。Javaの識別子として使えるものにします</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components namespace=&quot;hoge&quot;&gt;
    ...
&lt;/components&gt;
</pre>

            <h3><a name="includeTag">includeタグ(任意)</a></h3>
            <p>分割されたS2Containerの定義を<a href="#Include">取り込む</a>場合に使います。</p>
            <h4><a name="pathAttr">path属性(必須)</a></h4>
            <p>定義ファイルのパスを指定することができます。CLASSPATHで指定されているディレクトリをルートとする定義ファイルの絶対パスです。例えば、WEB-INF/classes/aaa.dicon
の場合は aaa.dicon に、WEB-INF/classes/aaa/bbb/ccc.dicon の場合は aaa/bbb/ccc.dicon
になりますセパレータは、WindowsでもUnixでも/です。componentタグの前に記述する必要があります。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;include path=&quot;aaa/bbb/ccc.dicon&quot; /&gt;
&lt;/components&gt;
</pre>

            <h3><a name="componentTag">componentタグ(任意)</a></h3>
            <p>コンポーネントを定義します。</p>
            <h4><a name="classAttr">class属性(任意)</a></h4>
            <p>クラスの完全限定名を指定します。ボディで、<a href="#ognlExpr">OGNL式</a>を使ってコンポーネントを指定した場合は、class属性を省略することができます。OGNL式を使った場合にclass属性を指定すると、型チェックを行います。</p>
            <h4><a name="componentTag.nameAttr">name属性(任意)</a></h4>
            <p>名前を指定することもできます。Javaの識別子として使えるものにします。詳しくは、<a href="#getComponent">コンポーネントの取得</a>を参照してください。</p>
            <h4><a name="instanceAttr">instance属性(任意)</a></h4>
            <p>S2Containerがどのようにコンポーネントのインスタンスを管理するのかを指定することができます。singleton(デフォルト)、prototype、outer、request、sessionを指定することができます。詳しくは、<a href="#InstanceMode">インスタンス管理</a>を参照してください。</p>
            <h4><a name="autoBindingAttr">autoBinding属性(任意)</a></h4>
            <p>S2Containerがコンポーネントの依存関係をどのように解決するのかを指定できます。auto(デフォルト)、constructor、property、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。</p>

            <h3><a name="argTag">argタグ(任意)</a></h3>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使った場合は、コンストラクタの引数になります。記述した順番でコンストラクタに渡されます。
            <a href="#initMethodTag">initMethodタグ</a>、<a href="#destroyMethodTag">destroyMethodタグ</a>の子タグとして使った場合は、メソッドの引数になります。記述した順番でメソッドに渡されます。
            引数として渡される実際の値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

            <h3><a name="propertyTag">propertyタグ(任意)</a></h3>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使います。プロパティとして設定される実際の値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

            <h4><a name="propertyTag.nameAttr">name属性(必須)</a></h4>
            <p>プロパティ名を指定します。</p>

            <h4><a name="propertyTag.bindingTypeAttr">bindingType属性(任意)</a></h4>
            <p>プロパティごとに自動バインディングを細かく制御できます。must、should(デフォルト)、may、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。</p>

            <h3><a name="metaTag">metaタグ(任意)</a></h3>
            <p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとして使います。メタデータの値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

<h4><a name="propertyTag.nameAttr">name属性(任意)</a></h4>

            <p>メタ名を指定します。</p>

            <h3><a name="initMethodTag">initMethodタグ(任意)</a></h3>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使います。引数は、子タグで、<a href="#argTag">argタグ</a>を使います。name属性を書かずに、<a href="#ognlExpr">OGNL式</a>を使って、コンポーネントのメソッドを呼び出すこともできます。initMethodタグが定義されているコンポーネント自身を表す#self、System.outを表す#out、System.errを表す#errがinitMethodタグ内だけで有効なオブジェクトとして使えます。</p>
            <h4><a name="initMethodTag.nameAttr">name属性(任意)</a></h4>
            <p>メソッド名を指定します。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container 2.3//EN&quot;
&quot;http://www.seasar.org/dtd/components23.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;java.util.HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;initMethod&gt;#self.put(&quot;aaa&quot;, 111)&lt;/initMethod&gt;
        &lt;initMethod&gt;#out.println(&quot;Hello&quot;)&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h3><a name="destroyMethodTag">destroyMethodタグ(任意)</a></h3>
            <p>initMethodタグと同様です。</p>

            <h3><a name="aspectTag">aspectタグ(任意)</a></h3>
            <p>アスペクトをコンポーネントに組み込みます。詳しくは、S2AOPの<a href="aop.html#aspectTag">aspectタグ</a>の説明を参照してください。</p>

            <h3><a name="descriptionTag">descriptionタグ(任意)</a></h3>

            <p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとしてdescriptionタグを使うことができます。自由に説明を記述できます。</p>

            <h3><a name="ognlExpr">OGNL式</a></h3>
            <p>S2Containerでは、式言語として<a href="http://www.ognl.org/">OGNL</a>を利用しています。XMLの中で、文字列で記述した内容(式)をJavaのオブジェクトに変換するためのものだと思って間違いないと思います。</p>

            <ul>
            <li>文字列は、&quot;hoge&quot;のように&quot;で囲みます。</li>
            <li>charは、'a'のように'で囲みます。</li>
            <li>数値は、123のようにそのまま記述します。</li>
            <li>論理値は、true,falseのようにそのまま記述します。</li>
            <li>new java.util.Date(0)のようにクラスの完全限定名でコンストラクタを呼び出すことができます。</li>
            <li> @java.lang.Math@max(1, 2)のようにstaticなメソッドを呼び出した結果を参照することができます。</li>
            <li>@java.lang.String@classのようにクラスを参照できます。</li>
            <li>hoge.toString()のようにコンポーネントのメソッドを呼び出した結果を参照することができます。この例は、どこかでhogeという名前のコンポーネントが定義されているという前提です。</li>
            </ul>
            詳しくは、<a href="http://www.ognl.org/2.6.7/Documentation/html/LanguageGuide/index.html">OGNLのマニュアル</a>を参照してください。<br/>
            <br/>

<h2><a name="AnnotationReference">S2Containerアノテーションリファレンス</a></h2>
<p>S2Containerでは、アノテーションの実装方法として､
Tigerアノテーション､backport175アノテーション､定数アノテーションの3種類を用意しています。一般的にアノテーションといえば､Java 5から導入された
Tigerアノテーションですが､それだけだと、JDK1.4のユーザが利用できなくなってしまいます。</p>
<p>できるだけ、多くの方にアノテーションを便利に使ってもらいたいため､JDK1.4で、
Tiger風アノテーション(JSR-175)を使うことのできる
<a href="http://backport175.codehaus.org/">backport175</a>アノテーション、public static finalな定数を利用する定数アノテーションを用意しています。 </p>

<h3><a name="ComponentAnnotation">Componentアノテーション</a></h3>
<p><a href="#componentTag">componentタグ</a>のかわりに使えるのが、Componentアノテーションです。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Component(name="xxx", instance=InstanceType.PROTOTYPE,
        autoBinding=AutoBindingType.PROPERTY)
public class Xxx {
    ...
}
</pre>
<p>backport175アノテーションは以下のようになります。</p>
<pre>
/**
 * @org.seasar.framework.container.annotation.backport175.Component(
 *      name = "xxx",
 *      instance = "prototype",
 *      autoBinding = "property")
 */
public class Xxx {
    ...
}
</pre>
<p>定数アノテーションは以下のようになります。</p>
<pre>
public static final String COMPONENT =
  "name = xxx, instance = prototype, autoBinding = property";
</pre>

<h3><a name="BindingAnnotation">Bindingアノテーション</a></h3>
<p><a href="#propertyTag">propertyタグ</a>のかわりに使えるのが、Bindingアノテーションです。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Binding("aaa2")
public void setAaa(String aaa) {
    ...
}

@Binding(bindingType=BindingType.NONE)
public void setBbb(String bbb) {
    ...
}

@Binding
public void setCcc(String ccc) {
    ...
}
</pre>
<p>backport175アノテーションは以下のようになります。</p>
<pre>
/**

 * @org.seasar.framework.container.annotation.backport175.Binding("aaa2")
 */
public void setAaa(String aaa) {
    ...
}

/**
 * @org.seasar.framework.container.annotation.backport175.Binding(bindingType="none")
 */
public void setBbb(String bbb) {
    ...
}

/**
 * @org.seasar.framework.container.annotation.backport175.Binding
 */
public void setCcc(String ccc) {
    ...
}
</pre>
<p>定数アノテーションはプロパティ名_BINDINGで指定します。</p>
<pre>
public static final String aaa_BINDING = "aaa2";

public static final String bbb_BINDING = "bindingType=none";

public static final String ccc_BINDING = null;

public void setAaa(String aaa) {
    ...
}

public void setBbb(String bbb) {
    ...
}

public void setCcc(String ccc) {
    ...
}
</pre>

<h3><a name="AspectAnnotation">Aspectアノテーション</a></h3>
<p><a href="aop.html#aspectTag">aspectタグ</a>のかわりに使えるのが、Aspectアノテーションです。aspectタグと異なり､複数定義することはできないので､
複数のインターセプタを適用したい場合は､<a href="aop.html#InterceptorChain">InterceptorChain</a>を使ってください。ポイントカットを指定したいときは､pointcut属性を指定します。クラスに対するアノテーションの場合､pointcutを指定しないときは､そのクラスが実装しているすべてのインターフェースのメソッドが対象になります。</p>
<p>Tigerアノテーションは以下のようになります。</p>
<pre>
@Aspect("aop.traceInterceptor")
public class Xxx {
    ...
}

public class Xxx {
    ...
    @Aspect("aop.traceInterceptor")
    public void hoge() {
        ...
    }
}
</pre>
<p>backport175アノテーションは以下のようになります。</p>
<pre>
/**
 * @org.seasar.framework.container.annotation.backport175.Aspect(
 *  "aop.traceInterceptor")
 */
public class Xxx {
    ...
}

public class Xxx {
    ...
    /**
     * @org.seasar.framework.container.annotation.backport175.Aspect(
     *  "aop.traceInterceptor")
     */
    public void hoge() {
        ...
    }
}
</pre>
<p>定数アノテーションは以下のようになります。pointcutを複数指定したい場合は､pointcut= get.*\nexecute.*のように\nで区切ってください。
\n以外の区切り文字を使ってはいけません。</p>
<pre>
public static final String ASPECT =
    "interceptor=aop.traceInterceptor, pointcut=getAaa";
</pre>


<!-- document end -->
<!-- don't edit start -->
</td>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="14"><img height="30" width="14" src="images/spacer.gif" alt=""></td>
<td width="766"><img height="30" width="592" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
<td width="766" class="copyright">Copyright&copy; 2004-2005, The Seasar Foundation and the others. All rights reserved.</td>
</tr></table>
<td class="backright" align="left" valign="top">&nbsp;</td></tr><tr>
<td class="backunder" align="left"  valign="top" width="780" height="16">&nbsp;</td>
<td class="backcorner" align="left" valign="top" height="16">&nbsp;</td>
</tr></table></body>
<!-- don't edit end -->
</html>
